<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆入门 on f1ow-blog</title><link>https://zp9080.github.io/tags/%E5%A0%86%E5%85%A5%E9%97%A8/</link><description>Recent content in 堆入门 on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://zp9080.github.io/tags/%E5%A0%86%E5%85%A5%E9%97%A8/rss.xml" rel="self" type="application/rss+xml"/><item><title>basic skills</title><link>https://zp9080.github.io/post/%E5%A0%86/basic-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/basic-skills/</guid><description>[TOC] 各个bin的大小 以下皆为chunk的大小： fastbin:0x20-0x80 smallbin:&amp;lt;=0x3f0 largebin:&amp;gt;=0x400 tcache:0x20-0x410 unlink unlink 的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）比如当</description></item><item><title>personal skills</title><link>https://zp9080.github.io/post/%E5%A0%86/personal-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/personal-skills/</guid><description>注意二级指针，*的作用是解引用，把它想成访问地址又形象又好理解 学会画图很重要 注意malloc的大小和实际开辟的chunk的大小 传给free的</description></item><item><title>保护机制变动</title><link>https://zp9080.github.io/post/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</guid><description>一篇讲这个的博客 house系列 tcachebin 堆指针异或加密（glibc-2.32 引入） fastbin 堆指针异或加密（glibc-2.32 引入） 堆内存对齐检查（gli</description></item><item><title>打法总述</title><link>https://zp9080.github.io/post/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</guid><description>[TOC] 打法总述 笔者对于这些攻击手法感觉不是很难，难的地方在于堆风水 有无off-by-null 一般没有uaf都是会有off-by-null可以利用</description></item><item><title>堆tricks</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86tricks/</guid><description>[TOC] 1. 泄露libcbase，heapbase 2. 打free_hook或IO_FILE 保护机制 泄露heapbase 一般想要泄露heapbase的情</description></item><item><title>堆分配（自己复现）</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</guid><description>[TOC] 一篇讲的比较清楚的博客 malloc函数 说明：first chunk是指bin中链表头部的chunk,last chunk是指bin中链表尾部的</description></item><item><title>堆分配机制</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</guid><description>[TOC] 一篇讲的很好的博客 概念明晰 bins的链表用的是头插法 fd和bk只在bins才有 在堆中prev chunk就是比它地址低的，next chunk</description></item></channel></rss>