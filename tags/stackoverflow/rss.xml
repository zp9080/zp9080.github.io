<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stackoverflow on f1ow-blog</title><link>https://zp9080.github.io/tags/stackoverflow/</link><description>Recent content in Stackoverflow on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://zp9080.github.io/tags/stackoverflow/rss.xml" rel="self" type="application/rss+xml"/><item><title>csu_init</title><link>https://zp9080.github.io/post/stackoverflow/csu_init/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/csu_init/</guid><description>[TOC] 代码部分 csu_front_addr csu_end_addr 注意不要add rsp,8 function应当是所要调用的函数在栈或bss段上的地址，这样call [r12+rbx*8]才能正确，因为要</description></item><item><title>dynamic sections</title><link>https://zp9080.github.io/post/stackoverflow/dynamic-sections/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/dynamic-sections/</guid><description>[TOC] Global Offset Table GOT 表在 ELF 文件中分为两个部分： .got，存储导入变量的地址。 .got.plt，存储导入函数的地址。 在 Linux 的实现中，.got.plt 的前三</description></item><item><title>hijackgot</title><link>https://zp9080.github.io/post/stackoverflow/hijackgot/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/hijackgot/</guid><description>我们知道每次调用外部函数，我们必定会到GOT表中查询外部函数的真实地址，那么如果我们能将GOT中外部函数的地址修改为我们的目标函数，就可以实</description></item><item><title>mprotect</title><link>https://zp9080.github.io/post/stackoverflow/mprotect/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/mprotect/</guid><description>mprotect可以修改一个区域的权限 void mprotect(void *address, size_t length, int prot); address: 这是要操作的内存区域的起始地址。通常是一个 void 指针，可以指向任何类型的数据。 length: 这是要操作</description></item><item><title>one_gadget</title><link>https://zp9080.github.io/post/stackoverflow/one_gadget/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/one_gadget/</guid><description>ogg</description></item><item><title>ret2dlresolve</title><link>https://zp9080.github.io/post/stackoverflow/ret2dlresolve/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/ret2dlresolve/</guid><description>[TOC] 参考博客 适用于NO RELRO, Partial RELRO，在64位中一般都是打linkmap结构体，板子题 攻击模板 总结地说，我们需要 st_other != 0 l -&amp;gt; l_addr = system_libc - a_libc</description></item><item><title>sandbox</title><link>https://zp9080.github.io/post/stackoverflow/sandbox/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/sandbox/</guid><description>[TOC] sandbox sandbox检测工具 seccomp-tools dump ./file 有时候直接用这个指令没有检测到沙盒，一般是因为程序还没有执行到沙盒，随便输入执行到沙盒就行 prctl函数 可以</description></item><item><title>srop</title><link>https://zp9080.github.io/post/stackoverflow/srop/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/srop/</guid><description>[TOC] 一些重要理解 rsp必须必须指向fake_frame的底部，不然sigreturn无法正常执行 fake_frame中的rip的值就是sigr</description></item><item><title>stack_migration</title><link>https://zp9080.github.io/post/stackoverflow/stack_migration/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/stack_migration/</guid><description>[TOC] 栈迁移 栈迁移的核心是leave_ret指令，要清楚leave_ret指令的作用 栈迁移：rbp覆盖为我们想要转移到的地址-8（注意有个pop</description></item><item><title>函数参数传递</title><link>https://zp9080.github.io/post/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>64位函数参数传递 主要区别在于第4个参数，一般函数调用第4个参数是rcx存储，系统调用是r10存储</description></item><item><title>栈对齐</title><link>https://zp9080.github.io/post/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</guid><description>高版本的Ubuntu执行system或者printf需要高16位栈对齐 一般的做法就是垫一个ret或者不要system完整函数里面的pop rbp 后</description></item></channel></rss>