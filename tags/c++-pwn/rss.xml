<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Pwn on f1ow-blog</title><link>https://zp9080.github.io/tags/c++-pwn/</link><description>Recent content in C++ Pwn on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://zp9080.github.io/tags/c++-pwn/rss.xml" rel="self" type="application/rss+xml"/><item><title>C++</title><link>https://zp9080.github.io/post/c++-pwn/c++/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++/</guid><description>std::allocator std::allocator::allocator 是 C++ 标准库中的一个类构造函数。它属于 std::allocator 类的一部分，用于分配和管理内存，特别是用于分配字符 (char) 类型的内存。 在使用 std::allocator 时，通常不需要显式调用 std::allocator::allocator 构</description></item><item><title>C++libc配置</title><link>https://zp9080.github.io/post/c++-pwn/c++libc%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++libc%E9%85%8D%E7%BD%AE/</guid><description>参考的是这篇文章 方法一 直接在相应的ubuntu版本下写题 方法二 在相应的ubuntu中创建C++文件,并且g++ -g test.cpp -o test,然后直接去指向</description></item><item><title>C++异常处理</title><link>https://zp9080.github.io/post/c++-pwn/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>[TOC] 参考博客 源码分析 原理 介绍 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误</description></item><item><title>vtable</title><link>https://zp9080.github.io/post/c++-pwn/vtable/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/vtable/</guid><description>例题 SICTF ROUND3 ezcpp 题目分析 题目上来泄露出了pie，也有后门函数，然后是两个功能get和print，核心思路是劫持vtable 细节阐述 对ida反汇编的</description></item><item><title>栈溢出</title><link>https://zp9080.github.io/post/c++-pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/</guid><description>例题 SICTF ROUND3 overflow 漏洞在这里，cin是不限制读入长度的，但是要注意不要用space,\n，那么operator=就相当于任意写，而buf又在栈上，把</description></item><item><title>知识学习</title><link>https://zp9080.github.io/post/c++-pwn/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid><description>C++知识点 * __int64 v1; // rax v1 = std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, &amp;#34;What do you want to say?&amp;#34;); std命名空间，operator&amp;laquo;是重载运算符函数，&amp;laquo;&amp;lt;std::ch</description></item></channel></rss>