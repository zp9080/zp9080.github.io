<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>堆杂记 on f1ow-blog</title><link>https://zp9080.github.io/categories/%E5%A0%86%E6%9D%82%E8%AE%B0/</link><description>Recent content in 堆杂记 on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 27 Nov 2024 20:05:08 +0800</lastBuildDate><atom:link href="https://zp9080.github.io/categories/%E5%A0%86%E6%9D%82%E8%AE%B0/rss.xml" rel="self" type="application/rss+xml"/><item><title>有关realloc的堆攻击</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E6%9C%89%E5%85%B3realloc%E7%9A%84%E5%A0%86%E6%94%BB%E5%87%BB/</link><pubDate>Wed, 27 Nov 2024 20:05:08 +0800</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E6%9C%89%E5%85%B3realloc%E7%9A%84%E5%A0%86%E6%94%BB%E5%87%BB/</guid><description/></item><item><title>exit</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</guid><description>[TOC] exit_hook攻击 ​glibc-2.34​ 后失效 区分_exit()与exit() _exit()就是一个简单的系统调用syscall #include &amp;lt;unistd.h&amp;gt;</description></item><item><title>house of husk</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</guid><description>参考博客1 参考博客2 效果是执行一次call，一般都是打ogg 这个spec对应的字符对应的偏移就是其ASCII码 漏洞原理 ​printf​ 函数通</description></item><item><title>off-by-one</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</guid><description>参考博客 off-by-one确实比off-by-null好打多了 注意off-by-one构造overlapping chunk的时候要使得通过</description></item><item><title>partial overwrite</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</guid><description>[TOC] 程序没有show函数，当堆块被free后，如果还可以edit，那么就可以通过partial overwrite来进行泄露进而爆破申请出想要申</description></item><item><title>unsafe unlink</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</guid><description>[TOC] 核心 这个技巧适用于no pie的情况下使用 chunk 0 ptr store in &amp;amp;ptr malloc(0x420) # not in fastbin or tcache malloc(0x420) edit(0, p64(0)+p64(fake_size)+p64(&amp;amp;ptr-0x18)+p64(&amp;amp;ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x430-0x10 限制: overflow ,可以修改prev_inuse触发fake chunk unlink</description></item><item><title>低版本off-by-null</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</guid><description>off-by-null 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出</description></item><item><title>高版本off-by-null</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</guid><description>[TOC] 思路分析 贴一个 参考博客 多了几个步骤： 一个伪造fake chunk的过程 伪造了size还得满足__builtin_expect (fd-&amp;gt;bk != p || bk-&amp;gt;fd != p, 0</description></item><item><title>高版本打tcache</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</guid><description>[TOC] 前言 在此之前，笔者libc2.35都固化思维地只会largebin attack然后打IO，一遇到高版本还打tcache的好像束手无策 但是l</description></item><item><title>关于泄露</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</guid><description>打NKCTF2024有一个libc2.23的堆题，虽然笔者不太会libc2.23的堆还是想看一看这个题 堆溢出里面泄露不要只想着传统的通过ch</description></item></channel></rss>