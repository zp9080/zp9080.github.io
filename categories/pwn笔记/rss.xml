<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PWN笔记 on f1ow-blog</title><link>https://zp9080.github.io/categories/pwn%E7%AC%94%E8%AE%B0/</link><description>Recent content in PWN笔记 on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 11 Jan 2025 21:18:58 +0800</lastBuildDate><atom:link href="https://zp9080.github.io/categories/pwn%E7%AC%94%E8%AE%B0/rss.xml" rel="self" type="application/rss+xml"/><item><title>汇编</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/</link><pubDate>Sat, 11 Jan 2025 21:18:58 +0800</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/</guid><description/></item><item><title>crt pwn</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/crt-pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/crt-pwn/</guid><description>打NKCTF2024遇到的一个题，还比较有意思，pwn中结合了密码相关的知识 后面的内容很简单，就是写入p64()*4，因此刚好可以getsh</description></item><item><title>ctypes</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/ctypes/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/ctypes/</guid><description>用python中的库实现C from pwn import * from ctypes import * from pwnlib.util.packing import p64 p = remote(&amp;#39;10.131.194.201&amp;#39;,59746) LIBC = CDLL(&amp;#39;libc.so.6&amp;#39;) seed = LIBC.time(0) LIBC.srand(seed) x = LIBC.rand() payload = str(x).encode() p.sendline(payload) p.interactive()</description></item><item><title>dbg小技巧</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>fp tls disass search -p, &amp;ndash;pointer Search for a pointer-width integer ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;mov rdx, qword ptr [rdi + 8]&amp;rsquo; ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;rdx.*rdi&amp;rsquo; 搜索包含同时出现rdx和rdi寄存器的指令 .*是一个正则表达式，表示匹配任意字符零</description></item><item><title>printf函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/printf%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/printf%E5%87%BD%E6%95%B0/</guid><description>奇怪的知识点，printf函数会有个判断al的值是否为0的操作来判断是否进行浮点数操作</description></item><item><title>setuid</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/setuid/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/setuid/</guid><description>最近做了一个题执行了system(&amp;quot;/bin/sh&amp;quot;)后发现flag只有root才有read权限，这里要提权 可以参考此篇</description></item><item><title>skills</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/skills/</guid><description>有read函数最好用send，scanf和gets必须用sendline init函数也要查看，有时候一些变量的初始化就在其中 strlen的绕</description></item><item><title>system_execve函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/system_execve%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/system_execve%E5%87%BD%E6%95%B0/</guid><description>[TOC] system函数 system(&amp;quot;$0&amp;quot;) system(&amp;ldquo;sh&amp;rdquo;) system(&amp;quot;/bin/sh&amp;quot;) system(&amp;quot;/bin//sh&amp;quot;)都可以拿到shell cat *：是一个在命令行中使用的Unix/L</description></item><item><title>templates</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/templates/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/templates/</guid><description>[TOC] recv canary=int(sh.recvuntil(b&amp;quot;00&amp;quot;).decode(),16) buffer= int(p.recv(14), 16) 两个十六进制是一个字节，但是printf函数打印是一个字符一个字符的打印，一个字符是一个字节，所以0x7ffec1484618也</description></item><item><title>tricks</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/tricks/</guid><description>[TOC] 做题步骤 第一步先checksec(checksec至关重要，因为如果partial rello那么很可能会打got，然后no pie这种很可能</description></item><item><title>反弹shell</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%BC%B9shell/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%BC%B9shell/</guid><description>[TOC] 参考博客 关闭了标准输入、标准输出、标准错误时可以利用反弹shell 反弹shell connect()+dupsh() - 反连 实测这种最好用,这里的ip要填写自己的wsl的ip</description></item><item><title>浮点数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0/</guid><description>用float-toy可以很方便的构造浮点数</description></item><item><title>利用函数返回值设置rax</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</guid><description>利用函数返回值设置rax参数其实是一种挺常见的技巧，read函数可以设置rax，strtol也可以设置rax 这里写的题目是vnctf2023</description></item><item><title>盲注</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E7%9B%B2%E6%B3%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E7%9B%B2%E6%B3%A8/</guid><description>对于盲注，最关键的地方就是根据已有经验去猜 例题 SICTF ROUND3 ezsignin 题目描述，ubuntu:22.04 libc2.35 这个题通过尝试应该是个无限read+printf 解题</description></item><item><title>游戏逆向pwn</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</guid><description>一个逆向游戏题,这里有个很明显的任意写漏洞 if ( op == &amp;#39;l&amp;#39; ) player_tile = getchar(); *(_BYTE *)(row[1] + buf + 90 * *row) = player_tile; 但这里有个很恶心的地方*(_BYTE *)(row[1] + buf + 90 * *row) = 0x2E; 这个地</description></item><item><title>有关system函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</guid><description>[TOC] 最近写了vnctf2023的traveler一题，一眼看出是栈迁移，题目也给了system函数，但是卡了很久 但是要注意一个很坑的地方，就是</description></item><item><title>做题遇到的函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</guid><description>[TOC] strtoull函数 munmap函数 setvbuf函数 fgets函数 char *fgets(char *str, int n, FILE *stream); fgets() 从 stream 中读取字符，直到读取了 n-1 个字符、读取并转移到字符串</description></item></channel></rss>