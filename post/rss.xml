<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on f1ow-blog</title><link>https://zp9080.github.io/post/</link><description>Recent content in Posts on f1ow-blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Thu, 27 Feb 2025 17:57:37 +0800</lastBuildDate><atom:link href="https://zp9080.github.io/post/rss.xml" rel="self" type="application/rss+xml"/><item><title>zsh</title><link>https://zp9080.github.io/post/tools/zsh/</link><pubDate>Thu, 27 Feb 2025 17:57:37 +0800</pubDate><guid>https://zp9080.github.io/post/tools/zsh/</guid><description/></item><item><title>经验总结</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 14 Feb 2025 17:00:43 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</guid><description/></item><item><title>Linux系统</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 03 Feb 2025 14:24:32 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>2025西湖论剑babytrace</title><link>https://zp9080.github.io/post/shellcode/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91babytrace/</link><pubDate>Sun, 19 Jan 2025 10:54:10 +0800</pubDate><guid>https://zp9080.github.io/post/shellcode/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91babytrace/</guid><description/></item><item><title>CCBCISCN初赛</title><link>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/ccbciscn%E5%88%9D%E8%B5%9B/</link><pubDate>Sat, 11 Jan 2025 21:27:26 +0800</pubDate><guid>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/ccbciscn%E5%88%9D%E8%B5%9B/</guid><description/></item><item><title>汇编</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/</link><pubDate>Sat, 11 Jan 2025 21:18:58 +0800</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/</guid><description/></item><item><title>强网杯S8决赛qvm</title><link>https://zp9080.github.io/post/vm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AFs8%E5%86%B3%E8%B5%9Bqvm/</link><pubDate>Fri, 10 Jan 2025 20:31:51 +0800</pubDate><guid>https://zp9080.github.io/post/vm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AFs8%E5%86%B3%E8%B5%9Bqvm/</guid><description/></item><item><title>CCBCISCN初赛avm</title><link>https://zp9080.github.io/post/vm-pwn/ccbciscn%E5%88%9D%E8%B5%9Bavm/</link><pubDate>Fri, 10 Jan 2025 19:19:06 +0800</pubDate><guid>https://zp9080.github.io/post/vm-pwn/ccbciscn%E5%88%9D%E8%B5%9Bavm/</guid><description/></item><item><title>2025全国大学生软件创新大赛软件系统安全赛vm</title><link>https://zp9080.github.io/post/vm-pwn/2025%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9Bvm/</link><pubDate>Fri, 10 Jan 2025 16:37:57 +0800</pubDate><guid>https://zp9080.github.io/post/vm-pwn/2025%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9Bvm/</guid><description/></item><item><title>Intellij</title><link>https://zp9080.github.io/post/tools/intellij/</link><pubDate>Thu, 19 Dec 2024 21:11:33 +0800</pubDate><guid>https://zp9080.github.io/post/tools/intellij/</guid><description/></item><item><title>知识盲区</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/</link><pubDate>Thu, 19 Dec 2024 19:56:59 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/</guid><description/></item><item><title>编程规范</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link><pubDate>Thu, 19 Dec 2024 17:23:01 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid><description/></item><item><title>编程语言笔记</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 02 Dec 2024 22:32:15 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</guid><description/></item><item><title>快捷键</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Sat, 30 Nov 2024 21:52:27 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description/></item><item><title>有关realloc的堆攻击</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E6%9C%89%E5%85%B3realloc%E7%9A%84%E5%A0%86%E6%94%BB%E5%87%BB/</link><pubDate>Wed, 27 Nov 2024 20:05:08 +0800</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E6%9C%89%E5%85%B3realloc%E7%9A%84%E5%A0%86%E6%94%BB%E5%87%BB/</guid><description/></item><item><title>2024鹏程杯vm</title><link>https://zp9080.github.io/post/vm-pwn/2024%E9%B9%8F%E7%A8%8B%E6%9D%AFvm/</link><pubDate>Sun, 10 Nov 2024 00:37:27 +0800</pubDate><guid>https://zp9080.github.io/post/vm-pwn/2024%E9%B9%8F%E7%A8%8B%E6%9D%AFvm/</guid><description>&lt;ul>
&lt;li>记录一下这个vm的复现过程&lt;/li>
&lt;/ul>
&lt;h2 id="题目分析">题目分析
&lt;a class="header-anchor" href="#%e9%a2%98%e7%9b%ae%e5%88%86%e6%9e%90">&lt;/a>
&lt;/h2></description></item><item><title>双写绕过</title><link>https://zp9080.github.io/post/web-pwn/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/</link><pubDate>Sat, 09 Nov 2024 23:57:01 +0800</pubDate><guid>https://zp9080.github.io/post/web-pwn/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/</guid><description/></item><item><title>从rust堆看堆块伪造</title><link>https://zp9080.github.io/post/rust-pwn/%E4%BB%8Erust%E5%A0%86%E7%9C%8B%E5%A0%86%E5%9D%97%E4%BC%AA%E9%80%A0/</link><pubDate>Fri, 08 Nov 2024 09:07:41 +0800</pubDate><guid>https://zp9080.github.io/post/rust-pwn/%E4%BB%8Erust%E5%A0%86%E7%9C%8B%E5%A0%86%E5%9D%97%E4%BC%AA%E9%80%A0/</guid><description/></item><item><title>go中的栈溢出</title><link>https://zp9080.github.io/post/go-pwn/go%E4%B8%AD%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/</link><pubDate>Wed, 06 Nov 2024 23:04:56 +0800</pubDate><guid>https://zp9080.github.io/post/go-pwn/go%E4%B8%AD%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/</guid><description/></item><item><title>AFL++</title><link>https://zp9080.github.io/post/fuzz/afl++/</link><pubDate>Tue, 05 Nov 2024 09:50:25 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/afl++/</guid><description/></item><item><title>libc2.27下的orw</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84orw/</link><pubDate>Mon, 04 Nov 2024 19:19:49 +0800</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84orw/</guid><description>&lt;p>
&lt;a href="https://blog.csdn.net/qq_45595732/article/details/115271623" title="参考文章" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 参考文章
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item><item><title>论文阅读心得</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%BF%83%E5%BE%97/</link><pubDate>Fri, 01 Nov 2024 20:51:48 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%BF%83%E5%BE%97/</guid><description/></item><item><title>Fuzz论文收集</title><link>https://zp9080.github.io/post/fuzz/fuzz%E8%AE%BA%E6%96%87%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 28 Oct 2024 20:55:11 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/fuzz%E8%AE%BA%E6%96%87%E6%94%B6%E9%9B%86/</guid><description/></item><item><title>Fuzzing101笔记</title><link>https://zp9080.github.io/post/fuzz/fuzzing101%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 26 Oct 2024 17:08:27 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/fuzzing101%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>记录一下做这个遇到的问题和理解&lt;/p></description></item><item><title>污点分析初探</title><link>https://zp9080.github.io/post/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</link><pubDate>Fri, 25 Oct 2024 20:29:25 +0800</pubDate><guid>https://zp9080.github.io/post/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</guid><description/></item><item><title>fuzz参考博客</title><link>https://zp9080.github.io/post/fuzz/fuzz%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/</link><pubDate>Fri, 25 Oct 2024 20:27:25 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/fuzz%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/</guid><description/></item><item><title>KLEE</title><link>https://zp9080.github.io/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/klee/</link><pubDate>Fri, 25 Oct 2024 20:21:51 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/klee/</guid><description>&lt;p>
&lt;a href="https://github.com/klee/klee" title="KLEE项目地址" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 KLEE项目地址
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item><item><title>符号执行初探</title><link>https://zp9080.github.io/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E6%8E%A2/</link><pubDate>Fri, 25 Oct 2024 19:35:13 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E6%8E%A2/</guid><description/></item><item><title>源鲁杯-2024 show_me_the_code</title><link>https://zp9080.github.io/post/llvm-pwn/%E6%BA%90%E9%B2%81%E6%9D%AF-2024-show_me_the_code/</link><pubDate>Fri, 25 Oct 2024 15:34:48 +0800</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/%E6%BA%90%E9%B2%81%E6%9D%AF-2024-show_me_the_code/</guid><description/></item><item><title>Hugo二级分类功能</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/hugo%E4%BA%8C%E7%BA%A7%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/</link><pubDate>Thu, 24 Oct 2024 10:32:06 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/hugo%E4%BA%8C%E7%BA%A7%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/</guid><description/></item><item><title>反序列化</title><link>https://zp9080.github.io/post/php/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Wed, 23 Oct 2024 15:55:50 +0800</pubDate><guid>https://zp9080.github.io/post/php/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description/></item><item><title>sql注入绕过</title><link>https://zp9080.github.io/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</link><pubDate>Wed, 23 Oct 2024 15:14:38 +0800</pubDate><guid>https://zp9080.github.io/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</guid><description/></item><item><title>文件包含</title><link>https://zp9080.github.io/post/web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</link><pubDate>Tue, 22 Oct 2024 23:23:57 +0800</pubDate><guid>https://zp9080.github.io/post/web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</guid><description/></item><item><title>php-rce绕过</title><link>https://zp9080.github.io/post/php/php-rce%E7%BB%95%E8%BF%87/</link><pubDate>Tue, 22 Oct 2024 20:32:52 +0800</pubDate><guid>https://zp9080.github.io/post/php/php-rce%E7%BB%95%E8%BF%87/</guid><description>&lt;p>RCE的绕过就是要多多积累&lt;/p></description></item><item><title>php变量覆盖</title><link>https://zp9080.github.io/post/php/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</link><pubDate>Tue, 22 Oct 2024 20:00:58 +0800</pubDate><guid>https://zp9080.github.io/post/php/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</guid><description/></item><item><title>php常见绕过</title><link>https://zp9080.github.io/post/php/php%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87/</link><pubDate>Tue, 22 Oct 2024 19:36:07 +0800</pubDate><guid>https://zp9080.github.io/post/php/php%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87/</guid><description/></item><item><title>XFF与XRI</title><link>https://zp9080.github.io/post/web/xff%E4%B8%8Exri/</link><pubDate>Tue, 22 Oct 2024 00:30:24 +0800</pubDate><guid>https://zp9080.github.io/post/web/xff%E4%B8%8Exri/</guid><description/></item><item><title>文件上传</title><link>https://zp9080.github.io/post/web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Mon, 21 Oct 2024 23:36:46 +0800</pubDate><guid>https://zp9080.github.io/post/web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description/></item><item><title>信息收集</title><link>https://zp9080.github.io/post/web/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 21 Oct 2024 23:28:58 +0800</pubDate><guid>https://zp9080.github.io/post/web/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description/></item><item><title>常见问题</title><link>https://zp9080.github.io/post/web/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 21 Oct 2024 23:10:14 +0800</pubDate><guid>https://zp9080.github.io/post/web/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description/></item><item><title>tricks</title><link>https://zp9080.github.io/post/web/tricks/</link><pubDate>Sun, 20 Oct 2024 11:18:18 +0800</pubDate><guid>https://zp9080.github.io/post/web/tricks/</guid><description/></item><item><title>php语法特性</title><link>https://zp9080.github.io/post/php/php%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</link><pubDate>Sun, 20 Oct 2024 10:24:42 +0800</pubDate><guid>https://zp9080.github.io/post/php/php%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</guid><description/></item><item><title>sql注入初探</title><link>https://zp9080.github.io/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E5%88%9D%E6%8E%A2/</link><pubDate>Sun, 20 Oct 2024 09:26:35 +0800</pubDate><guid>https://zp9080.github.io/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E5%88%9D%E6%8E%A2/</guid><description/></item><item><title>春秋云境 Initial</title><link>https://zp9080.github.io/post/%E6%B8%97%E9%80%8F/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-initial/</link><pubDate>Sat, 19 Oct 2024 23:43:08 +0800</pubDate><guid>https://zp9080.github.io/post/%E6%B8%97%E9%80%8F/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-initial/</guid><description/></item><item><title>Github使用笔记</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/github%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 16 Oct 2024 00:35:10 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/github%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid><description/></item><item><title>GZCTF平台搭建运维</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/gzctf%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E8%BF%90%E7%BB%B4/</link><pubDate>Mon, 14 Oct 2024 23:37:48 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/gzctf%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E8%BF%90%E7%BB%B4/</guid><description/></item><item><title>SCTF2024</title><link>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/sctf2024/</link><pubDate>Wed, 09 Oct 2024 15:46:30 +0800</pubDate><guid>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/sctf2024/</guid><description>&lt;p>[TOC]&lt;/p></description></item><item><title>内核编译</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</link><pubDate>Sun, 06 Oct 2024 16:36:40 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</guid><description/></item><item><title>libc2.27下的house of orange+house of apple2</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84house-of-orange+house-of-apple2/</link><pubDate>Sun, 22 Sep 2024 20:28:50 +0800</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84house-of-orange+house-of-apple2/</guid><description/></item><item><title>llvm中ll文件解读</title><link>https://zp9080.github.io/post/llvm-pwn/llvm%E4%B8%ADll%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 19 Sep 2024 13:49:55 +0800</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/llvm%E4%B8%ADll%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/</guid><description>[TOC] ll文件解析 ll文件中常见变量的理解 @ - 全局变量 % - 局部变量 alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内</description></item><item><title>goahead源码阅读</title><link>https://zp9080.github.io/post/iot/goahead%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Tue, 17 Sep 2024 15:18:52 +0800</pubDate><guid>https://zp9080.github.io/post/iot/goahead%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description/></item><item><title>arm环境搭建</title><link>https://zp9080.github.io/post/iot/arm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 15 Sep 2024 10:07:07 +0800</pubDate><guid>https://zp9080.github.io/post/iot/arm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description/></item><item><title>第四届长城杯网络安全大赛暨京津冀网络安全技能竞赛初赛</title><link>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E4%BA%AC%E6%B4%A5%E5%86%80%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E7%AB%9E%E8%B5%9B%E5%88%9D%E8%B5%9B/</link><pubDate>Sun, 08 Sep 2024 14:25:09 +0800</pubDate><guid>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E4%BA%AC%E6%B4%A5%E5%86%80%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E7%AB%9E%E8%B5%9B%E5%88%9D%E8%B5%9B/</guid><description/></item><item><title>杂记</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/</link><pubDate>Fri, 06 Sep 2024 20:47:51 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/</guid><description/></item><item><title>IOT入门CVE复现</title><link>https://zp9080.github.io/post/iot/iot%E5%85%A5%E9%97%A8cve%E5%A4%8D%E7%8E%B0/</link><pubDate>Thu, 05 Sep 2024 20:08:08 +0800</pubDate><guid>https://zp9080.github.io/post/iot/iot%E5%85%A5%E9%97%A8cve%E5%A4%8D%E7%8E%B0/</guid><description/></item><item><title>路由器环境配置</title><link>https://zp9080.github.io/post/iot/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 05 Sep 2024 15:24:15 +0800</pubDate><guid>https://zp9080.github.io/post/iot/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description/></item><item><title>IOT入门学习</title><link>https://zp9080.github.io/post/iot/iot%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 04 Sep 2024 19:08:36 +0800</pubDate><guid>https://zp9080.github.io/post/iot/iot%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</guid><description/></item><item><title>基于ptrace的沙箱绕过</title><link>https://zp9080.github.io/post/shellcode/%E5%9F%BA%E4%BA%8Eptrace%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/</link><pubDate>Tue, 03 Sep 2024 14:31:33 +0800</pubDate><guid>https://zp9080.github.io/post/shellcode/%E5%9F%BA%E4%BA%8Eptrace%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/</guid><description/></item><item><title>afl-fuzz源码分析下篇</title><link>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/</link><pubDate>Mon, 02 Sep 2024 12:03:30 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/</guid><description>&lt;p>[TOC]&lt;/p>
&lt;h1 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>本篇作为fuzz的最后一篇，核心是fuzz大循环中的内容&lt;/li>
&lt;li>fuzz_one函数很长，笔者将其分为了几个大的过程分析&lt;/li>
&lt;li>&lt;strong>个人认为的重点&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>cull_queue 精简队列，和top_rated有关，重要
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sync_fuzzers 同步fuzzer，这部分现在还没那么重要，但是fuzz实操时为了效率这部分可能会比较重要，初学看看就行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save_if_interesting 这个函数和之前很多内容相关，重要
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fuzz_one及其相关函数 核心函数，重要之重要
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="fuzz大循环">fuzz大循环
&lt;a class="header-anchor" href="#fuzz%e5%a4%a7%e5%be%aa%e7%8e%af">&lt;/a>
&lt;/h1></description></item><item><title>afl-fuzz源码分析中篇</title><link>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%AD%E7%AF%87/</link><pubDate>Sun, 01 Sep 2024 16:51:06 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%AD%E7%AF%87/</guid><description>&lt;p>[TOC]&lt;/p></description></item><item><title>afl-fuzz源码分析上篇</title><link>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A%E7%AF%87/</link><pubDate>Sat, 31 Aug 2024 15:38:00 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A%E7%AF%87/</guid><description/></item><item><title>afl-gcc与afl-as源码阅读</title><link>https://zp9080.github.io/post/fuzz/afl-gcc%E4%B8%8Eafl-as%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Sat, 31 Aug 2024 10:15:00 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/afl-gcc%E4%B8%8Eafl-as%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description/></item><item><title>基于popen函数的攻击</title><link>https://zp9080.github.io/post/web-pwn/%E5%9F%BA%E4%BA%8Epopen%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Thu, 29 Aug 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/web-pwn/%E5%9F%BA%E4%BA%8Epopen%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>2024羊城杯vhttpd 题目没有给libc,保护全开，还是32位，看到这些基本就没有想栈溢出方面的事情了 可以发现这个与以往的web pwn有</description></item><item><title>羊城杯2024</title><link>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/%E7%BE%8A%E5%9F%8E%E6%9D%AF2024/</link><pubDate>Wed, 28 Aug 2024 16:56:52 +0800</pubDate><guid>https://zp9080.github.io/post/wp%E5%90%88%E9%9B%86/%E7%BE%8A%E5%9F%8E%E6%9D%AF2024/</guid><description/></item><item><title>fuzz初探</title><link>https://zp9080.github.io/post/fuzz/fuzz%E5%88%9D%E6%8E%A2/</link><pubDate>Sun, 11 Aug 2024 16:42:17 +0800</pubDate><guid>https://zp9080.github.io/post/fuzz/fuzz%E5%88%9D%E6%8E%A2/</guid><description/></item><item><title>Pwn出题笔记</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/pwn%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 06 Aug 2024 21:10:03 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/pwn%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/</guid><description/></item><item><title>内核攻击方法概述</title><link>https://zp9080.github.io/post/kernel-pwn/%E5%86%85%E6%A0%B8%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</link><pubDate>Tue, 06 Aug 2024 18:45:18 +0800</pubDate><guid>https://zp9080.github.io/post/kernel-pwn/%E5%86%85%E6%A0%B8%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</guid><description/></item><item><title>安卓逆向</title><link>https://zp9080.github.io/post/re/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/</link><pubDate>Mon, 05 Aug 2024 10:22:44 +0800</pubDate><guid>https://zp9080.github.io/post/re/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/</guid><description/></item><item><title>ida用法</title><link>https://zp9080.github.io/post/re/ida%E7%94%A8%E6%B3%95/</link><pubDate>Sat, 03 Aug 2024 18:05:55 +0800</pubDate><guid>https://zp9080.github.io/post/re/ida%E7%94%A8%E6%B3%95/</guid><description/></item><item><title>RE常见算法</title><link>https://zp9080.github.io/post/re/re%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 03 Aug 2024 15:19:03 +0800</pubDate><guid>https://zp9080.github.io/post/re/re%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</guid><description/></item><item><title>Python逆向</title><link>https://zp9080.github.io/post/re/python%E9%80%86%E5%90%91/</link><pubDate>Thu, 01 Aug 2024 16:25:35 +0800</pubDate><guid>https://zp9080.github.io/post/re/python%E9%80%86%E5%90%91/</guid><description/></item><item><title>PE结构体</title><link>https://zp9080.github.io/post/re/pe%E7%BB%93%E6%9E%84%E4%BD%93/</link><pubDate>Thu, 01 Aug 2024 09:50:34 +0800</pubDate><guid>https://zp9080.github.io/post/re/pe%E7%BB%93%E6%9E%84%E4%BD%93/</guid><description>可以参考 这篇博客</description></item><item><title>RE入门</title><link>https://zp9080.github.io/post/re/re%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 01 Aug 2024 09:50:34 +0800</pubDate><guid>https://zp9080.github.io/post/re/re%E5%85%A5%E9%97%A8/</guid><description/></item><item><title>Github学习</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/github%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 01 Aug 2024 09:21:41 +0800</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/github%E5%AD%A6%E4%B9%A0/</guid><description/></item><item><title>AE64</title><link>https://zp9080.github.io/post/shellcode/ae64/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/ae64/</guid><description>AE64 AE64 is a tool which can transform any amd64 architecture shellcode into pure alphanumeric shellcode using self-modify code technology, so the page need to be writable.
Install git clone https://github.com/veritas501/ae64.git --depth 1 cd ae64 sudo python3 setup.py install Usage For usage example, you can see example folder.
Quickstart from ae64 import AE64 from pwn import * context.arch=&amp;#39;amd64&amp;#39; # get bytes format shellcode shellcode = asm(shellcraft.sh()) # get alphanumeric shellcode enc_shellcode = AE64().</description></item><item><title>arm pwn基础知识</title><link>https://zp9080.github.io/post/arm-pwn/arm-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/arm-pwn/arm-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>all in one arm ret2csu 参考博客 arm汇编学习 arm汇编学习 调试 #类似用gdbserver启动运行这个二进制文件 binary_path = &amp;#34;/home/zp9080/PWN/pwn&amp;#34; qemu_bin = &amp;#39;qemu-aarch64&amp;#39; # Ensure this is installed p = process([qemu_bin,&amp;#39;-L&amp;#39;,&amp;#39;/usr/aarch64-linux-gnu/&amp;#39;,&amp;#39;-g&amp;#39;, &amp;#39;1234&amp;#39;, binary_path]) # p = process([qemu_bin, &amp;#39;-L&amp;#39;,&amp;#39;/usr/aarch64-linux-gnu/&amp;#39;,</description></item><item><title>arm pwn例题</title><link>https://zp9080.github.io/post/arm-pwn/arm-pwn%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/arm-pwn/arm-pwn%E4%BE%8B%E9%A2%98/</guid><description>以xyctf2024 EZ2.0?为例题，主要记录一下做题过程 发现pwntools的gdb.debug功能非常强大，可以很方便的调试 第一步看静</description></item><item><title>basic</title><link>https://zp9080.github.io/post/format-string/basic/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/basic/</guid><description>[TOC] 写入的字节数 但是写入4字节，也就是32位一般会太大不让写，所以一般都写入2字节 %n的理解 要利用%k$n这个特性，%n的特性：不输出字符，但</description></item><item><title>basic skills</title><link>https://zp9080.github.io/post/%E5%A0%86/basic-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/basic-skills/</guid><description>[TOC] 各个bin的大小 以下皆为chunk的大小： fastbin:0x20-0x80 smallbin:&amp;lt;=0x3f0 largebin:&amp;gt;=0x400 tcache:0x20-0x410 unlink unlink 的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）比如当</description></item><item><title>basic_shellcode</title><link>https://zp9080.github.io/post/shellcode/basic_shellcode/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/basic_shellcode/</guid><description>[TOC] 注意架构 通常情况下，pwntools 会根据您的操作系统和系统架构来自动选择合适的默认架构。如果您在64位操作系统上运行 pwntools，它</description></item><item><title>C++</title><link>https://zp9080.github.io/post/c++-pwn/c++/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++/</guid><description>std::allocator std::allocator::allocator 是 C++ 标准库中的一个类构造函数。它属于 std::allocator 类的一部分，用于分配和管理内存，特别是用于分配字符 (char) 类型的内存。 在使用 std::allocator 时，通常不需要显式调用 std::allocator::allocator 构</description></item><item><title>C++libc配置</title><link>https://zp9080.github.io/post/c++-pwn/c++libc%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++libc%E9%85%8D%E7%BD%AE/</guid><description>参考的是这篇文章 方法一 直接在相应的ubuntu版本下写题 方法二 在相应的ubuntu中创建C++文件,并且g++ -g test.cpp -o test,然后直接去指向</description></item><item><title>C++异常处理</title><link>https://zp9080.github.io/post/c++-pwn/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>[TOC] 参考博客 源码分析 原理 介绍 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误</description></item><item><title>CISCN-2021 satool</title><link>https://zp9080.github.io/post/llvm-pwn/ciscn-2021-satool/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/ciscn-2021-satool/</guid><description>刚做完红帽杯那个入门题来写这个，一看代码500多行的re直接不想看了，后来跟着这个博客过了一遍，收获不少 参考博客 核心思想 做llvm pass首</description></item><item><title>crt pwn</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/crt-pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/crt-pwn/</guid><description>打NKCTF2024遇到的一个题，还比较有意思，pwn中结合了密码相关的知识 后面的内容很简单，就是写入p64()*4，因此刚好可以getsh</description></item><item><title>csu_init</title><link>https://zp9080.github.io/post/stackoverflow/csu_init/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/csu_init/</guid><description>[TOC] 代码部分 csu_front_addr csu_end_addr 注意不要add rsp,8 function应当是所要调用的函数在栈或bss段上的地址，这样call [r12+rbx*8]才能正确，因为要</description></item><item><title>ctypes</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/ctypes/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/ctypes/</guid><description>用python中的库实现C from pwn import * from ctypes import * from pwnlib.util.packing import p64 p = remote(&amp;#39;10.131.194.201&amp;#39;,59746) LIBC = CDLL(&amp;#39;libc.so.6&amp;#39;) seed = LIBC.time(0) LIBC.srand(seed) x = LIBC.rand() payload = str(x).encode() p.sendline(payload) p.interactive()</description></item><item><title>D3BabyEscape</title><link>https://zp9080.github.io/post/qemu-pwn/d3babyescape/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/qemu-pwn/d3babyescape/</guid><description>[TOC] 学完qemu逃逸后的第一题，这个题难点在于要逆向 题目分析 如何开始逆向 首先根据-device启动参数知道设备是l0dev，接下来进行逆向。逆</description></item><item><title>D3CTF PwnShell</title><link>https://zp9080.github.io/post/php-pwn/d3ctf-pwnshell/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/php-pwn/d3ctf-pwnshell/</guid><description>[TOC] 参考博客1 题目分析 题目中add是一个堆块ck2存另一个堆块的地址ck1，这就有了利用的机会，如果可以控制ck2的内容，那么就有任意地址写 e</description></item><item><title>dbg小技巧</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>fp tls disass search -p, &amp;ndash;pointer Search for a pointer-width integer ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;mov rdx, qword ptr [rdi + 8]&amp;rsquo; ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;rdx.*rdi&amp;rsquo; 搜索包含同时出现rdx和rdi寄存器的指令 .*是一个正则表达式，表示匹配任意字符零</description></item><item><title>decrypt safe unlink</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/decrypt-safe-unlink/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/decrypt-safe-unlink/</guid><description>[TOC] 这篇博客已经讲的很详细了 与libc2.31有些许不同的地方就是libc2.32多加了对next域的限制，稍作修改即可 代码 from pwn import * from pwnlib.util.packing import p64 from</description></item><item><title>docker</title><link>https://zp9080.github.io/post/tools/docker/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/docker/</guid><description>docker的安装与使用 docker常用命令 docker在pwn中的使用 在docker中搭建pwn环境 vscode连接docker容器 doc</description></item><item><title>dynamic sections</title><link>https://zp9080.github.io/post/stackoverflow/dynamic-sections/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/dynamic-sections/</guid><description>[TOC] Global Offset Table GOT 表在 ELF 文件中分为两个部分： .got，存储导入变量的地址。 .got.plt，存储导入函数的地址。 在 Linux 的实现中，.got.plt 的前三</description></item><item><title>exit</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</guid><description>[TOC] exit_hook攻击 ​glibc-2.34​ 后失效 区分_exit()与exit() _exit()就是一个简单的系统调用syscall #include &amp;lt;unistd.h&amp;gt;</description></item><item><title>fastbin attack</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin-attack/</guid><description>[TOC] 核心： 1.存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞 2.漏洞发生于 fastbin 类型的 chunk 中 3.fastbin的单项链表结构,fd指针</description></item><item><title>fastbin reverse into tcache</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/fastbin-reverse-into-tcache/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/fastbin-reverse-into-tcache/</guid><description>[TOC] 参考博客1 参考博客2 低版本 在2.27-2.31版本中，没有对fd指针加密，所以在利用的时候非常简单，只需要将tcache填满，然后放7个c</description></item><item><title>fastbin错位构造</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin%E9%94%99%E4%BD%8D%E6%9E%84%E9%80%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin%E9%94%99%E4%BD%8D%E6%9E%84%E9%80%A0/</guid><description>通过错位构造\x7f可以得到malloc_hook edit(0x10,p64(libc.sym[&amp;#39;__malloc_hook&amp;#39;]-0x23)) add(0x68,b&amp;#34;A&amp;#34;*8) add(0x68,b&amp;#34;\x00&amp;#34;*0x13 + p64(one_gadget))</description></item><item><title>FastCP</title><link>https://zp9080.github.io/post/qemu-pwn/fastcp/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/qemu-pwn/fastcp/</guid><description>[TOC] 主要参考了这个博客 入门qemu逃逸第一题，花了好几天时间才把所有的细节搞明白 题目分析 题目名字就是fastcp，所以ida直接搜发现这些有关</description></item><item><title>fmtstr_payload</title><link>https://zp9080.github.io/post/format-string/fmtstr_payload/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/fmtstr_payload/</guid><description>[TOC] 适用情况 这个工具只适用于栈上的格式化字符串，可以参考offset变量的设置要求 这个工具写入的数据直接是一个size_t类型，所以如果限制输</description></item><item><title>format_string-skills</title><link>https://zp9080.github.io/post/format-string/format_string-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/format_string-skills/</guid><description>[TOC] 一般rsp为相对格式化字符串的第5或6个参数 打ogg只用写入几个字节 返回地址本身就是Libc里面的函数 那么我们写入的时候为了省事其实可以只</description></item><item><title>gdbserver</title><link>https://zp9080.github.io/post/tools/gdbserver/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/gdbserver/</guid><description>GDB Server的远程调试功能 利用gdbserver apt-get install openssh-server apt-get install gdb apt-get install gdbserver apt install net-tools apt install iptables 在docker中gdbserver docker_ip:6666 file_addr args 然后在虚拟机中gdb</description></item><item><title>go语法特性</title><link>https://zp9080.github.io/post/go-pwn/go%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/go-pwn/go%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</guid><description>参考博客1 string,slice,多个返回值 内置数据类型 len与cap stringtoslicebyte memmove go的函数调用约定是这样的，传参用到的寄存器依次是：AX，BX，</description></item><item><title>hijackgot</title><link>https://zp9080.github.io/post/stackoverflow/hijackgot/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/hijackgot/</guid><description>我们知道每次调用外部函数，我们必定会到GOT表中查询外部函数的真实地址，那么如果我们能将GOT中外部函数的地址修改为我们的目标函数，就可以实</description></item><item><title>house of apple1</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/</guid><description>[TOC] 参考博客 house of apple1 需要和其他方法结合而进行后续的FSOP利用 _IO_wstrn_jumps 前言 利用条件 使用house of apple的条件为： 1、程序从main函数返回或能调</description></item><item><title>house of apple2</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple2/</guid><description>[TOC] 参考博客 house of apple2心得体会 house of apple2可以在只劫持_wide_data的条件下控制程序的执行流!!! fp的vtable覆盖为_I</description></item><item><title>house of botcake</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/house-of-botcake/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/house-of-botcake/</guid><description>house of botcake 可以看看这篇文章 house of botcake一般都会配合tcache poison一起打 打tcache poison时如果限制了malloc的chu</description></item><item><title>house of cat</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-cat/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-cat/</guid><description>[TOC] 参考博客 参考博客 house of cat在_IO_switch_to_wget_mode可以设置rdx,随后调用setcontent+61可以直接进行o</description></item><item><title>house of emma</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-emma/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-emma/</guid><description>[TOC] 参考文章 例题详解 _IO_cookie_jumps中的_IO_cookie_write，_IO_cookie_write又会调用 cookie_io_functions_t __io_</description></item><item><title>house of husk</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</guid><description>参考博客1 参考博客2 效果是执行一次call，一般都是打ogg 这个spec对应的字符对应的偏移就是其ASCII码 漏洞原理 ​printf​ 函数通</description></item><item><title>house of kiwi</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-kiwi/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-kiwi/</guid><description>[TOC] 参考文章 例题讲解 例题讲解 _IO_file_jumps中的_IO_file_sync 前言 加沙盒的题目,在2.29之后的堆题中,通常为以下两种</description></item><item><title>house of orange</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-orange/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-orange/</guid><description>[TOC] 参考博客 攻击分析 修改top chunk的size，然后add一个大于top chunk size的chunk让top chunk进入unsorted bin</description></item><item><title>house of orange新理解</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/house-of-orange%E6%96%B0%E7%90%86%E8%A7%A3/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/house-of-orange%E6%96%B0%E7%90%86%E8%A7%A3/</guid><description>house of orange攻击流程没什么好说的，但笔者之前一直认为就只是把top chunk放入unsorted bin，然后修改unsorted bin的</description></item><item><title>house of pig</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig/</guid><description>[TOC] 原理详解 题目详解 _IO_str_jumps中的_IO_str_overflow 核心 利用_IO_str_overflow的malloc,me</description></item><item><title>house of pig plus</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig-plus/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig-plus/</guid><description>[TOC] 参考博客 当题目中限制了system函数的调用，可以使用此方法进行orw，但是这个方法的前提还是有hook可打 特别之处 IO_str_over</description></item><item><title>hugo博客搭建</title><link>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E7%AC%94%E8%AE%B0/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>hugo博客搭建超详细教程 hugo主题选择 如果E:\Project\Blog\ZER0-blog\public\img\author.jpg</description></item><item><title>io basic knowledge</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/io-basic-knowledge/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/io-basic-knowledge/</guid><description>[TOC] _IO_list_all、 _IO_2_1_stderr、 stderr FSOP FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使</description></item><item><title>json格式</title><link>https://zp9080.github.io/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/json/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/json/</guid><description>JSON 常见格式 1.简单对象 { &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, &amp;#34;age&amp;#34;: 30, &amp;#34;is_student&amp;#34;: false } 这是一个包含三个键值对的简单对象。 2.嵌套对象 { &amp;#34;person&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, &amp;#34;age&amp;#34;: 30, &amp;#34;address&amp;#34;: { &amp;#34;street&amp;#34;: &amp;#34;123 Main St&amp;#34;, &amp;#34;city&amp;#34;: &amp;#34;Anytown&amp;#34;, &amp;#34;country&amp;#34;: &amp;#34;USA&amp;#34; } } } 在这个示例中</description></item><item><title>kali</title><link>https://zp9080.github.io/post/tools/kali/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/kali/</guid><description>账号:zzzp 密码：20040918 安装vmmare</description></item><item><title>kernel pwn基础知识</title><link>https://zp9080.github.io/post/kernel-pwn/kernel-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/kernel-pwn/kernel-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>[TOC] 通用保护机制 KASLR FGKASLR STACK PROTECTOR SMAP/SMEP KPTI 内核 “堆” 上保护机制 Hardened Usercopy Hardened freelist Random freelist CONFIG_INIT_ON_ALLOC_DEFAULT_ON 调试相关 在启动sh脚本后加上 -gdb tcp::1234 ，然后在pwndbg中target remote 127.0.0.1 1234</description></item><item><title>largebin attack</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/largebin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/largebin-attack/</guid><description>[TOC] 学习时参考的博客 博客1 博客2 往一个地址写入一个堆地址 largebin attack经常用来在堆上伪造FAKE FILE来打IO_FILE 代码 malloc(0x420) #0 malloc(0x20) malloc(0x410) #1 malloc(0x20) free(0) #</description></item><item><title>libc got</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc-got/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc-got/</guid><description>[TOC] 参考博客 其实没什么特别的，现在主流的打法就是puts函数会调用libc中got.plt的strlen函数，而strlen的got表可以被我</description></item><item><title>libc2.39堆攻击</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.39%E5%A0%86%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.39%E5%A0%86%E6%94%BB%E5%87%BB/</guid><description>打litctf2024的时候遇到了一个libc2.39的堆，还是用house of apple2这个链打，但是有一点不同，这里做一下记录 主要是发现</description></item><item><title>linux基础</title><link>https://zp9080.github.io/post/linux-basic-knowledge/linux%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/linux-basic-knowledge/linux%E5%9F%BA%E7%A1%80/</guid><description>linux基础 Linux基础 网络问题：换源 网站链接 man(man 指令) /tldr(与man基本类似，只不过显示的东西更加简洁) Linux 系统目录结构 | 菜鸟教程 (runoob.com)</description></item><item><title>llvm-pwn</title><link>https://zp9080.github.io/post/llvm-pwn/llvm-pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/llvm-pwn/</guid><description>[TOC] 主要参考了此篇 博客 核心思路 其实llvm pass最主要的是pwn opt这个文件，同时其一般都是no pie,Partial RELRO,因此通常可以通过覆写got表</description></item><item><title>llvm基础学习</title><link>https://zp9080.github.io/post/llvm-pwn/llvm%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/llvm%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid><description>参考博客1 参考博客2 基础知识 前端后端都不用管，关注llvm IR这个东西 llvm IR的头部是一些Target Information target layout clang 与 llvm 常见指令 .ll 格式：人类可以阅读</description></item><item><title>magic gadgets</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/magic-gadgets/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/magic-gadgets/</guid><description>libc2.36 此时的rax正好指向FAKE_IO头部 .text:0000000000160E56 mov rdx, [rax+38h] .text:0000000000160E5A mov rdi, rax .text:0000000000160E5D call qword ptr [rdx+20h] 也就是svcudp_reply+0x1a .text:00000000001630AA mov rbp, [rdi+48h] .text:00000000001630AE mov rax, [rbp+18h] .text:00000000001630B2 lea r13, [rbp+10h] .text:00000000001630B6 mov dword ptr [rbp+10h],</description></item><item><title>mips pwn基础知识</title><link>https://zp9080.github.io/post/mips-pwn/mips-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/mips-pwn/mips-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>经典例题讲解 wiki内容 运行mips文件以及调试 安装mipsrop插件 shellcode base mips没有NX功能，所以栈是可以执行的，所以基本上都是打shel</description></item><item><title>mips pwn例题</title><link>https://zp9080.github.io/post/mips-pwn/mips-pwn%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/mips-pwn/mips-pwn%E4%BE%8B%E9%A2%98/</guid><description>这里以XYCTF2024 EZ1.0? 为例题 题目分析 int vuln() { char v1[64]; // [sp+18h] [+18h] BYREF read(0, v1, 256); return 0; } 无法泄露栈地址，因此要找适当的gadget来把sp的值给某个寄存器，然</description></item><item><title>mp_</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/mp_/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/mp_/</guid><description>[TOC] 不能使用tcache -&amp;gt; 通过large_bin attack修改mp_.tcache_bins -&amp;gt; free相应chunk -&amp;gt; 修改tcache的相应</description></item><item><title>mprotect</title><link>https://zp9080.github.io/post/stackoverflow/mprotect/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/mprotect/</guid><description>mprotect可以修改一个区域的权限 void mprotect(void *address, size_t length, int prot); address: 这是要操作的内存区域的起始地址。通常是一个 void 指针，可以指向任何类型的数据。 length: 这是要操作</description></item><item><title>off-by-one</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</guid><description>参考博客 off-by-one确实比off-by-null好打多了 注意off-by-one构造overlapping chunk的时候要使得通过</description></item><item><title>one_gadget</title><link>https://zp9080.github.io/post/stackoverflow/one_gadget/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/one_gadget/</guid><description>ogg</description></item><item><title>orw-plus</title><link>https://zp9080.github.io/post/shellcode/orw-plus/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/orw-plus/</guid><description>详细内容可以参考这篇文章 贴一个总结的还不错的文章 [TOC] 两种基本orw的shellcode 第一种 ; open(&amp;#34;flag&amp;#34;, 0) push 0x67616c66 push 0x2 pop rax mov rdi,rsp xor rsi,rsi syscall ; read(fd, rsp, 0x50) mov rdi,rax xor rax,rax mov rsi,rsp push</description></item><item><title>partial overwrite</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</guid><description>[TOC] 程序没有show函数，当堆块被free后，如果还可以edit，那么就可以通过partial overwrite来进行泄露进而爆破申请出想要申</description></item><item><title>personal skills</title><link>https://zp9080.github.io/post/%E5%A0%86/personal-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/personal-skills/</guid><description>注意二级指针，*的作用是解引用，把它想成访问地址又形象又好理解 学会画图很重要 注意malloc的大小和实际开辟的chunk的大小 传给free的</description></item><item><title>php pwn基本知识</title><link>https://zp9080.github.io/post/php-pwn/php-pwn%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/php-pwn/php-pwn%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid><description>[TOC] 基础知识 php pwn开启远程得到的实际上是远程用apache搭建的一个web页面，和web息息相关 我们上传文件后可以直接访问url/exp.p</description></item><item><title>php pwn例题</title><link>https://zp9080.github.io/post/php-pwn/%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/php-pwn/%E4%BE%8B%E9%A2%98/</guid><description>2020De1CTF-mixture 参考博客 这个题的.so扩展函数的功能就是打开文件并且输出，memcpy没有限制n的大小有个很明显的栈溢出 主要思路是通过/proc/self</description></item><item><title>printf函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/printf%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/printf%E5%87%BD%E6%95%B0/</guid><description>奇怪的知识点，printf函数会有个判断al的值是否为0的操作来判断是否进行浮点数操作</description></item><item><title>protobuf</title><link>https://zp9080.github.io/post/go-pwn/protobuf/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/go-pwn/protobuf/</guid><description>在go pwn的堆题中，经常会有结构体，在go中这些结构体就是通过protobuf来传递的 如果抹除了protobuf的标志，那就只能手撕了，具</description></item><item><title>pwndbg</title><link>https://zp9080.github.io/post/tools/pwndbg/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/pwndbg/</guid><description>[TOC] 基本指令 help //帮助 i //info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用 i b //常用，info break 查看所有断点信</description></item><item><title>python常用</title><link>https://zp9080.github.io/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/python%E5%B8%B8%E7%94%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/python%E5%B8%B8%E7%94%A8/</guid><description>[TOC] fromhex，十六进制字符串转换为字节对象互相转化 &amp;gt;&amp;gt;&amp;gt; bytes([0,1,2,3,4,5]).hex() &amp;#39;000102030405&amp;#39; #fromhex这个中间有空格也不影响 &amp;gt;&amp;gt;&amp;gt; bytes.fromhex(&amp;#39;000102030405&amp;#39;) b&amp;#39;\x00\x01\x02\x03\x04\x05&amp;#39; &amp;gt;&amp;gt;&amp;gt; b&amp;#39;abcde&amp;#39;.hex() &amp;#39;6162636465&amp;#39; &amp;gt;&amp;gt;&amp;gt; a = bytes.fromhex(&amp;#39;6162636465&amp;#39;) b&amp;#39;abcde&amp;#39; 切片操作，这个很常用</description></item><item><title>qemu pwn基础知识</title><link>https://zp9080.github.io/post/qemu-pwn/qemu-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/qemu-pwn/qemu-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>[TOC] 常用指令 lspci ls /sys/devices/pci0000\:00/0000\:00\:04.0/ -monitor telnet:127.0.0.1:4444,server,nowait 后 nc 127.0.0.1 4444可以info pci看的更清楚,这个技巧仅限于qemu，发现内核不好使 qemu到底在pwn什么 主要是pwn q</description></item><item><title>realloc调整堆栈</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/realloc%E8%B0%83%E6%95%B4%E5%A0%86%E6%A0%88/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/realloc%E8%B0%83%E6%95%B4%E5%A0%86%E6%A0%88/</guid><description>注意realloc_hook就在malloc_hook-8的位置 # __malloc_hook -&amp;gt; realloc+8 # __realloc_hook -&amp;gt; one_gadget realloc = libc_base + libc.sym[&amp;#39;realloc&amp;#39;] one_gadget = [0x4527a, 0xf03a4, 0xf1247] add(4, 0x68, b&amp;#39;p&amp;#39; * 11 + p64(libc_base + one_gadget[0]) + p64(realloc + 8))</description></item><item><title>ret2dlresolve</title><link>https://zp9080.github.io/post/stackoverflow/ret2dlresolve/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/ret2dlresolve/</guid><description>[TOC] 参考博客 适用于NO RELRO, Partial RELRO，在64位中一般都是打linkmap结构体，板子题 攻击模板 总结地说，我们需要 st_other != 0 l -&amp;gt; l_addr = system_libc - a_libc</description></item><item><title>sandbox</title><link>https://zp9080.github.io/post/stackoverflow/sandbox/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/sandbox/</guid><description>[TOC] sandbox sandbox检测工具 seccomp-tools dump ./file 有时候直接用这个指令没有检测到沙盒，一般是因为程序还没有执行到沙盒，随便输入执行到沙盒就行 prctl函数 可以</description></item><item><title>setuid</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/setuid/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/setuid/</guid><description>最近做了一个题执行了system(&amp;quot;/bin/sh&amp;quot;)后发现flag只有root才有read权限，这里要提权 可以参考此篇</description></item><item><title>shellcode tricks</title><link>https://zp9080.github.io/post/shellcode/shellcode-tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/shellcode-tricks/</guid><description>常用系统调用号 syscall 64位 0-&amp;gt;read 1-&amp;gt;write 2-&amp;gt;open 5-&amp;gt;fstat 9-&amp;gt;mmap 0xa-&amp;gt;mprotect 0xf-&amp;gt;rt_sigreturn 0x3b-&amp;gt;execve 0x5a-&amp;gt;chmod int 0x80 32位 3-&amp;gt;read 4-&amp;gt;write 5-&amp;gt;open 0xb-&amp;gt;execve 有时候受字长限制可以考虑eax,ax,al这种寄存器,让shellcode变短 cd</description></item><item><title>shellcode网站</title><link>https://zp9080.github.io/post/shellcode/shellcode%E7%BD%91%E7%AB%99/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/shellcode%E7%BD%91%E7%AB%99/</guid><description>详细阐述了各种shellcode 可以查看各个指令对应的机械码 系统调用号 汇编网站 shellcode库</description></item><item><title>skills</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/skills/</guid><description>有read函数最好用send，scanf和gets必须用sendline init函数也要查看，有时候一些变量的初始化就在其中 strlen的绕</description></item><item><title>socket</title><link>https://zp9080.github.io/post/web-pwn/socket/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/web-pwn/socket/</guid><description>[TOC] 这篇文章生动详细地讲清楚了socket到底是什么 相关知识 一些关键理解 注意这里和反弹shell不太一样，反弹shell创建了套间字后直接co</description></item><item><title>srop</title><link>https://zp9080.github.io/post/stackoverflow/srop/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/srop/</guid><description>[TOC] 一些重要理解 rsp必须必须指向fake_frame的底部，不然sigreturn无法正常执行 fake_frame中的rip的值就是sigr</description></item><item><title>stack_migration</title><link>https://zp9080.github.io/post/stackoverflow/stack_migration/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/stack_migration/</guid><description>[TOC] 栈迁移 栈迁移的核心是leave_ret指令，要清楚leave_ret指令的作用 栈迁移：rbp覆盖为我们想要转移到的地址-8（注意有个pop</description></item><item><title>stderr</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stderr/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stderr/</guid><description>在打IO攻击的时候经常需要用到malloc_assert，要打stderr,这里区分一下几个概念 1.直接打_IO_2_1_stderr_ 如果</description></item><item><title>stdout</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stdout/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stdout/</guid><description>[TOC] 遇到puts或printf，就会将_IO_write_base指向的内容打印出来。实际操作中发现如果是write函数还不行 stdout原理</description></item><item><title>system_execve函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/system_execve%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/system_execve%E5%87%BD%E6%95%B0/</guid><description>[TOC] system函数 system(&amp;quot;$0&amp;quot;) system(&amp;ldquo;sh&amp;rdquo;) system(&amp;quot;/bin/sh&amp;quot;) system(&amp;quot;/bin//sh&amp;quot;)都可以拿到shell cat *：是一个在命令行中使用的Unix/L</description></item><item><title>tcache stashing unlink attack</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache-stashing-unlink-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache-stashing-unlink-attack/</guid><description>[TOC] 学习时参考的博客 一篇讲原理的博客 例题博客 例题博客 例题博客 1.获得任意地址target_addr的控制权 2.在任意地址target_addr</description></item><item><title>tcache_perthread_struct</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache_perthread_struct/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache_perthread_struct/</guid><description>[TOC] tcache_perthread_struct可以free掉，在libc2.30以下的版本tcache_perthread_struct大</description></item><item><title>templates</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/templates/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/templates/</guid><description>[TOC] recv canary=int(sh.recvuntil(b&amp;quot;00&amp;quot;).decode(),16) buffer= int(p.recv(14), 16) 两个十六进制是一个字节，但是printf函数打印是一个字符一个字符的打印，一个字符是一个字节，所以0x7ffec1484618也</description></item><item><title>tilix</title><link>https://zp9080.github.io/post/tools/tilix/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/tilix/</guid><description>参考博客</description></item><item><title>tls</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tls/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tls/</guid><description>[TOC] 参考文章 对于tcache 修改线程tcache变量 在tls区域，有一个线程变量tcache，如果能用largebin attack修改tcac</description></item><item><title>tmux</title><link>https://zp9080.github.io/post/tools/tmux/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/tmux/</guid><description>[TOC] 参考博客 参考博客 基本概念 session：一个服务器可以包含多个会话，可以理解成是一个特定的终端组合，通常将同一任务下的工作放到一个会话中。</description></item><item><title>tools installation</title><link>https://zp9080.github.io/post/tools/tools-installation/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/tools-installation/</guid><description>u24 pwn环境安装 pwntools 直接pip install pwntools ROPgadget 参考此篇博客 安装报错解决 one_gadget sudo apt update sudo apt install ruby gem install one_gadget ida 吾爱破解 linux安装ida9 gdb pwndbg 参考此篇博客 sudo ./setup.sh burpsuite 直接下</description></item><item><title>tricks</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/tricks/</guid><description>[TOC] 做题步骤 第一步先checksec(checksec至关重要，因为如果partial rello那么很可能会打got，然后no pie这种很可能</description></item><item><title>uaf</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/uaf/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/uaf/</guid><description>[TOC] UAF不仅可以泄露，还能让两个指针指向同一个chunk 题目分析 巅峰极客2022 happy_note libc2.35 add大小要&amp;lt;=0x200，add时无read。然</description></item><item><title>unsafe unlink</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</guid><description>[TOC] 核心 这个技巧适用于no pie的情况下使用 chunk 0 ptr store in &amp;amp;ptr malloc(0x420) # not in fastbin or tcache malloc(0x420) edit(0, p64(0)+p64(fake_size)+p64(&amp;amp;ptr-0x18)+p64(&amp;amp;ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x430-0x10 限制: overflow ,可以修改prev_inuse触发fake chunk unlink</description></item><item><title>unsorted bin attack</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/unsorted-bin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/unsorted-bin-attack/</guid><description>[TOC] 1.unsorted bin attack 被利用的前提是控制 unsorted bin chunk 的 bk 指针或者有show函数。 2.unsorted bin attack的目的一般是为别的attack做准备，比如可以通过main_ar</description></item><item><title>vm pwn例题</title><link>https://zp9080.github.io/post/vm-pwn/vm-pwn%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/vm-pwn/vm-pwn%E4%BE%8B%E9%A2%98/</guid><description>OGEEK2019_FINAL_OVM 数组溢出 from pwn import * context.log_level=&amp;#39;debug&amp;#39; p = process(&amp;#34;vmpwn&amp;#34;) elf = ELF(&amp;#34;vmpwn&amp;#34;) libc = elf.libc s = lambda data :p.send(data) sa = lambda text,data :p.sendafter(text, str(data)) sl = lambda data :p.sendline(data) sla = lambda text,data :p.sendlineafter(text, str(data)) r = lambda num=4096 :p.recv(num) ru = lambda text :p.recvuntil(text) uu32 = lambda :u32(p.recvuntil(&amp;#34;\xf7&amp;#34;)[-4:].ljust(4,&amp;#34;\x00&amp;#34;)) uu64 = lambda :u64(p.recvuntil(&amp;#34;\x7f&amp;#34;)[-6:].ljust(8,&amp;#34;\x00&amp;#34;)) lg = lambda name,data :p.success(name + &amp;#34;-&amp;gt; 0x%x&amp;#34; % data) def</description></item><item><title>vm pwn知识学习</title><link>https://zp9080.github.io/post/vm-pwn/vm-pwn%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/vm-pwn/vm-pwn%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid><description>参考博客1 参考博客2 有时候可以逆向出结构体 vmpwn难度在于逆向，逆向结束后一般都是会有整数溢出进行任意地址读写或者是个堆题，七分逆向三分猜</description></item><item><title>vtable</title><link>https://zp9080.github.io/post/c++-pwn/vtable/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/vtable/</guid><description>例题 SICTF ROUND3 ezcpp 题目分析 题目上来泄露出了pie，也有后门函数，然后是两个功能get和print，核心思路是劫持vtable 细节阐述 对ida反汇编的</description></item><item><title>Web Pwn常见做法</title><link>https://zp9080.github.io/post/web-pwn/web-pwn%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/web-pwn/web-pwn%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95/</guid><description>[TOC] 参考博客 VNCTF2022一道题 一般httpd程序的执行流程为 在main函数中用pthread或fork来进入HTTP请求处理函数 在HTT</description></item><item><title>win pwn调试相关</title><link>https://zp9080.github.io/post/win-pwn/win-pwn%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/win-pwn/win-pwn%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3/</guid><description>在Windbg中，要查看当前指令所在的函数，您可以使用 ln（List Nearest Symbols）命令。该命令将告诉您当前执行指令所在的函数，以及在该函</description></item><item><title>win pwn例题</title><link>https://zp9080.github.io/post/win-pwn/win-pwn%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/win-pwn/win-pwn%E4%BE%8B%E9%A2%98/</guid><description>最近打NKCTF遇到了一个winpwn，在此也是借着这个机会学习了一下 漏洞也很明显，如果是linux直接ret2libc很快就打完了，这里引</description></item><item><title>zellij</title><link>https://zp9080.github.io/post/tools/zellij/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/tools/zellij/</guid><description>参考此篇博客</description></item><item><title>保护机制变动</title><link>https://zp9080.github.io/post/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</guid><description>一篇讲这个的博客 house系列 tcachebin 堆指针异或加密（glibc-2.32 引入） fastbin 堆指针异或加密（glibc-2.32 引入） 堆内存对齐检查（gli</description></item><item><title>打法总述</title><link>https://zp9080.github.io/post/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</guid><description>[TOC] 打法总述 笔者对于这些攻击手法感觉不是很难，难的地方在于堆风水 有无off-by-null 一般没有uaf都是会有off-by-null可以利用</description></item><item><title>低版本off-by-null</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</guid><description>off-by-null 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出</description></item><item><title>堆summary</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E5%A0%86summary/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E5%A0%86summary/</guid><description>[TOC] house系列 house系列的致命缺陷就是vtable是通过偏移调用函数 这种找vtable要根据源码去libc.so.6里面进行对比查找，</description></item><item><title>堆tricks</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86tricks/</guid><description>[TOC] 1. 泄露libcbase，heapbase 2. 打free_hook或IO_FILE 保护机制 泄露heapbase 一般想要泄露heapbase的情</description></item><item><title>堆分配（自己复现）</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</guid><description>[TOC] 一篇讲的比较清楚的博客 malloc函数 说明：first chunk是指bin中链表头部的chunk,last chunk是指bin中链表尾部的</description></item><item><title>堆分配机制</title><link>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</guid><description>[TOC] 一篇讲的很好的博客 概念明晰 bins的链表用的是头插法 fd和bk只在bins才有 在堆中prev chunk就是比它地址低的，next chunk</description></item><item><title>反弹shell</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%BC%B9shell/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%BC%B9shell/</guid><description>[TOC] 参考博客 关闭了标准输入、标准输出、标准错误时可以利用反弹shell 反弹shell connect()+dupsh() - 反连 实测这种最好用,这里的ip要填写自己的wsl的ip</description></item><item><title>非常见类型的格式化字符串</title><link>https://zp9080.github.io/post/format-string/%E9%9D%9E%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/%E9%9D%9E%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>scanf的格式化字符串 做了这么久的格式化字符串，第一次见scanf的格式化字符串，于是做个记录 题目分析 可以看到把read读入的作为scan</description></item><item><title>非栈上格式化字符串</title><link>https://zp9080.github.io/post/format-string/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>（非栈上格式化字符串）往retaddr写一个orw，这种一般都要有无限次写才行,同时要找到栈上一个链才行 要注意链写的时候不要被覆盖，%{0}</description></item><item><title>浮点数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0/</guid><description>用float-toy可以很方便的构造浮点数</description></item><item><title>高版本off-by-null</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</guid><description>[TOC] 思路分析 贴一个 参考博客 多了几个步骤： 一个伪造fake chunk的过程 伪造了size还得满足__builtin_expect (fd-&amp;gt;bk != p || bk-&amp;gt;fd != p, 0</description></item><item><title>高版本打tcache</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</guid><description>[TOC] 前言 在此之前，笔者libc2.35都固化思维地只会largebin attack然后打IO，一遇到高版本还打tcache的好像束手无策 但是l</description></item><item><title>关于泄露</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</guid><description>打NKCTF2024有一个libc2.23的堆题，虽然笔者不太会libc2.23的堆还是想看一看这个题 堆溢出里面泄露不要只想着传统的通过ch</description></item><item><title>函数参数传递</title><link>https://zp9080.github.io/post/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>64位函数参数传递 主要区别在于第4个参数，一般函数调用第4个参数是rcx存储，系统调用是r10存储</description></item><item><title>红帽杯-2021 simpleVM</title><link>https://zp9080.github.io/post/llvm-pwn/%E7%BA%A2%E5%B8%BD%E6%9D%AF-2021-simplevm/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/%E7%BA%A2%E5%B8%BD%E6%9D%AF-2021-simplevm/</guid><description>[TOC] 入门llvm pass的第一题， 这里给出一个写的比较详细的博客 题目分析 先ctrl+g定位到.load段找到pass函数 发现如果函数名为o0o</description></item><item><title>基于jmp_buf结构体的攻击</title><link>https://zp9080.github.io/post/web-pwn/%E5%9F%BA%E4%BA%8Ejmp_buf%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/web-pwn/%E5%9F%BA%E4%BA%8Ejmp_buf%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>前置知识 jmp_buf结构体 setjmp.h 头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则 jmp_buf 是一</description></item><item><title>利用函数返回值设置rax</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</guid><description>利用函数返回值设置rax参数其实是一种挺常见的技巧，read函数可以设置rax，strtol也可以设置rax 这里写的题目是vnctf2023</description></item><item><title>盲注</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E7%9B%B2%E6%B3%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E7%9B%B2%E6%B3%A8/</guid><description>对于盲注，最关键的地方就是根据已有经验去猜 例题 SICTF ROUND3 ezsignin 题目描述，ubuntu:22.04 libc2.35 这个题通过尝试应该是个无限read+printf 解题</description></item><item><title>目录穿越</title><link>https://zp9080.github.io/post/web-pwn/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/web-pwn/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/</guid><description>[TOC] 此题是NKCTF2024 httpd这道题 题目分析 %[^ ] 是C语言中 scanf 和 sscanf 函数用于格式化输入的格式化字符串中的一个格式说明符。具体地，%[^ ] 表</description></item><item><title>强网杯-2022 yakagame</title><link>https://zp9080.github.io/post/llvm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AF-2022-yakagame/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/llvm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AF-2022-yakagame/</guid><description>题目分析 做过前两个llvm的题，逆向基本已经没有什么问题了，题目逻辑都看得懂，题目中有个很明显的后门函数 if ( (__int64)*score &amp;gt; 0x12345678 ) backdoor(); 但是有个很困惑的地方是</description></item><item><title>权限提升-Change Others</title><link>https://zp9080.github.io/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-others/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-others/</guid><description>如果我们可以改变特权进程的执行轨迹，也可以实现提权。这里我们从以下角度来考虑如何改变特权进程的执行轨迹。 改数据 改代码 符号链接 如果一个 root 权限的</description></item><item><title>权限提升-Change Self</title><link>https://zp9080.github.io/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-self/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-self/</guid><description>内核会通过进程的 task_struct 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程</description></item><item><title>受限制的shellcode</title><link>https://zp9080.github.io/post/shellcode/%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84shellcode/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/shellcode/%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84shellcode/</guid><description>[TOC] 这篇博客不错 shellcode字长受限 一种解决方法是先写入read函数然后再read任意长度的shellcode 无法使用syscall 发现</description></item><item><title>游戏逆向pwn</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</guid><description>一个逆向游戏题,这里有个很明显的任意写漏洞 if ( op == &amp;#39;l&amp;#39; ) player_tile = getchar(); *(_BYTE *)(row[1] + buf + 90 * *row) = player_tile; 但这里有个很恶心的地方*(_BYTE *)(row[1] + buf + 90 * *row) = 0x2E; 这个地</description></item><item><title>有关system函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</guid><description>[TOC] 最近写了vnctf2023的traveler一题，一眼看出是栈迁移，题目也给了system函数，但是卡了很久 但是要注意一个很坑的地方，就是</description></item><item><title>远程交互</title><link>https://zp9080.github.io/post/linux-basic-knowledge/%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/linux-basic-knowledge/%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/</guid><description>[TOC] 登录远程服务器 ssh -p 50022 my@127.0.0.1 -p 后面是端口 my 是服务器用户名 127.0.0.1 是服务器 ip 与远程交互文件 可以参考这篇文章 Linux scp 命令用于 Linux 之间复制文件和目录。 scp 是 secure copy 的缩</description></item><item><title>杂乱的知识点</title><link>https://zp9080.github.io/post/linux-basic-knowledge/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/linux-basic-knowledge/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>[TOC] gdb关闭本地alsr 参考此篇博客 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 上面那个直接关闭本地整个的alsr set disable-randomization on show disable-randomization sudo -s echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space exit 文件路径 “/”在系统文件中表示绝对</description></item><item><title>栈对齐</title><link>https://zp9080.github.io/post/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</guid><description>高版本的Ubuntu执行system或者printf需要高16位栈对齐 一般的做法就是垫一个ret或者不要system完整函数里面的pop rbp 后</description></item><item><title>栈上格式化字符串</title><link>https://zp9080.github.io/post/format-string/%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/format-string/%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>往栈上某个地址一次写入6个字节 #target是目标地址，n0是想要写入的东西,k为ljust之后p64(target)为格式化字符串的第几个</description></item><item><title>栈溢出</title><link>https://zp9080.github.io/post/c++-pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/</guid><description>例题 SICTF ROUND3 overflow 漏洞在这里，cin是不限制读入长度的，但是要注意不要用space,\n，那么operator=就相当于任意写，而buf又在栈上，把</description></item><item><title>知识学习</title><link>https://zp9080.github.io/post/c++-pwn/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/c++-pwn/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</guid><description>C++知识点 * __int64 v1; // rax v1 = std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, &amp;#34;What do you want to say?&amp;#34;); std命名空间，operator&amp;laquo;是重载运算符函数，&amp;laquo;&amp;lt;std::ch</description></item><item><title>最常用的house攻击</title><link>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84house%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84house%E6%94%BB%E5%87%BB/</guid><description>[TOC] 经验总结 _IO_list_all,IO_2_1_stderr,stderr看情况写哪个 FROP打house of apple2,malloc_a</description></item><item><title>做题遇到的函数</title><link>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://zp9080.github.io/post/pwn%E7%AC%94%E8%AE%B0/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</guid><description>[TOC] strtoull函数 munmap函数 setvbuf函数 fgets函数 char *fgets(char *str, int n, FILE *stream); fgets() 从 stream 中读取字符，直到读取了 n-1 个字符、读取并转移到字符串</description></item></channel></rss>