<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.126.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="afl-fuzz源码分析下篇"><meta itemprop=description content="集中一点,登峰造极"><meta name=description content="集中一点,登峰造极"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://zp9080.github.io/imgs/author.png"><meta itemprop=keywords content="Fuzz"><meta property="og:type" content="article"><meta property="og:title" content="afl-fuzz源码分析下篇"><meta property="og:description" content="集中一点,登峰造极"><meta property="og:image" content="/imgs/author.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/"><meta property="og:site_name" content="f1ow-blog"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="f1ow"><meta property="article:published_time" content="2024-09-02 12:03:30 +0800 CST"><meta property="article:modified_time" content="2024-09-02 12:03:30 +0800 CST"><link type=text/css rel=stylesheet href=https://zp9080.github.io/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=https://zp9080.github.io/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://zp9080.github.io/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.bfbac3431de920c11b5b1cafa45029ea1bc93d5d3da50fed4ab6924b4c250360.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87","permalink":"https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/","title":"afl-fuzz源码分析下篇","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>afl-fuzz源码分析下篇 - f1ow-blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><div class=overlay></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>f1ow-blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>集中一点,登峰造极</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>207</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-categories hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#fuzz大循环>fuzz大循环</a></li><li><a href=#cull_queue>cull_queue</a><ul><li><a href=#mark_as_redundant>mark_as_redundant</a></li></ul></li><li><a href=#sync_fuzzers>sync_fuzzers</a></li><li><a href=#save_if_interesting>save_if_interesting</a></li><li><a href=#fuzz_one-相关函数>fuzz_one 相关函数</a><ul><li><a href=#common_fuzz_stuff>common_fuzz_stuff</a></li><li><a href=#calculate_score>calculate_score</a></li><li><a href=#trim_case>trim_case</a></li></ul></li><li><a href=#fuzz_one准备工作>fuzz_one准备工作</a></li><li><a href=#fuzz_one变异阶段>fuzz_one变异阶段</a><ul><li><a href=#simple-bitflip>simple bitflip</a><ul><li><a href=#bitflip-11>bitflip 1/1</a></li><li><a href=#bitflip-21>bitflip 2/1</a></li><li><a href=#bitflip-41>bitflip 4/1</a></li><li><a href=#bitflip-88>bitflip 8/8</a></li><li><a href=#bitflip-168>bitflip 16/8</a></li><li><a href=#bitflip-328>bitflip 32/8</a></li></ul></li><li><a href=#arithmetic-incdec>arithmetic inc/dec</a><ul><li><a href=#arith-88>arith 8/8</a></li><li><a href=#arith-168>arith 16/8</a></li><li><a href=#arith-328>arith 32/8</a></li></ul></li><li><a href=#interesting-values>interesting values</a><ul><li><a href=#interest-88>interest 8/8</a></li><li><a href=#interest-168>interest 16/8</a></li><li><a href=#interest-328>interest 32/8</a></li></ul></li><li><a href=#dictionary-stuff>dictionary stuff</a><ul><li><a href=#user-extras-over>user extras (over)</a></li><li><a href=#user-extras-insert>user extras (insert)</a></li><li><a href=#auto-extras-over>auto extras (over)</a></li></ul></li><li><a href=#random-havoc>random havoc</a></li><li><a href=#splicing>splicing</a><ul><li><a href=#locate_diffs>locate_diffs</a></li></ul></li></ul></li><li><a href=#心得体会>心得体会</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=f1ow src=/imgs/img-lazy-loading.gif data-src=/imgs/author.png><p class=site-author-name itemprop=name>f1ow</p><div class=site-description itemprop=description>集中一点,登峰造极</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>207</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>38</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>80</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zp9080 title="Github → https://github.com/zp9080" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://v3rdant.cn/ title=https://v3rdant.cn/ target=_blank>v3rdant</a></li><li class=links-of-blogroll-item><a href=https://juicymio.github.io/ title=https://juicymio.github.io/ target=_blank>juicymio</a></li><li class=links-of-blogroll-item><a href=https://ka7arotto.github.io/ title=https://ka7arotto.github.io/ target=_blank>Goku</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2024-07-28T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=273686></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=660></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2025-02-27T17:57:37+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/zp9080 rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/author.png"><meta itemprop=name content="f1ow"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="f1ow"><meta itemprop=description content="集中一点,登峰造极"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="afl-fuzz源码分析下篇"><meta itemprop=description content="[TOC]
前言


本篇作为fuzz的最后一篇，核心是fuzz大循环中的内容
fuzz_one函数很长，笔者将其分为了几个大的过程分析
个人认为的重点

cull_queue 精简队列，和top_rated有关，重要
sync_fuzzers 同步fuzzer，这部分现在还没那么重要，但是fuzz实操时为了效率这部分可能会比较重要，初学看看就行
save_if_interesting 这个函数和之前很多内容相关，重要
fuzz_one及其相关函数 核心函数，重要之重要
fuzz大循环

"></span><header class=post-header><h1 class=post-title itemprop="name headline">afl-fuzz源码分析下篇
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/Fuzz/afl-fuzz%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%b8%8b%e7%af%87.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-09-02 12:03:30 +0800 CST" itemprop="dateCreated datePublished" datetime="2024-09-02 12:03:30 +0800 CST">2024-09-02
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/fuzz itemprop=url rel=index><span itemprop=name>AEG/Fuzz</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>12833</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>26分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>[TOC]</p><h1 id=前言>前言
<a class=header-anchor href=#%e5%89%8d%e8%a8%80></a></h1><ul><li>本篇作为fuzz的最后一篇，核心是fuzz大循环中的内容</li><li>fuzz_one函数很长，笔者将其分为了几个大的过程分析</li><li><strong>个人认为的重点</strong></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-text data-lang=text><span style=display:flex><span>cull_queue 精简队列，和top_rated有关，重要
</span></span><span style=display:flex><span>sync_fuzzers 同步fuzzer，这部分现在还没那么重要，但是fuzz实操时为了效率这部分可能会比较重要，初学看看就行
</span></span><span style=display:flex><span>save_if_interesting 这个函数和之前很多内容相关，重要
</span></span><span style=display:flex><span>fuzz_one及其相关函数 核心函数，重要之重要
</span></span></code></pre></div><h1 id=fuzz大循环>fuzz大循环
<a class=header-anchor href=#fuzz%e5%a4%a7%e5%be%aa%e7%8e%af></a></h1><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span> <span style=color:#a2f;font-weight:700>while</span> (<span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u8 skipped_fuzz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//精简队列
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>cull_queue</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>queue_cur) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      queue_cycle<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      current_entry     <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>      cur_skipped_paths <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>      queue_cur         <span style=color:#666>=</span> queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//如果是resume则根据seek_to来找到对应的位置
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>while</span> (seek_to) {
</span></span><span style=display:flex><span>        current_entry<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>        seek_to<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>        queue_cur <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//ui
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#00a000>show_stats</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (not_on_tty) {
</span></span><span style=display:flex><span>        <span style=color:#00a000>ACTF</span>(<span style=color:#b44>&#34;Entering queue cycle %llu.&#34;</span>, queue_cycle);
</span></span><span style=display:flex><span>        <span style=color:#00a000>fflush</span>(stdout);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* If we had a full queue cycle with no new finds, try
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         recombination strategies next. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (queued_paths <span style=color:#666>==</span> prev_queued) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// 如果整轮没有新发现，则考虑打开 use_splicing 
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (use_splicing) cycles_wo_finds<span style=color:#666>++</span>; <span style=color:#a2f;font-weight:700>else</span> use_splicing <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> cycles_wo_finds <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      prev_queued <span style=color:#666>=</span> queued_paths;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 设置环境变量 AFL_IMPORT_FIRST，可以让 AFL 在工作之前先与其他 fuzzer 同步一次
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (sync_id <span style=color:#666>&amp;&amp;</span> queue_cycle <span style=color:#666>==</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>getenv</span>(<span style=color:#b44>&#34;AFL_IMPORT_FIRST&#34;</span>))
</span></span><span style=display:flex><span>        <span style=color:#00a000>sync_fuzzers</span>(use_argv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    skipped_fuzz <span style=color:#666>=</span> <span style=color:#00a000>fuzz_one</span>(use_argv);
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 若这个用例没有被跳过，且处于并行模式
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>stop_soon <span style=color:#666>&amp;&amp;</span> sync_id <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>skipped_fuzz) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 每发生 5 次这样的事件，就执行 sync_fuzzers()
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(sync_interval_cnt<span style=color:#666>++</span> <span style=color:#666>%</span> SYNC_INTERVAL))
</span></span><span style=display:flex><span>        <span style=color:#00a000>sync_fuzzers</span>(use_argv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>stop_soon <span style=color:#666>&amp;&amp;</span> exit_1) stop_soon <span style=color:#666>=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (stop_soon) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 轮到下一个testcase
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    queue_cur <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>    current_entry<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//以下就是fuzz结束的一些处理，分析略
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (queue_cur) <span style=color:#00a000>show_stats</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* If we stopped programmatically, we kill the forkserver and the current runner. 
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     If we stopped manually, this is done by the signal handler. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (stop_soon <span style=color:#666>==</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (child_pid <span style=color:#666>&gt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>kill</span>(child_pid, SIGKILL);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (forksrv_pid <span style=color:#666>&gt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>kill</span>(forksrv_pid, SIGKILL);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Now that we&#39;ve killed the forkserver, we wait for it to be able to get rusage stats. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>waitpid</span>(forksrv_pid, <span style=color:#a2f>NULL</span>, <span style=color:#666>0</span>) <span style=color:#666>&lt;=</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#00a000>WARNF</span>(<span style=color:#b44>&#34;error waitpid</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>write_bitmap</span>();
</span></span><span style=display:flex><span>  <span style=color:#00a000>write_stats_file</span>(<span style=color:#666>0</span>, <span style=color:#666>0</span>, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#00a000>save_auto</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a0a000>stop_fuzzing</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>SAYF</span>(CURSOR_SHOW cLRD <span style=color:#b44>&#34;</span><span style=color:#b62;font-weight:700>\n\n</span><span style=color:#b44>+++ Testing aborted %s +++</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span> cRST,
</span></span><span style=display:flex><span>       stop_soon <span style=color:#666>==</span> <span style=color:#666>2</span> <span style=color:#666>?</span> <span style=color:#b44>&#34;programmatically&#34;</span> <span style=color:#666>:</span> <span style=color:#b44>&#34;by user&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Running for more than 30 minutes but still doing first cycle? */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (queue_cycle <span style=color:#666>==</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>get_cur_time</span>() <span style=color:#666>-</span> start_time <span style=color:#666>&gt;</span> <span style=color:#666>30</span> <span style=color:#666>*</span> <span style=color:#666>60</span> <span style=color:#666>*</span> <span style=color:#666>1000</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>SAYF</span>(<span style=color:#b44>&#34;</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span> cYEL <span style=color:#b44>&#34;[!] &#34;</span> cRST
</span></span><span style=display:flex><span>           <span style=color:#b44>&#34;Stopped during the first cycle, results may be incomplete.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>           <span style=color:#b44>&#34;    (For info on resuming, see %s/README.)</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, doc_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>fclose</span>(plot_file);
</span></span><span style=display:flex><span>  <span style=color:#00a000>destroy_queue</span>();
</span></span><span style=display:flex><span>  <span style=color:#00a000>destroy_extras</span>();
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_free</span>(target_path);
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_free</span>(sync_id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>alloc_report</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>OKF</span>(<span style=color:#b44>&#34;We&#39;re done here. Have a nice day!</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>exit</span>(<span style=color:#666>0</span>);
</span></span></code></pre></div><h1 id=cull_queue>cull_queue
<a class=header-anchor href=#cull_queue></a></h1><ul><li>temp_v用来表示哪些位置没有被覆盖，遍历top_reted数组，对于top_rated数组中的每一个q，利用其trace_mini来更新temp_v。temp_v中的每一位为0表示被覆盖，为1表示没有被覆盖</li><li>注意区分!和~。!是逻辑非（NOT）运算符，~是按位取反（Bitwise NOT）运算符，对于temp_v[j] &= ~top_rated[i]->trace_mini[j];这一步，正好就实现了上述功能。同时temp_v和trace_mini是路径压缩后的结果，只表示是否被覆盖，不管次数</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* The second part of the mechanism discussed above is a routine that
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   goes over top_rated[] entries, and then sequentially grabs winners for
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   previously-unseen bytes (temp_v) and marks them as favored, at least
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   until the next run. The favored entries are given more air time during
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   all fuzzing steps. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>cull_queue</span>(<span style=color:#0b0;font-weight:700>void</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>struct</span> queue_entry<span style=color:#666>*</span> q;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// temp_v 是一个 bitmap，表示哪些位置还未被覆盖
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>static</span> u8 temp_v[MAP_SIZE <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>];
</span></span><span style=display:flex><span>  u32 i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//只有update_bitmap_score得分更新了，才会进行下面的步骤
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (dumb_mode <span style=color:#666>||</span> <span style=color:#666>!</span>score_changed) <span style=color:#a2f;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  score_changed <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>memset</span>(temp_v, <span style=color:#666>255</span>, MAP_SIZE <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  queued_favored  <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  pending_favored <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  q <span style=color:#666>=</span> queue;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//把queue中所有的favored设置为0
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>while</span> (q) {
</span></span><span style=display:flex><span>    q<span style=color:#666>-&gt;</span>favored <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    q <span style=color:#666>=</span> q<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Let&#39;s see if anything in the bitmap isn&#39;t captured in temp_v.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     If yes, and if it has a top_rated[] contender, let&#39;s use it. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> MAP_SIZE; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (top_rated[i] <span style=color:#666>&amp;&amp;</span> (temp_v[i <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>] <span style=color:#666>&amp;</span> (<span style=color:#666>1</span> <span style=color:#666>&lt;&lt;</span> (i <span style=color:#666>&amp;</span> <span style=color:#666>7</span>)))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u32 j <span style=color:#666>=</span> MAP_SIZE <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Remove all bits belonging to the current entry from temp_v. */</span>
</span></span><span style=display:flex><span>     <span style=color:#080;font-style:italic>// 用偏爱用例更新 temp_v
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>while</span> (j<span style=color:#666>--</span>) 
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (top_rated[i]<span style=color:#666>-&gt;</span>trace_mini[j])
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>          temp_v[j] <span style=color:#666>&amp;=</span> <span style=color:#666>~</span>top_rated[i]<span style=color:#666>-&gt;</span>trace_mini[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      top_rated[i]<span style=color:#666>-&gt;</span>favored <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>      queued_favored<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 若这个偏爱用例还从来没被 fuzz 过，则增加 pending_favored 计数器
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>top_rated[i]<span style=color:#666>-&gt;</span>was_fuzzed) pending_favored<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  q <span style=color:#666>=</span> queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>while</span> (q) {
</span></span><span style=display:flex><span>    <span style=color:#00a000>mark_as_redundant</span>(q, <span style=color:#666>!</span>q<span style=color:#666>-&gt;</span>favored);
</span></span><span style=display:flex><span>    q <span style=color:#666>=</span> q<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=mark_as_redundant>mark_as_redundant
<a class=header-anchor href=#mark_as_redundant></a></h2><ul><li>根据传入的state数值，如果不被favored就加入到out_dir/queue/.state/redundant_edges/中，否则就unlink这个文件(删除指定路径名的文件)</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Mark / unmark as redundant (edge-only). This is not used for restoring state,
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   but may be useful for post-processing datasets. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>mark_as_redundant</span>(<span style=color:#a2f;font-weight:700>struct</span> queue_entry<span style=color:#666>*</span> q, u8 state) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8<span style=color:#666>*</span> fn;
</span></span><span style=display:flex><span>  s32 fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (state <span style=color:#666>==</span> q<span style=color:#666>-&gt;</span>fs_redundant) <span style=color:#a2f;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  q<span style=color:#666>-&gt;</span>fs_redundant <span style=color:#666>=</span> state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fn <span style=color:#666>=</span> <span style=color:#00a000>strrchr</span>(q<span style=color:#666>-&gt;</span>fname, <span style=color:#b44>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>  fn <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/queue/.state/redundant_edges/%s&#34;</span>, out_dir, fn <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (state) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(fn, O_WRONLY <span style=color:#666>|</span> O_CREAT <span style=color:#666>|</span> O_EXCL, <span style=color:#666>0600</span>);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to create &#39;%s&#39;&#34;</span>, fn);
</span></span><span style=display:flex><span>    <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>unlink</span>(fn)) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to remove &#39;%s&#39;&#34;</span>, fn);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_free</span>(fn);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=sync_fuzzers>sync_fuzzers
<a class=header-anchor href=#sync_fuzzers></a></h1><ul><li>用于在各个 fuzzer 之间同步状态</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;dirent.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> dirent {
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>ino_t</span>          d_ino;       <span style=color:#080;font-style:italic>// 文件的索引节点号 (inode number)
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#0b0;font-weight:700>off_t</span>          d_off;       <span style=color:#080;font-style:italic>// 目录文件中的偏移量（在某些系统中未使用）
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#0b0;font-weight:700>unsigned</span> <span style=color:#0b0;font-weight:700>short</span> d_reclen;    <span style=color:#080;font-style:italic>// 此目录项的长度
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#0b0;font-weight:700>unsigned</span> <span style=color:#0b0;font-weight:700>char</span>  d_type;      <span style=color:#080;font-style:italic>// 文件类型
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#0b0;font-weight:700>char</span>           d_name[<span style=color:#666>256</span>]; <span style=color:#080;font-style:italic>// 文件名（以 null 结尾的字符串）
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>};
</span></span><span style=display:flex><span><span style=color:#080>#define CASE_PREFIX &#34;id:&#34;
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#080;font-style:italic>/* Grab interesting test cases from other fuzzers. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>sync_fuzzers</span>(<span style=color:#0b0;font-weight:700>char</span><span style=color:#666>**</span> argv) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  DIR<span style=color:#666>*</span> sd;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//sync_dir_entry
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>struct</span> dirent<span style=color:#666>*</span> sd_ent;
</span></span><span style=display:flex><span>  u32 sync_cnt <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sd <span style=color:#666>=</span> <span style=color:#00a000>opendir</span>(sync_dir);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>sd) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to open &#39;%s&#39;&#34;</span>, sync_dir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_max <span style=color:#666>=</span> stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  cur_depth <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Look at the entries created for every other fuzzer in the sync directory. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>while</span> ((sd_ent <span style=color:#666>=</span> <span style=color:#00a000>readdir</span>(sd))) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 枚举 sync_dir 下的每一个目录或文件
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>static</span> u8 stage_tmp[<span style=color:#666>128</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DIR<span style=color:#666>*</span> qd;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>struct</span> dirent<span style=color:#666>*</span> qd_ent; 
</span></span><span style=display:flex><span>    u8 <span style=color:#666>*</span>qd_path, <span style=color:#666>*</span>qd_synced_path;
</span></span><span style=display:flex><span>    u32 min_accept <span style=color:#666>=</span> <span style=color:#666>0</span>, next_min_accept;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    s32 id_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Skip dot files and our own output directory. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (sd_ent<span style=color:#666>-&gt;</span>d_name[<span style=color:#666>0</span>] <span style=color:#666>==</span> <span style=color:#b44>&#39;.&#39;</span> <span style=color:#666>||</span> <span style=color:#666>!</span><span style=color:#00a000>strcmp</span>(sync_id, sd_ent<span style=color:#666>-&gt;</span>d_name)) <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Skip anything that doesn&#39;t have a queue/ subdirectory. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//跳过没有queue/子目录的任何内容
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    qd_path <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/%s/queue&#34;</span>, sync_dir, sd_ent<span style=color:#666>-&gt;</span>d_name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(qd <span style=color:#666>=</span> <span style=color:#00a000>opendir</span>(qd_path))) {
</span></span><span style=display:flex><span>      <span style=color:#00a000>ck_free</span>(qd_path);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Retrieve the ID of the last seen test case. */</span>
</span></span><span style=display:flex><span>    qd_synced_path <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/.synced/%s&#34;</span>, out_dir, sd_ent<span style=color:#666>-&gt;</span>d_name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    id_fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(qd_synced_path, O_RDWR <span style=color:#666>|</span> O_CREAT, <span style=color:#666>0600</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (id_fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to create &#39;%s&#39;&#34;</span>, qd_synced_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>read</span>(id_fd, <span style=color:#666>&amp;</span>min_accept, <span style=color:#a2f;font-weight:700>sizeof</span>(u32)) <span style=color:#666>&gt;</span> <span style=color:#666>0</span>) 
</span></span><span style=display:flex><span>      <span style=color:#00a000>lseek</span>(id_fd, <span style=color:#666>0</span>, SEEK_SET);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    next_min_accept <span style=color:#666>=</span> min_accept;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Show stats */</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>sprintf</span>(stage_tmp, <span style=color:#b44>&#34;sync %u&#34;</span>, <span style=color:#666>++</span>sync_cnt);
</span></span><span style=display:flex><span>    stage_name <span style=color:#666>=</span> stage_tmp;
</span></span><span style=display:flex><span>    stage_cur  <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    stage_max  <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* For every file queued by this fuzzer, parse ID and see if we have looked at
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       it before; exec a test case if not. */</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//遍历sync_dir/sd_ent-&gt;d_name/queue/
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>while</span> ((qd_ent <span style=color:#666>=</span> <span style=color:#00a000>readdir</span>(qd))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u8<span style=color:#666>*</span> path;
</span></span><span style=display:flex><span>      s32 fd;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>struct</span> stat st;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (qd_ent<span style=color:#666>-&gt;</span>d_name[<span style=color:#666>0</span>] <span style=color:#666>==</span> <span style=color:#b44>&#39;.&#39;</span> <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          <span style=color:#00a000>sscanf</span>(qd_ent<span style=color:#666>-&gt;</span>d_name, CASE_PREFIX <span style=color:#b44>&#34;%06u&#34;</span>, <span style=color:#666>&amp;</span>syncing_case) <span style=color:#666>!=</span> <span style=color:#666>1</span> <span style=color:#666>||</span> 
</span></span><span style=display:flex><span>          syncing_case <span style=color:#666>&lt;</span> min_accept) <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* OK, sounds like a new one. Let&#39;s give it a try. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (syncing_case <span style=color:#666>&gt;=</span> next_min_accept)
</span></span><span style=display:flex><span>        next_min_accept <span style=color:#666>=</span> syncing_case <span style=color:#666>+</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//sync_dir/sd_ent-&gt;d_name/queue/qd_ent-&gt;d_name
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      path <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/%s&#34;</span>, qd_path, qd_ent<span style=color:#666>-&gt;</span>d_name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Allow this to fail in case the other fuzzer is resuming or so... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(path, O_RDONLY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>         <span style=color:#00a000>ck_free</span>(path);
</span></span><span style=display:flex><span>         <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>fstat</span>(fd, <span style=color:#666>&amp;</span>st)) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;fstat() failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Ignore zero-sized or oversized files. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (st.st_size <span style=color:#666>&amp;&amp;</span> st.st_size <span style=color:#666>&lt;=</span> MAX_FILE) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        u8  fault;
</span></span><span style=display:flex><span>        u8<span style=color:#666>*</span> mem <span style=color:#666>=</span> <span style=color:#00a000>mmap</span>(<span style=color:#666>0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (mem <span style=color:#666>==</span> MAP_FAILED) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to mmap &#39;%s&#39;&#34;</span>, path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* See what happens. We rely on save_if_interesting() to catch major
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           errors and save the test case. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>write_to_testcase</span>(mem, st.st_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        fault <span style=color:#666>=</span> <span style=color:#00a000>run_target</span>(argv, exec_tmout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (stop_soon) <span style=color:#a2f;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//表示同步方是当前sync_dir文件夹下的哪个文件
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        syncing_party <span style=color:#666>=</span> sd_ent<span style=color:#666>-&gt;</span>d_name;
</span></span><span style=display:flex><span>        queued_imported <span style=color:#666>+=</span> <span style=color:#00a000>save_if_interesting</span>(argv, mem, st.st_size, fault);
</span></span><span style=display:flex><span>        syncing_party <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>munmap</span>(mem, st.st_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(stage_cur<span style=color:#666>++</span> <span style=color:#666>%</span> stats_update_freq)) <span style=color:#00a000>show_stats</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#00a000>ck_free</span>(path);
</span></span><span style=display:flex><span>      <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_write</span>(id_fd, <span style=color:#666>&amp;</span>next_min_accept, <span style=color:#a2f;font-weight:700>sizeof</span>(u32), qd_synced_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>close</span>(id_fd);
</span></span><span style=display:flex><span>    <span style=color:#00a000>closedir</span>(qd);
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_free</span>(qd_path);
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_free</span>(qd_synced_path);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>closedir</span>(sd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=save_if_interesting>save_if_interesting
<a class=header-anchor href=#save_if_interesting></a></h1><ul><li>看这个函数之前先复习一些内容</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-text data-lang=text><span style=display:flex><span>run_target 函数返回值是：
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FAULT_NONE(0)，表示 child 正常结束。
</span></span><span style=display:flex><span>FAULT_TMOUT(1)，表示超时。
</span></span><span style=display:flex><span>FAULT_CRASH(2)，表示程序崩溃。
</span></span><span style=display:flex><span>FAULT_ERROR(3)，表示 fuzzer 本身出现问题。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>virgin_bits，常规 fuzz 过程的探索情况
</span></span><span style=display:flex><span>virgin_tmout，超时用例的探索情况
</span></span><span style=display:flex><span>virgin_crash，crash 用例的探索情况
</span></span></code></pre></div><ul><li>根据run_target跑的结果判断这个用例是否有趣,判断是否产生新的覆盖位或者路径，没有直接返回0.否则加到queue中，计算刚才run_target后的trace_bits的hash32存到queue_top->exec_cksum中</li><li>再次校准该testcase</li><li>在考虑完要不要把一个元素加入 queue 后，再考虑要不要将其保存到文件系统</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Check if the result of an execve() during routine fuzzing is interesting,
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   save or queue the input test case for further analysis if so. Returns 1 if
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   entry is saved, 0 otherwise. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> u8 <span style=color:#00a000>save_if_interesting</span>(<span style=color:#0b0;font-weight:700>char</span><span style=color:#666>**</span> argv, <span style=color:#0b0;font-weight:700>void</span><span style=color:#666>*</span> mem, u32 len, u8 fault) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8  <span style=color:#666>*</span>fn <span style=color:#666>=</span> <span style=color:#b44>&#34;&#34;</span>;
</span></span><span style=display:flex><span>  u8  hnb;
</span></span><span style=display:flex><span>  s32 fd;
</span></span><span style=display:flex><span>  u8  keeping <span style=color:#666>=</span> <span style=color:#666>0</span>, res;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 若 fault = crash_mode = 2，则处于 crash exploration 模式且崩溃了
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>// 若 fault = crash_mode = 0，则处于普通模式，且没有崩溃或超时
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (fault <span style=color:#666>==</span> crash_mode) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Keep only if there are new bits in the map, add to queue for
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       future fuzzing, etc. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 如果没发现新的路径，就忽略
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// has_new_bits 返回值：0 表示无成果；1 表示 hit count 变动；2 表示发现了新的边
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(hnb <span style=color:#666>=</span> <span style=color:#00a000>has_new_bits</span>(virgin_bits))) {
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (crash_mode) total_crashes<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 这是用例的文件名，描述了 id、来历
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    fn <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/queue/id:%06u,%s&#34;</span>, out_dir, queued_paths,
</span></span><span style=display:flex><span>                      <span style=color:#00a000>describe_op</span>(hnb));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//把这个用例加到队列中，这个用例是queue_top
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>add_to_queue</span>(fn, len, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (hnb <span style=color:#666>==</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>      queue_top<span style=color:#666>-&gt;</span>has_new_cov <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>      queued_with_cov<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    queue_top<span style=color:#666>-&gt;</span>exec_cksum <span style=color:#666>=</span> <span style=color:#00a000>hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Try to calibrate inline; this also calls update_bitmap_score() when
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       successful. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//校准这个用例
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    res <span style=color:#666>=</span> <span style=color:#00a000>calibrate_case</span>(argv, queue_top, mem, queue_cycle <span style=color:#666>-</span> <span style=color:#666>1</span>, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (res <span style=color:#666>==</span> FAULT_ERROR)
</span></span><span style=display:flex><span>      <span style=color:#00a000>FATAL</span>(<span style=color:#b44>&#34;Unable to execute target application&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(fn, O_WRONLY <span style=color:#666>|</span> O_CREAT <span style=color:#666>|</span> O_EXCL, <span style=color:#666>0600</span>);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to create &#39;%s&#39;&#34;</span>, fn);
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_write</span>(fd, mem, len, fn);
</span></span><span style=display:flex><span>    <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    keeping <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>switch</span> (fault) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//**********************************************超时*******************************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>FAULT_TMOUT</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Timeouts are not very interesting, but we&#39;re still obliged to keep
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         a handful of samples. We use the presence of new bits in the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         hang-specific bitmap as a signal of uniqueness. In &#34;dumb&#34; mode, we
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         just keep everything. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      total_tmouts<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (unique_hangs <span style=color:#666>&gt;=</span> KEEP_UNIQUE_HANG) <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// simplify_trace 函数是只保留「是否命中」而不保留 count，这和路径压缩的trace_mini有点像
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>simplify_trace</span>((u32<span style=color:#666>*</span>)trace_bits);
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// 若在 timeout 用例中，没有发现新的边，则丢弃
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#00a000>has_new_bits</span>(virgin_tmout)) <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      unique_tmouts<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Before saving, we make sure that it&#39;s a genuine hang by re-running
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         the target with a more generous timeout (unless the default timeout
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         is already generous). */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (exec_tmout <span style=color:#666>&lt;</span> hang_tmout) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        u8 new_fault;
</span></span><span style=display:flex><span>        <span style=color:#00a000>write_to_testcase</span>(mem, len);
</span></span><span style=display:flex><span>        new_fault <span style=color:#666>=</span> <span style=color:#00a000>run_target</span>(argv, hang_tmout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* A corner case that one user reported bumping into: increasing the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           timeout actually uncovers a crash. Make sure we don&#39;t discard it if
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           so. */</span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// 重跑结果是 crash
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>stop_soon <span style=color:#666>&amp;&amp;</span> new_fault <span style=color:#666>==</span> FAULT_CRASH) <span style=color:#a2f;font-weight:700>goto</span> keep_as_crash;
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// 重跑正常结束了，丢弃
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (stop_soon <span style=color:#666>||</span> new_fault <span style=color:#666>!=</span> FAULT_TMOUT) <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      fn <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/hangs/id:%06llu,%s&#34;</span>, out_dir,
</span></span><span style=display:flex><span>                        unique_hangs, <span style=color:#00a000>describe_op</span>(<span style=color:#666>0</span>));
</span></span><span style=display:flex><span>      unique_hangs<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      last_hang_time <span style=color:#666>=</span> <span style=color:#00a000>get_cur_time</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//************************************************crash***********************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>FAULT_CRASH</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a0a000>keep_as_crash</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* This is handled in a manner roughly similar to timeouts,
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         except for slightly different limits and no need to re-run test
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         cases. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      total_crashes<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (unique_crashes <span style=color:#666>&gt;=</span> KEEP_UNIQUE_CRASH) <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>simplify_trace</span>((u32<span style=color:#666>*</span>)trace_bits);
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// 若这与其他的 crash 本质相同，则丢弃
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#00a000>has_new_bits</span>(virgin_crash)) <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>unique_crashes) <span style=color:#00a000>write_crash_readme</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      fn <span style=color:#666>=</span> <span style=color:#00a000>alloc_printf</span>(<span style=color:#b44>&#34;%s/crashes/id:%06llu,sig:%02u,%s&#34;</span>, out_dir,
</span></span><span style=display:flex><span>                        unique_crashes, kill_signal, <span style=color:#00a000>describe_op</span>(<span style=color:#666>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      unique_crashes<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      last_crash_time <span style=color:#666>=</span> <span style=color:#00a000>get_cur_time</span>();
</span></span><span style=display:flex><span>      last_crash_execs <span style=color:#666>=</span> total_execs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>FAULT_ERROR</span>: <span style=color:#00a000>FATAL</span>(<span style=color:#b44>&#34;Unable to execute target application&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>default</span><span style=color:#666>:</span> <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* If we&#39;re here, we apparently want to save the crash or hang
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     test case, too. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(fn, O_WRONLY <span style=color:#666>|</span> O_CREAT <span style=color:#666>|</span> O_EXCL, <span style=color:#666>0600</span>);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to create &#39;%s&#39;&#34;</span>, fn);
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_write</span>(fd, mem, len, fn);
</span></span><span style=display:flex><span>  <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_free</span>(fn);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> keeping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=fuzz_one-相关函数>fuzz_one 相关函数
<a class=header-anchor href=#fuzz_one-%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0></a></h1><h2 id=common_fuzz_stuff>common_fuzz_stuff
<a class=header-anchor href=#common_fuzz_stuff></a></h2><ul><li>可以看到这就是个集成函数，把write_to_testcase,run_target,save_if_interesting集成到一起，方便fuzz_one使用</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Write a modified test case, run program, process results. Handle
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   error conditions, returning 1 if it&#39;s time to bail out. This is
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   a helper function for fuzz_one(). */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>EXP_ST u8 <span style=color:#00a000>common_fuzz_stuff</span>(<span style=color:#0b0;font-weight:700>char</span><span style=color:#666>**</span> argv, u8<span style=color:#666>*</span> out_buf, u32 len) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8 fault;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//这个和afl_postprocess有关，之前已经分析过了
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (post_handler) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    out_buf <span style=color:#666>=</span> <span style=color:#00a000>post_handler</span>(out_buf, <span style=color:#666>&amp;</span>len);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>out_buf <span style=color:#666>||</span> <span style=color:#666>!</span>len) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//将testcase写入target
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#00a000>write_to_testcase</span>(out_buf, len);
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//run_target运行
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  fault <span style=color:#666>=</span> <span style=color:#00a000>run_target</span>(argv, exec_tmout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (stop_soon) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//超时处理
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (fault <span style=color:#666>==</span> FAULT_TMOUT) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (subseq_tmouts<span style=color:#666>++</span> <span style=color:#666>&gt;</span> TMOUT_LIMIT) {
</span></span><span style=display:flex><span>      cur_skipped_paths<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> subseq_tmouts <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Users can hit us with SIGUSR1 to request the current input
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     to be abandoned. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (skip_requested) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     skip_requested <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>     cur_skipped_paths<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>     <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* This handles FAULT_ERROR for us: */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//将save_if_interesting函数的返回值加入到queued_discovered
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  queued_discovered <span style=color:#666>+=</span> <span style=color:#00a000>save_if_interesting</span>(argv, out_buf, len, fault);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//ui
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(stage_cur <span style=color:#666>%</span> stats_update_freq) <span style=color:#666>||</span> stage_cur <span style=color:#666>+</span> <span style=color:#666>1</span> <span style=color:#666>==</span> stage_max)
</span></span><span style=display:flex><span>    <span style=color:#00a000>show_stats</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=calculate_score>calculate_score
<a class=header-anchor href=#calculate_score></a></h2><ul><li>这个是给testcase打分的一个函数，分数的定义都比较主观，也可能是根据经验，这个地方显然是可以根据实际情况优化修改打分机制，进而更好的fuzz</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Calculate case desirability score to adjust the length of havoc fuzzing.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   A helper function for fuzz_one(). Maybe some of these constants should
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   go into config.h. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> u32 <span style=color:#00a000>calculate_score</span>(<span style=color:#a2f;font-weight:700>struct</span> queue_entry<span style=color:#666>*</span> q) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 全局平均校准时间
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  u32 avg_exec_us <span style=color:#666>=</span> total_cal_us <span style=color:#666>/</span> total_cal_cycles;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 全局平均 bitmap 大小
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  u32 avg_bitmap_size <span style=color:#666>=</span> total_bitmap_size <span style=color:#666>/</span> total_bitmap_entries;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  u32 perf_score <span style=color:#666>=</span> <span style=color:#666>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Adjust score based on execution speed of this path, compared to the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     less expensive to fuzz, so we&#39;re giving them more air time. */</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 用例跑得越快，得分越高
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>0.1</span> <span style=color:#666>&gt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>10</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>0.25</span> <span style=color:#666>&gt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>25</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>0.5</span> <span style=color:#666>&gt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>0.75</span> <span style=color:#666>&gt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>75</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>4</span> <span style=color:#666>&lt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>300</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>3</span> <span style=color:#666>&lt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>200</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>exec_us <span style=color:#666>*</span> <span style=color:#666>2</span> <span style=color:#666>&lt;</span> avg_exec_us) perf_score <span style=color:#666>=</span> <span style=color:#666>150</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Adjust score based on bitmap size. The working theory is that better
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 用例覆盖度越高，得分越高
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>0.3</span> <span style=color:#666>&gt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>0.5</span> <span style=color:#666>&gt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>0.75</span> <span style=color:#666>&gt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>1.5</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>3</span> <span style=color:#666>&lt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>0.25</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>2</span> <span style=color:#666>&lt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>0.5</span>;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>bitmap_size <span style=color:#666>*</span> <span style=color:#666>1.5</span> <span style=color:#666>&lt;</span> avg_bitmap_size) perf_score <span style=color:#666>*=</span> <span style=color:#666>0.75</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Adjust score based on handicap. Handicap is proportional to how late
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     in the game we learned about this path. Latecomers are allowed to run
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     for a bit longer until they catch up with the rest. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 如果用例发现得比较晚，则多给一些得分
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>handicap <span style=color:#666>&gt;=</span> <span style=color:#666>4</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    perf_score <span style=color:#666>*=</span> <span style=color:#666>4</span>;
</span></span><span style=display:flex><span>    q<span style=color:#666>-&gt;</span>handicap <span style=color:#666>-=</span> <span style=color:#666>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>handicap) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    perf_score <span style=color:#666>*=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>    q<span style=color:#666>-&gt;</span>handicap<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Final adjustment based on input depth, under the assumption that fuzzing
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     deeper test cases is more likely to reveal stuff that can&#39;t be
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     discovered with traditional fuzzers. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 该用例深度越大，分数越高
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>switch</span> (q<span style=color:#666>-&gt;</span>depth) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>0</span> ... <span style=color:#666>3</span><span style=color:#666>:</span>   <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>4</span> ... <span style=color:#666>7</span><span style=color:#666>:</span>   perf_score <span style=color:#666>*=</span> <span style=color:#666>2</span>; <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>8</span> ... <span style=color:#666>13</span><span style=color:#666>:</span>  perf_score <span style=color:#666>*=</span> <span style=color:#666>3</span>; <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>14</span> ... <span style=color:#666>25</span><span style=color:#666>:</span> perf_score <span style=color:#666>*=</span> <span style=color:#666>4</span>; <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>default</span><span style=color:#666>:</span>        perf_score <span style=color:#666>*=</span> <span style=color:#666>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Make sure that we don&#39;t go over limit. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 最多给 1600 分
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (perf_score <span style=color:#666>&gt;</span> HAVOC_MAX_MULT <span style=color:#666>*</span> <span style=color:#666>100</span>) perf_score <span style=color:#666>=</span> HAVOC_MAX_MULT <span style=color:#666>*</span> <span style=color:#666>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> perf_score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=trim_case>trim_case
<a class=header-anchor href=#trim_case></a></h2><ul><li>此函数用于fuzz_one的TRIMMING阶段</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Trim all new test cases to save cycles when doing deterministic checks. The
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   file size, to keep the stage short and sweet. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> u8 <span style=color:#00a000>trim_case</span>(<span style=color:#0b0;font-weight:700>char</span><span style=color:#666>**</span> argv, <span style=color:#a2f;font-weight:700>struct</span> queue_entry<span style=color:#666>*</span> q, u8<span style=color:#666>*</span> in_buf) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>static</span> u8 tmp[<span style=color:#666>64</span>];
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>static</span> u8 clean_trace[MAP_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8  needs_write <span style=color:#666>=</span> <span style=color:#666>0</span>, fault <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  u32 trim_exec <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  u32 remove_len;
</span></span><span style=display:flex><span>  u32 len_p2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Although the trimmer will be less useful when variable behavior is
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     detected, it will still work to some extent, so we don&#39;t check for
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     this. */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 不裁剪长度小于 5 的用例
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (q<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> <span style=color:#666>5</span>) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name <span style=color:#666>=</span> tmp;
</span></span><span style=display:flex><span>  bytes_trim_in <span style=color:#666>+=</span> q<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Select initial chunk len, starting with large steps. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  len_p2 <span style=color:#666>=</span> <span style=color:#00a000>next_p2</span>(q<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 把输入分成 16 块。最小块长度是 4
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  remove_len <span style=color:#666>=</span> <span style=color:#00a000>MAX</span>(len_p2 <span style=color:#666>/</span> TRIM_START_STEPS, TRIM_MIN_BYTES);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Continue until the number of steps gets too high or the stepover
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     gets too small. */</span>
</span></span><span style=display:flex><span>   <span style=color:#080;font-style:italic>// 尝试以 remove_len 为块长进行裁剪
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>while</span> (remove_len <span style=color:#666>&gt;=</span> <span style=color:#00a000>MAX</span>(len_p2 <span style=color:#666>/</span> TRIM_END_STEPS, TRIM_MIN_BYTES)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u32 remove_pos <span style=color:#666>=</span> remove_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>sprintf</span>(tmp, <span style=color:#b44>&#34;trim %s/%s&#34;</span>, <span style=color:#00a000>DI</span>(remove_len), <span style=color:#00a000>DI</span>(remove_len));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    stage_max <span style=color:#666>=</span> q<span style=color:#666>-&gt;</span>len <span style=color:#666>/</span> remove_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>while</span> (remove_pos <span style=color:#666>&lt;</span> q<span style=color:#666>-&gt;</span>len) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u32 trim_avail <span style=color:#666>=</span> <span style=color:#00a000>MIN</span>(remove_len, q<span style=color:#666>-&gt;</span>len <span style=color:#666>-</span> remove_pos);
</span></span><span style=display:flex><span>      u32 cksum;
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 裁掉这块，写入 out_file
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#00a000>write_with_gap</span>(in_buf, q<span style=color:#666>-&gt;</span>len, remove_pos, trim_avail);
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//调用run_target运行
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      fault <span style=color:#666>=</span> <span style=color:#00a000>run_target</span>(argv, exec_tmout);
</span></span><span style=display:flex><span>      trim_execs<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//运行出错直接终止trim
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (stop_soon <span style=color:#666>||</span> fault <span style=color:#666>==</span> FAULT_ERROR) <span style=color:#a2f;font-weight:700>goto</span> abort_trimming;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Note that we don&#39;t keep track of crashes or hangs here; maybe TODO? */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      cksum <span style=color:#666>=</span> <span style=color:#00a000>hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* If the deletion had no impact on the trace, make it permanent. This
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         isn&#39;t perfect for variable-path inputs, but we&#39;re just making a
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         best-effort pass, so it&#39;s not a big deal if we end up with false
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         negatives every now and then. */</span>
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 若行为不变，则可以裁剪
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (cksum <span style=color:#666>==</span> q<span style=color:#666>-&gt;</span>exec_cksum) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        u32 move_tail <span style=color:#666>=</span> q<span style=color:#666>-&gt;</span>len <span style=color:#666>-</span> remove_pos <span style=color:#666>-</span> trim_avail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q<span style=color:#666>-&gt;</span>len <span style=color:#666>-=</span> trim_avail;
</span></span><span style=display:flex><span>        len_p2  <span style=color:#666>=</span> <span style=color:#00a000>next_p2</span>(q<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>memmove</span>(in_buf <span style=color:#666>+</span> remove_pos, in_buf <span style=color:#666>+</span> remove_pos <span style=color:#666>+</span> trim_avail, 
</span></span><span style=display:flex><span>                move_tail);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Let&#39;s save a clean trace, which will be needed by
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           update_bitmap_score once we&#39;re done with the trimming stuff. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>needs_write) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          needs_write <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>          <span style=color:#00a000>memcpy</span>(clean_trace, trace_bits, MAP_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> remove_pos <span style=color:#666>+=</span> remove_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Since this can be slow, update the screen every now and then. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>(trim_exec<span style=color:#666>++</span> <span style=color:#666>%</span> stats_update_freq)) <span style=color:#00a000>show_stats</span>();
</span></span><span style=display:flex><span>      stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 块长度减半
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    remove_len <span style=color:#666>&gt;&gt;=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* If we have made changes to in_buf, we also need to update the on-disk
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     version of the test case. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (needs_write) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s32 fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>unlink</span>(q<span style=color:#666>-&gt;</span>fname); <span style=color:#080;font-style:italic>/* ignore errors */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(q<span style=color:#666>-&gt;</span>fname, O_WRONLY <span style=color:#666>|</span> O_CREAT <span style=color:#666>|</span> O_EXCL, <span style=color:#666>0600</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to create &#39;%s&#39;&#34;</span>, q<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_write</span>(fd, in_buf, q<span style=color:#666>-&gt;</span>len, q<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>    <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>memcpy</span>(trace_bits, clean_trace, MAP_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#00a000>update_bitmap_score</span>(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a0a000>abort_trimming</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  bytes_trim_out <span style=color:#666>+=</span> q<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> fault;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=fuzz_one准备工作>fuzz_one准备工作
<a class=header-anchor href=#fuzz_one%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c></a></h1><ul><li>总体流程如下</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-text data-lang=text><span style=display:flex><span>1.根据testcase的属性，来决定跳过这次fuzz的概率，favored用例永远是优先的
</span></span><span style=display:flex><span>2.将testcase内容mmap到地址空间用in_buf存储，out_buf存储变异出来的用例
</span></span><span style=display:flex><span>3.CALIBRATION阶段，如果queue_cur-&gt;cal_failed存在，且次数不超过CAL_CHANCES，再次进行校准
</span></span><span style=display:flex><span>4.TRIMMING阶段，如果用例没有被trim，则进行此阶段
</span></span><span style=display:flex><span>5.PERFORMANCE SCORE，调用calculate_score函数计算当前testcase的得分
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>  s32 len, fd, temp_len, i, j;
</span></span><span style=display:flex><span>  u8  <span style=color:#666>*</span>in_buf, <span style=color:#666>*</span>out_buf, <span style=color:#666>*</span>orig_in, <span style=color:#666>*</span>ex_tmp, <span style=color:#666>*</span>eff_map <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;
</span></span><span style=display:flex><span>  u32 splice_cycle <span style=color:#666>=</span> <span style=color:#666>0</span>, perf_score <span style=color:#666>=</span> <span style=color:#666>100</span>, orig_perf, prev_cksum, eff_cnt <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8  ret_val <span style=color:#666>=</span> <span style=color:#666>1</span>, doing_det <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u8  a_collect[MAX_AUTO_EXTRA];
</span></span><span style=display:flex><span>  u32 a_len <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 若有暂未被 fuzz 过的 favored 用例
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (pending_favored) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* If we have any favored, non-fuzzed new arrivals in the queue,
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       possibly skip to them at the expense of already-fuzzed or non-favored
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       cases. */</span>
</span></span><span style=display:flex><span>     <span style=color:#080;font-style:italic>// 若当前用例已经被 fuzz 过了，或当前用例并非 favored，则以 99% 的概率跳过，让新 favored 用例先 fuzz
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> ((queue_cur<span style=color:#666>-&gt;</span>was_fuzzed <span style=color:#666>||</span> <span style=color:#666>!</span>queue_cur<span style=color:#666>-&gt;</span>favored) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>UR</span>(<span style=color:#666>100</span>) <span style=color:#666>&lt;</span> SKIP_TO_NEW_PROB) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>queue_cur<span style=color:#666>-&gt;</span>favored <span style=color:#666>&amp;&amp;</span> queued_paths <span style=color:#666>&gt;</span> <span style=color:#666>10</span>) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 所有 favored 用例都被 fuzz 过，且当前用例并非 favored，且 corpus 大小超过 10
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>/* Otherwise, still possibly skip non-favored cases, albeit less often.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       The odds of skipping stuff are higher for already-fuzzed inputs and
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       lower for never-fuzzed entries. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (queue_cycle <span style=color:#666>&gt;</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>queue_cur<span style=color:#666>-&gt;</span>was_fuzzed) {
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 若当前用例没有被 fuzz 过，以 75% 的概率跳过
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>100</span>) <span style=color:#666>&lt;</span> SKIP_NFAV_NEW_PROB) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 若当前用例被 fuzz 过，则以 95% 的概率跳过
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>100</span>) <span style=color:#666>&lt;</span> SKIP_NFAV_OLD_PROB) <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (not_on_tty) {
</span></span><span style=display:flex><span>    <span style=color:#00a000>ACTF</span>(<span style=color:#b44>&#34;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&#34;</span>,
</span></span><span style=display:flex><span>         current_entry, queued_paths, unique_crashes);
</span></span><span style=display:flex><span>    <span style=color:#00a000>fflush</span>(stdout);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Map the test case into memory. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(queue_cur<span style=color:#666>-&gt;</span>fname, O_RDONLY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to open &#39;%s&#39;&#34;</span>, queue_cur<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  len <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 调用 mmap 把文件挂进地址空间
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  orig_in <span style=color:#666>=</span> in_buf <span style=color:#666>=</span> <span style=color:#00a000>mmap</span>(<span style=color:#666>0</span>, len, PROT_READ <span style=color:#666>|</span> PROT_WRITE, MAP_PRIVATE, fd, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (orig_in <span style=color:#666>==</span> MAP_FAILED) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to mmap &#39;%s&#39;&#34;</span>, queue_cur<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     single byte anyway, so it wouldn&#39;t give us any performance or memory usage
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     benefits. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// out_buf 用来存储变异出来的用例，要交由目标程序执行
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  out_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  subseq_tmouts <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cur_depth <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>depth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/*******************************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   * CALIBRATION (only if failed earlier on) *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   *******************************************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (queue_cur<span style=color:#666>-&gt;</span>cal_failed) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u8 res <span style=color:#666>=</span> FAULT_TMOUT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (queue_cur<span style=color:#666>-&gt;</span>cal_failed <span style=color:#666>&lt;</span> CAL_CHANCES) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Reset exec_cksum to tell calibrate_case to re-execute the testcase
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         avoiding the usage of an invalid trace_bits.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      queue_cur<span style=color:#666>-&gt;</span>exec_cksum <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      res <span style=color:#666>=</span> <span style=color:#00a000>calibrate_case</span>(argv, queue_cur, in_buf, queue_cycle <span style=color:#666>-</span> <span style=color:#666>1</span>, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (res <span style=color:#666>==</span> FAULT_ERROR)
</span></span><span style=display:flex><span>        <span style=color:#00a000>FATAL</span>(<span style=color:#b44>&#34;Unable to execute target application&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (stop_soon <span style=color:#666>||</span> res <span style=color:#666>!=</span> crash_mode) {
</span></span><span style=display:flex><span>      cur_skipped_paths<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   * TRIMMING *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   ************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>queue_cur<span style=color:#666>-&gt;</span>trim_done) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u8 res <span style=color:#666>=</span> <span style=color:#00a000>trim_case</span>(argv, queue_cur, in_buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (res <span style=color:#666>==</span> FAULT_ERROR)
</span></span><span style=display:flex><span>      <span style=color:#00a000>FATAL</span>(<span style=color:#b44>&#34;Unable to execute target application&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (stop_soon) {
</span></span><span style=display:flex><span>      cur_skipped_paths<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Don&#39;t retry trimming, even if it failed. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    queue_cur<span style=color:#666>-&gt;</span>trim_done <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (len <span style=color:#666>!=</span> queue_cur<span style=color:#666>-&gt;</span>len) len <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>memcpy</span>(out_buf, in_buf, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/*********************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   * PERFORMANCE SCORE *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   *********************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_perf <span style=color:#666>=</span> perf_score <span style=color:#666>=</span> <span style=color:#00a000>calculate_score</span>(queue_cur);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Skip right away if -d is given, if we have done deterministic fuzzing on
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     this entry ourselves (was_fuzzed), or if it has gone through deterministic
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     testing in earlier, resumed runs (passed_det). */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (skip_deterministic <span style=color:#666>||</span> queue_cur<span style=color:#666>-&gt;</span>was_fuzzed <span style=color:#666>||</span> queue_cur<span style=color:#666>-&gt;</span>passed_det)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>goto</span> havoc_stage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Skip deterministic fuzzing if exec path checksum puts this out of scope
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     for this master instance. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (master_max <span style=color:#666>&amp;&amp;</span> (queue_cur<span style=color:#666>-&gt;</span>exec_cksum <span style=color:#666>%</span> master_max) <span style=color:#666>!=</span> master_id <span style=color:#666>-</span> <span style=color:#666>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>goto</span> havoc_stage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  doing_det <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span></code></pre></div><h1 id=fuzz_one变异阶段>fuzz_one变异阶段
<a class=header-anchor href=#fuzz_one%e5%8f%98%e5%bc%82%e9%98%b6%e6%ae%b5></a></h1><ul><li>先复习一下之前全局变量的相关内容</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> u64 stage_finds[<span style=color:#666>32</span>],           <span style=color:#080;font-style:italic>/* Patterns found per fuzz stage    */</span>
</span></span><span style=display:flex><span>           stage_cycles[<span style=color:#666>32</span>];          <span style=color:#080;font-style:italic>/* Execs per fuzz stage             */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* Interesting values, as per config.h */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//**********************确定性变异的内容*************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>static</span> s8  interesting_8[]  <span style=color:#666>=</span> { INTERESTING_8 };
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> s16 interesting_16[] <span style=color:#666>=</span> { INTERESTING_8, INTERESTING_16 };
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> s32 interesting_32[] <span style=color:#666>=</span> { INTERESTING_8, INTERESTING_16, INTERESTING_32 };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* Fuzzing stages */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//****************************变异所处的阶段*****************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>enum</span> {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 00 */</span> STAGE_FLIP1,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 01 */</span> STAGE_FLIP2,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 02 */</span> STAGE_FLIP4,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 03 */</span> STAGE_FLIP8,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 04 */</span> STAGE_FLIP16,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 05 */</span> STAGE_FLIP32,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 06 */</span> STAGE_ARITH8,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 07 */</span> STAGE_ARITH16,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 08 */</span> STAGE_ARITH32,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 09 */</span> STAGE_INTEREST8,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 10 */</span> STAGE_INTEREST16,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 11 */</span> STAGE_INTEREST32,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 12 */</span> STAGE_EXTRAS_UO,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 13 */</span> STAGE_EXTRAS_UI,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 14 */</span> STAGE_EXTRAS_AO,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 15 */</span> STAGE_HAVOC,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 16 */</span> STAGE_SPLICE
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* Stage value types */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 00 */</span> STAGE_VAL_NONE,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 01 */</span> STAGE_VAL_LE,
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* 02 */</span> STAGE_VAL_BE
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=simple-bitflip>simple bitflip
<a class=header-anchor href=#simple-bitflip></a></h2><ul><li>解释bitflip一些内容 ，a/b 的意思是翻转连续的 a 个 bit、步长为 b</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-text data-lang=text><span style=display:flex><span>#define FLIP_BIT(_ar, _b): 这是一个宏定义，定义了一个名为 FLIP_BIT 的宏。这个宏接受两个参数：_ar 和 _b。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>u8* _arf = (u8*)(_ar);: 将输入参数 _ar 转换为一个指向无符号8位整数 (u8) 的指针，并将其赋值给 _arf。_ar 通常是一个数组或者指向数据的指针。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>u32 _bf = (_b);: 将输入参数 _b 赋值给 _bf。_b 是表示要翻转的比特位位置的整数。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7));:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(_bf) &gt;&gt; 3: 这一步将 _bf 右移3位，相当于将 _bf 除以8。因为一个字节有8个比特，所以这个操作计算出 _bf 所在的字节的索引。
</span></span><span style=display:flex><span>_arf[(_bf) &gt;&gt; 3]: 根据前一步的结果，找到对应的字节。
</span></span><span style=display:flex><span>(_bf) &amp; 7: 这个操作取 _bf 的后3位（因为 7 的二进制是 111），它表示 _bf 在字节中的具体位置（0到7）。
</span></span><span style=display:flex><span>(128 &gt;&gt; ((_bf) &amp; 7)): 128 的二进制表示为 10000000，这个操作右移 _bf &amp; 7 位，以得到要翻转的比特位的掩码。例如，如果 _bf &amp; 7 为 0，结果是 10000000；如果 _bf &amp; 7 为 1，结果是 01000000。
</span></span><span style=display:flex><span>_arf[...] ^= ...: 最后使用 XOR 运算符 (^=) 对找到的字节中的指定比特位进行翻转。如果该比特位原来是 1，则变成 0；如果原来是 0，则变成 1。
</span></span></code></pre></div><ul><li>这里重点分析bitflip 1/1(其他都和它类似),bitflip 8/1(因为有个创建 eff_map 空间的步骤)</li></ul><h3 id=bitflip-11>bitflip 1/1
<a class=header-anchor href=#bitflip-11></a></h3><ul><li>从头到尾，步长为 1 bit，每次翻转 1 bit</li><li>调用 common_fuzz_stuff() 去实验，自动寻找 extra，构建词典(此部分在afl-fuzz源码分析上篇中已经分析过，和maybe_add_auto函数有关)。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/*********************************************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   * SIMPLE BITFLIP (+dictionary construction) *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   *********************************************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//翻转 _ar 的第 b 个 bit
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#080>#define FLIP_BIT(_ar, _b) do { \
</span></span></span><span style=display:flex><span><span style=color:#080>    u8* _arf = (u8*)(_ar); \
</span></span></span><span style=display:flex><span><span style=color:#080>    u32 _bf = (_b); \
</span></span></span><span style=display:flex><span><span style=color:#080>    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \
</span></span></span><span style=display:flex><span><span style=color:#080>  } while (0)
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Single walking bit. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip1&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//注意这里是左移3位，那么stage_cur就代表每一个bit，也就是逐bit
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  stage_max   <span style=color:#666>=</span> len <span style=color:#666>&lt;&lt;</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 1/1&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_val_type <span style=color:#666>=</span> STAGE_VAL_NONE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  prev_cksum <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>exec_cksum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>; stage_cur <span style=color:#666>&lt;</span> stage_max; stage_cur<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//计算出字节地址
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    stage_cur_byte <span style=color:#666>=</span> stage_cur <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//每第八次翻转并执行之后，都会检查 trace_bits 的改变情况
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode <span style=color:#666>&amp;&amp;</span> (stage_cur <span style=color:#666>&amp;</span> <span style=color:#666>7</span>) <span style=color:#666>==</span> <span style=color:#666>7</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u32 cksum <span style=color:#666>=</span> <span style=color:#00a000>hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>      如果翻转一个字节的 LSB，发现程序行为与原用例不同，则这个字节可能属于一个 extra token。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>      如果翻转这个字节的 LSB，程序行为与翻转前一个 LSB 的行为不同，则说明这里是 token 的分界点。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>      */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//如果都到了testcase的最后，并且cksum==prev_cksum，调用maybe_add_auto(a_collect, a_len);
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (stage_cur <span style=color:#666>==</span> stage_max <span style=color:#666>-</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> cksum <span style=color:#666>==</span> prev_cksum) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* If at end of file and we are still collecting a string, grab the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           final character and force output. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//这个地方是之前分析过的autodictionary
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>if</span> (a_len <span style=color:#666>&lt;</span> MAX_AUTO_EXTRA) a_collect[a_len] <span style=color:#666>=</span> out_buf[stage_cur <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        a_len<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (a_len <span style=color:#666>&gt;=</span> MIN_AUTO_EXTRA <span style=color:#666>&amp;&amp;</span> a_len <span style=color:#666>&lt;=</span> MAX_AUTO_EXTRA)
</span></span><span style=display:flex><span>          <span style=color:#00a000>maybe_add_auto</span>(a_collect, a_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//如果cksum!=prev_cksum，则将之前已经在a_collect的内容添加到autodictionary中，但是由于这次变化后导致cksum不同
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#080;font-style:italic>//说明这次变化是token 的分界点，需要让a_len=0
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (cksum <span style=color:#666>!=</span> prev_cksum) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Otherwise, if the checksum has changed, see if we have something
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           worthwhile queued up, and collect that if the answer is yes. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (a_len <span style=color:#666>&gt;=</span> MIN_AUTO_EXTRA <span style=color:#666>&amp;&amp;</span> a_len <span style=color:#666>&lt;=</span> MAX_AUTO_EXTRA)
</span></span><span style=display:flex><span>          <span style=color:#00a000>maybe_add_auto</span>(a_collect, a_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        a_len <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>        prev_cksum <span style=color:#666>=</span> cksum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Continue collecting string, but only if the bit flip actually made
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         any difference - we don&#39;t want no-op tokens. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (cksum <span style=color:#666>!=</span> queue_cur<span style=color:#666>-&gt;</span>exec_cksum) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (a_len <span style=color:#666>&lt;</span> MAX_AUTO_EXTRA) a_collect[a_len] <span style=color:#666>=</span> out_buf[stage_cur <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>];        
</span></span><span style=display:flex><span>        a_len<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP1]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP1] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=bitflip-21>bitflip 2/1
<a class=header-anchor href=#bitflip-21></a></h3><ul><li>从头到尾，步长为 1 bit，每次翻转相邻的 2 bit</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Two walking bits. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 2/1&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip2&#34;</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> (len <span style=color:#666>&lt;&lt;</span> <span style=color:#666>3</span>) <span style=color:#666>-</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>; stage_cur <span style=color:#666>&lt;</span> stage_max; stage_cur<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> stage_cur <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP2]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP2] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=bitflip-41>bitflip 4/1
<a class=header-anchor href=#bitflip-41></a></h3><ul><li>从头到尾，步长为 1 bit，每次翻转相邻的 4 bit</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Four walking bits. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 4/1&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip4&#34;</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> (len <span style=color:#666>&lt;&lt;</span> <span style=color:#666>3</span>) <span style=color:#666>-</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>; stage_cur <span style=color:#666>&lt;</span> stage_max; stage_cur<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> stage_cur <span style=color:#666>&gt;&gt;</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#00a000>FLIP_BIT</span>(out_buf, stage_cur <span style=color:#666>+</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP4]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP4] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=bitflip-88>bitflip 8/8
<a class=header-anchor href=#bitflip-88></a></h3><ul><li>从头到尾，步长为 1 byte，每次翻转相邻的 1 byte</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>//这个宏将位置 _p 右移 EFF_MAP_SCALE2 位。EFF_MAP_SCALE2 是一个常量，通常设置为 3，这意味着位置 _p 被除以 8。该宏用于计算输入数据在 eff_map 中的字节偏移量。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#080>#define EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#080;font-style:italic>//这个宏计算 _x 除以 8 后的余数。它用于判断 _x 在当前字节中的具体位置。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#080>#define EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))
</span></span></span><span style=display:flex><span><span style=color:#080>#define EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))
</span></span></span><span style=display:flex><span><span style=color:#080>#define EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Initialize effector map for the next step (see comments below). Always
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     flag first and last byte as doing something. */</span>
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//effector map
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>//创建 eff_map 空间，长度为测试用例字节数，并将头尾置 1，其余为 0
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  eff_map    <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc</span>(<span style=color:#00a000>EFF_ALEN</span>(len));
</span></span><span style=display:flex><span>  eff_map[<span style=color:#666>0</span>] <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>EFF_APOS</span>(len <span style=color:#666>-</span> <span style=color:#666>1</span>) <span style=color:#666>!=</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>    eff_map[<span style=color:#00a000>EFF_APOS</span>(len <span style=color:#666>-</span> <span style=color:#666>1</span>)] <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    eff_cnt<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Walking byte. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 8/8&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip8&#34;</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>; stage_cur <span style=color:#666>&lt;</span> stage_max; stage_cur<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> stage_cur;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    out_buf[stage_cur] <span style=color:#666>^=</span> <span style=color:#666>0xFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* We also use this stage to pull off a simple trick: we identify
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       bytes that seem to have no effect on the current execution path
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       even when fully flipped - and we skip them during more expensive
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       deterministic stages, such as arithmetics or known ints. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(stage_cur)]) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u32 cksum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* If in dumb mode or if the file is very short, just flag everything
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         without wasting time on checksums. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//翻转后检查 eff_map ，如果此字节对应项为 0 ，则检查翻转以后是否带来了路径变化，是则置 1.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>dumb_mode <span style=color:#666>&amp;&amp;</span> len <span style=color:#666>&gt;=</span> EFF_MIN_LEN)
</span></span><span style=display:flex><span>        cksum <span style=color:#666>=</span> <span style=color:#00a000>hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>else</span>
</span></span><span style=display:flex><span>        cksum <span style=color:#666>=</span> <span style=color:#666>~</span>queue_cur<span style=color:#666>-&gt;</span>exec_cksum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>// 用来区分一些无效byte，为后面的阶段做准备,通过一个eff_map 来标记有效byte
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      <span style=color:#a2f;font-weight:700>if</span> (cksum <span style=color:#666>!=</span> queue_cur<span style=color:#666>-&gt;</span>exec_cksum) {
</span></span><span style=display:flex><span>        eff_map[<span style=color:#00a000>EFF_APOS</span>(stage_cur)] <span style=color:#666>=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>        eff_cnt<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    out_buf[stage_cur] <span style=color:#666>^=</span> <span style=color:#666>0xFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* If the effector map is more than EFF_MAX_PERC dense, just flag the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     whole thing as worth fuzzing, since we wouldn&#39;t be saving much time
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     anyway. */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>  当整个 byte 的改变都没有带来任何路径变化时， AFL 认为这个 byte 是没有价值的，后续会根据 eff_map 来选择性跳过。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>  白皮书指出，这样的字节可能只是单纯的非元数据。
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>  */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (eff_cnt <span style=color:#666>!=</span> <span style=color:#00a000>EFF_ALEN</span>(len) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>      eff_cnt <span style=color:#666>*</span> <span style=color:#666>100</span> <span style=color:#666>/</span> <span style=color:#00a000>EFF_ALEN</span>(len) <span style=color:#666>&gt;</span> EFF_MAX_PERC) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 如果eff_map 大于 EFF_MAX_PERC ,那么直接把整个testcase标记为值得fuzz的
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>memset</span>(eff_map, <span style=color:#666>1</span>, <span style=color:#00a000>EFF_ALEN</span>(len));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    blocks_eff_select <span style=color:#666>+=</span> <span style=color:#00a000>EFF_ALEN</span>(len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    blocks_eff_select <span style=color:#666>+=</span> eff_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  blocks_eff_total <span style=color:#666>+=</span> <span style=color:#00a000>EFF_ALEN</span>(len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP8]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP8] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=bitflip-168>bitflip 16/8
<a class=header-anchor href=#bitflip-168></a></h3><ul><li>从头到尾，步长为 1 byte，每次翻转相邻的 2 byte</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Two walking bytes. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>goto</span> skip_bitflip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 16/8&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip16&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> len <span style=color:#666>-</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> len <span style=color:#666>-</span> <span style=color:#666>1</span>; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Let&#39;s consult the effector map... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i)] <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i <span style=color:#666>+</span> <span style=color:#666>1</span>)]) {
</span></span><span style=display:flex><span>      stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> i) <span style=color:#666>^=</span> <span style=color:#666>0xFFFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>    stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> i) <span style=color:#666>^=</span> <span style=color:#666>0xFFFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP16]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP16] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=bitflip-328>bitflip 32/8
<a class=header-anchor href=#bitflip-328></a></h3><ul><li>从头到尾，步长为 1 byte，每次翻转相邻的 4 byte</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Four walking bytes. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;bitflip 32/8&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;flip32&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> len <span style=color:#666>-</span> <span style=color:#666>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> len <span style=color:#666>-</span> <span style=color:#666>3</span>; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Let&#39;s consult the effector map... */</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i)] <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i <span style=color:#666>+</span> <span style=color:#666>1</span>)] <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i <span style=color:#666>+</span> <span style=color:#666>2</span>)] <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i <span style=color:#666>+</span> <span style=color:#666>3</span>)]) {
</span></span><span style=display:flex><span>      stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> i) <span style=color:#666>^=</span> <span style=color:#666>0xFFFFFFFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>    stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> i) <span style=color:#666>^=</span> <span style=color:#666>0xFFFFFFFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_FLIP32]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_FLIP32] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h2 id=arithmetic-incdec>arithmetic inc/dec
<a class=header-anchor href=#arithmetic-incdec></a></h2><ul><li>这一阶段对测试用例做加减法变异。config.h 中将宏 ARITH_MAX 定义为 35，代表了算术运算范围为 -35 到 +35.</li><li>其中用 could_be_bitflip 来检查是否此步骤会产生和 bitflip 一样的结果（用位比较做到的），以减少重复执行。同时， eff_map 也指导了此步骤</li><li>arith 16/8与arith 32/8和arith 8/8没有太多区别，就不贴源码了</li></ul><h3 id=arith-88>arith 8/8
<a class=header-anchor href=#arith-88></a></h3><ul><li>从头到尾，步长为 1 byte，对每个字节都从 -35 一直试到 +35</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* 8-bit arithmetics. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;arith 8/8&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;arith8&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> <span style=color:#666>2</span> <span style=color:#666>*</span> len <span style=color:#666>*</span> ARITH_MAX;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_val_type <span style=color:#666>=</span> STAGE_VAL_LE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> len; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u8 orig <span style=color:#666>=</span> out_buf[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Let&#39;s consult the effector map... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i)]) {
</span></span><span style=display:flex><span>      stage_max <span style=color:#666>-=</span> <span style=color:#666>2</span> <span style=color:#666>*</span> ARITH_MAX;
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>1</span>; j <span style=color:#666>&lt;=</span> ARITH_MAX; j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      u8 r <span style=color:#666>=</span> orig <span style=color:#666>^</span> (orig <span style=color:#666>+</span> j);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Do arithmetic operations only if the result couldn&#39;t be a product
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         of a bitflip. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#00a000>could_be_bitflip</span>(r)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stage_cur_val <span style=color:#666>=</span> j;
</span></span><span style=display:flex><span>        out_buf[i] <span style=color:#666>=</span> orig <span style=color:#666>+</span> j;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>        stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      r <span style=color:#666>=</span>  orig <span style=color:#666>^</span> (orig <span style=color:#666>-</span> j);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#00a000>could_be_bitflip</span>(r)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stage_cur_val <span style=color:#666>=</span> <span style=color:#666>-</span>j;
</span></span><span style=display:flex><span>        out_buf[i] <span style=color:#666>=</span> orig <span style=color:#666>-</span> j;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>        stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      out_buf[i] <span style=color:#666>=</span> orig;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_ARITH8]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_ARITH8] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=arith-168>arith 16/8
<a class=header-anchor href=#arith-168></a></h3><ul><li>从头到尾，步长为 1 byte，对每个 word 都从 -35 一直试到 +35</li></ul><h3 id=arith-328>arith 32/8
<a class=header-anchor href=#arith-328></a></h3><ul><li>从头到尾，步长为 1 byte，对每个 dword 都从 -35 一直试到 +35</li></ul><h2 id=interesting-values>interesting values
<a class=header-anchor href=#interesting-values></a></h2><ul><li>这一阶段用一些特殊的常数对测试用例做替换操作，could_be_arith 与上一阶段去重。并且，这一阶段同样受 eff_map 影响</li></ul><h3 id=interest-88>interest 8/8
<a class=header-anchor href=#interest-88></a></h3><ul><li>从头到尾，步长为 1 byte，用 INTERESTING_8 中的每个数替换测试用例 1 byte</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;interest 8/8&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;int8&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> len <span style=color:#666>*</span> <span style=color:#a2f;font-weight:700>sizeof</span>(interesting_8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_val_type <span style=color:#666>=</span> STAGE_VAL_LE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Setting 8-bit integers. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> len; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u8 orig <span style=color:#666>=</span> out_buf[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Let&#39;s consult the effector map... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>eff_map[<span style=color:#00a000>EFF_APOS</span>(i)]) {
</span></span><span style=display:flex><span>      stage_max <span style=color:#666>-=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(interesting_8);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> <span style=color:#a2f;font-weight:700>sizeof</span>(interesting_8); j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Skip if the value could be a product of bitflips or arithmetics. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>could_be_bitflip</span>(orig <span style=color:#666>^</span> (u8)interesting_8[j]) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          <span style=color:#00a000>could_be_arith</span>(orig, (u8)interesting_8[j], <span style=color:#666>1</span>)) {
</span></span><span style=display:flex><span>        stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      stage_cur_val <span style=color:#666>=</span> interesting_8[j];
</span></span><span style=display:flex><span>      out_buf[i] <span style=color:#666>=</span> interesting_8[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//复原
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      out_buf[i] <span style=color:#666>=</span> orig;
</span></span><span style=display:flex><span>      stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_INTEREST8]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_INTEREST8] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=interest-168>interest 16/8
<a class=header-anchor href=#interest-168></a></h3><ul><li>从头到尾，步长为 1 byte，用 INTERESTING_16 中的每个数替换测试用例 1 word</li></ul><h3 id=interest-328>interest 32/8
<a class=header-anchor href=#interest-328></a></h3><ul><li>从头到尾，步长为 1 byte，用 INTERESTING_32 中的每个数替换测试用例 1 dword</li></ul><h2 id=dictionary-stuff>dictionary stuff
<a class=header-anchor href=#dictionary-stuff></a></h2><ul><li>这一阶段用字典内容对测试用例进行替换</li></ul><h3 id=user-extras-over>user extras (over)
<a class=header-anchor href=#user-extras-over></a></h3><ul><li>extras在之前就按长度从小到大排了。从头到尾，步长为 1 byte，用 extras 中的每个字符串替换测试用例相同长度（这是个双重循环）。受 eff_map 影响。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>extras_cnt) <span style=color:#a2f;font-weight:700>goto</span> skip_user_extras;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Overwrite with user-supplied extras. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;user extras (over)&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;ext_UO&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> extras_cnt <span style=color:#666>*</span> len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_val_type <span style=color:#666>=</span> STAGE_VAL_NONE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> len; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u32 last_len <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Extras are sorted by size, from smallest to largest. This means
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       that we don&#39;t have to worry about restoring the buffer in
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       between writes at a particular offset determined by the outer
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       loop. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> extras_cnt; j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         skip them if there&#39;s no room to insert the payload, if the token
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         is redundant, or if its entire span has no bytes set in the effector
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>         map. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> ((extras_cnt <span style=color:#666>&gt;</span> MAX_DET_EXTRAS <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>UR</span>(extras_cnt) <span style=color:#666>&gt;=</span> MAX_DET_EXTRAS) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          extras[j].len <span style=color:#666>&gt;</span> len <span style=color:#666>-</span> i <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          <span style=color:#666>!</span><span style=color:#00a000>memcmp</span>(extras[j].data, out_buf <span style=color:#666>+</span> i, extras[j].len) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>          <span style=color:#666>!</span><span style=color:#00a000>memchr</span>(eff_map <span style=color:#666>+</span> <span style=color:#00a000>EFF_APOS</span>(i), <span style=color:#666>1</span>, <span style=color:#00a000>EFF_SPAN_ALEN</span>(i, extras[j].len))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stage_max<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      last_len <span style=color:#666>=</span> extras[j].len;
</span></span><span style=display:flex><span>      <span style=color:#00a000>memcpy</span>(out_buf <span style=color:#666>+</span> i, extras[j].data, last_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, len)) <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Restore all the clobbered memory. */</span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>memcpy</span>(out_buf <span style=color:#666>+</span> i, in_buf <span style=color:#666>+</span> i, last_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_EXTRAS_UO]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_EXTRAS_UO] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=user-extras-insert>user extras (insert)
<a class=header-anchor href=#user-extras-insert></a></h3><ul><li>这一步是插入extras，和上一个替换还不太一样</li><li>从头到尾，步长为 1 byte，将 extras 中的每个字符串尝试插入测试用例（用了ex_tmp 变量）。不受 eff_map 影响。</li><li>这一阶段复原相比于上述阶段更耗时，涉及到空间分配、拷贝、复原等操作。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span> <span style=color:#080;font-style:italic>/* Insertion of user-supplied extras. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;user extras (insert)&#34;</span>;
</span></span><span style=display:flex><span>  stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;ext_UI&#34;</span>;
</span></span><span style=display:flex><span>  stage_cur   <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>  stage_max   <span style=color:#666>=</span> extras_cnt <span style=color:#666>*</span> (len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> new_hit_cnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ex_tmp <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc</span>(len <span style=color:#666>+</span> MAX_DICT_FILE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;=</span> len; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_byte <span style=color:#666>=</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> extras_cnt; j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (len <span style=color:#666>+</span> extras[j].len <span style=color:#666>&gt;</span> MAX_FILE) {
</span></span><span style=display:flex><span>        stage_max<span style=color:#666>--</span>; 
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Insert token */</span>
</span></span><span style=display:flex><span>      <span style=color:#00a000>memcpy</span>(ex_tmp <span style=color:#666>+</span> i, extras[j].data, extras[j].len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Copy tail */</span>
</span></span><span style=display:flex><span>      <span style=color:#00a000>memcpy</span>(ex_tmp <span style=color:#666>+</span> i <span style=color:#666>+</span> extras[j].len, out_buf <span style=color:#666>+</span> i, len <span style=color:#666>-</span> i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, ex_tmp, len <span style=color:#666>+</span> extras[j].len)) {
</span></span><span style=display:flex><span>        <span style=color:#00a000>ck_free</span>(ex_tmp);
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      stage_cur<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Copy head */</span>
</span></span><span style=display:flex><span>    ex_tmp[i] <span style=color:#666>=</span> out_buf[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00a000>ck_free</span>(ex_tmp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage_finds[STAGE_EXTRAS_UI]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>  stage_cycles[STAGE_EXTRAS_UI] <span style=color:#666>+=</span> stage_max;
</span></span></code></pre></div><h3 id=auto-extras-over>auto extras (over)
<a class=header-anchor href=#auto-extras-over></a></h3><ul><li>上文提到 bitflip 时会产生字典。在这一步将使用这个字典。从头到尾，步长为 1 byte，用其中的每个字符串替换测试用例相同长度。受 eff_map 影响。</li></ul><h2 id=random-havoc>random havoc
<a class=header-anchor href=#random-havoc></a></h2><ul><li>很随机的进行变异操作，所以也有不少论文对这里进行优化</li><li>总体有如下操作</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-text data-lang=text><span style=display:flex><span>随机选取某个 bit 进行翻转
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 byte，将其设置为随机的 interesting value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 word，并随机选取大、小端序，将其设置为随机的 interesting value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 dword，并随机选取大、小端序，将其设置为随机的 interesting value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 byte，对其减去一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 byte，对其加上一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 word，并随机选取大、小端序，对其减去一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 word，并随机选取大、小端序，对其加上一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 dword，并随机选取大、小端序，对其减去一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 dword，并随机选取大、小端序，对其加上一个随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取某个 byte，将其设置为随机数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机删除一段 bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取一个位置，插入一段随机长度的内容，其中 75% 的概率是插入原文中随机位置的内容，25% 的概率是插入一段随机选取的数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取一个位置，替换为一段随机长度的内容，其中 75% 的概率是替换成原文中随机位置的内容，25% 的概率是替换成一段随机选取的数
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）替换
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）插入
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>变异后调用common_fuzz_stuff跑出结果，如果发现了新成果，那么剩余的 havoc 执行次数会翻倍
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#define HAVOC_CYCLES_INIT 1024
</span></span></span><span style=display:flex><span><span style=color:#080>#define HAVOC_CYCLES 256
</span></span></span><span style=display:flex><span><span style=color:#080>#define SPLICE_HAVOC 32
</span></span></span><span style=display:flex><span><span style=color:#080>#define HAVOC_MIN 16
</span></span></span><span style=display:flex><span><span style=color:#080>#define HAVOC_STACK_POW2 7
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#a0a000>havoc_stage</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>//给一些变量赋初值然后进行havoc
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  stage_cur_byte <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* The havoc stage mutation code is also invoked when splicing files; if the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     splice_cycle variable is set, generate different descriptions and such. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>splice_cycle) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_name  <span style=color:#666>=</span> <span style=color:#b44>&#34;havoc&#34;</span>;
</span></span><span style=display:flex><span>    stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;havoc&#34;</span>;
</span></span><span style=display:flex><span>     <span style=color:#080;font-style:italic>// 决定 havoc 实验次数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    stage_max   <span style=color:#666>=</span> (doing_det <span style=color:#666>?</span> <span style=color:#a0a000>HAVOC_CYCLES_INIT</span> : HAVOC_CYCLES) <span style=color:#666>*</span>
</span></span><span style=display:flex><span>                  perf_score <span style=color:#666>/</span> havoc_div <span style=color:#666>/</span> <span style=color:#666>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>static</span> u8 tmp[<span style=color:#666>32</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    perf_score <span style=color:#666>=</span> orig_perf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>sprintf</span>(tmp, <span style=color:#b44>&#34;splice %u&#34;</span>, splice_cycle);
</span></span><span style=display:flex><span>    stage_name  <span style=color:#666>=</span> tmp;
</span></span><span style=display:flex><span>    stage_short <span style=color:#666>=</span> <span style=color:#b44>&#34;splice&#34;</span>;
</span></span><span style=display:flex><span>    stage_max   <span style=color:#666>=</span> SPLICE_HAVOC <span style=color:#666>*</span> perf_score <span style=color:#666>/</span> havoc_div <span style=color:#666>/</span> <span style=color:#666>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (stage_max <span style=color:#666>&lt;</span> HAVOC_MIN) stage_max <span style=color:#666>=</span> HAVOC_MIN;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  temp_len <span style=color:#666>=</span> len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  orig_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  havoc_queued <span style=color:#666>=</span> queued_paths;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* We essentially just do several thousand runs (depending on perf_score)
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     where we take the input file and make random stacked tweaks. */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// 执行 havoc 阶段
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>for</span> (stage_cur <span style=color:#666>=</span> <span style=color:#666>0</span>; stage_cur <span style=color:#666>&lt;</span> stage_max; stage_cur<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    u32 use_stacking <span style=color:#666>=</span> <span style=color:#666>1</span> <span style=color:#666>&lt;&lt;</span> (<span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(HAVOC_STACK_POW2));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stage_cur_val <span style=color:#666>=</span> use_stacking;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> use_stacking; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>switch</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>15</span> <span style=color:#666>+</span> ((extras_cnt <span style=color:#666>+</span> a_extras_cnt) <span style=color:#666>?</span> <span style=color:#666>2</span> <span style=color:#666>:</span> <span style=color:#666>0</span>))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 bit 进行翻转
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>0</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Flip a single bit somewhere. Spooky! */</span>
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>          <span style=color:#00a000>FLIP_BIT</span>(out_buf, <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>&lt;&lt;</span> <span style=color:#666>3</span>));
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 byte，将其设置为随机的 interesting value
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>1</span><span style=color:#666>:</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Set byte to interesting value. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          out_buf[<span style=color:#00a000>UR</span>(temp_len)] <span style=color:#666>=</span> interesting_8[<span style=color:#00a000>UR</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(interesting_8))];
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 word，并随机选取大、小端序，将其设置为随机的 interesting value
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>2</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Set word to interesting value, randomly choosing endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>)) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              interesting_16[<span style=color:#00a000>UR</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(interesting_16) <span style=color:#666>&gt;&gt;</span> <span style=color:#666>1</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>)) <span style=color:#666>=</span> <span style=color:#00a000>SWAP16</span>(
</span></span><span style=display:flex><span>              interesting_16[<span style=color:#00a000>UR</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(interesting_16) <span style=color:#666>&gt;&gt;</span> <span style=color:#666>1</span>)]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 dword，并随机选取大、小端序，将其设置为随机的 interesting value
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>3</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Set dword to interesting value, randomly choosing endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>4</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>)) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              interesting_32[<span style=color:#00a000>UR</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(interesting_32) <span style=color:#666>&gt;&gt;</span> <span style=color:#666>2</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>)) <span style=color:#666>=</span> <span style=color:#00a000>SWAP32</span>(
</span></span><span style=display:flex><span>              interesting_32[<span style=color:#00a000>UR</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(interesting_32) <span style=color:#666>&gt;&gt;</span> <span style=color:#666>2</span>)]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 byte，对其减去一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>4</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly subtract from byte. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          out_buf[<span style=color:#00a000>UR</span>(temp_len)] <span style=color:#666>-=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 byte，对其加上一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>5</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly add to byte. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          out_buf[<span style=color:#00a000>UR</span>(temp_len)] <span style=color:#666>+=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 word，并随机选取大、小端序，对其减去一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>6</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly subtract from word, random endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>-=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>            u16 num <span style=color:#666>=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>SWAP16</span>(<span style=color:#00a000>SWAP16</span>(<span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos)) <span style=color:#666>-</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 word，并随机选取大、小端序，对其加上一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>7</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly add to word, random endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>+=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>            u16 num <span style=color:#666>=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>SWAP16</span>(<span style=color:#00a000>SWAP16</span>(<span style=color:#666>*</span>(u16<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos)) <span style=color:#666>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 dword，并随机选取大、小端序，对其减去一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>8</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly subtract from dword, random endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>4</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>-=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>            u32 num <span style=color:#666>=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>SWAP32</span>(<span style=color:#00a000>SWAP32</span>(<span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos)) <span style=color:#666>-</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 dword，并随机选取大、小端序，对其加上一个随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>9</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Randomly add to dword, random endian. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>4</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>2</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>+=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 pos <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>3</span>);
</span></span><span style=display:flex><span>            u32 num <span style=color:#666>=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(ARITH_MAX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>SWAP32</span>(<span style=color:#00a000>SWAP32</span>(<span style=color:#666>*</span>(u32<span style=color:#666>*</span>)(out_buf <span style=color:#666>+</span> pos)) <span style=color:#666>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取某个 byte，将其设置为随机数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>10</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#080;font-style:italic>/* Just set a random byte to a random value. Because,
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>             why not. We use XOR with 1-255 to eliminate the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>             possibility of a no-op. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          out_buf[<span style=color:#00a000>UR</span>(temp_len)] <span style=color:#666>^=</span> <span style=color:#666>1</span> <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(<span style=color:#666>255</span>);
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机删除一段 bytes
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>11</span> ... <span style=color:#666>12</span><span style=color:#666>:</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Delete bytes. We&#39;re making this a bit more likely
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>               than insertion (the next option) in hopes of keeping
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>               files reasonably small. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 del_from, del_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Don&#39;t delete too much. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            del_len <span style=color:#666>=</span> <span style=color:#00a000>choose_block_len</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            del_from <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> del_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>memmove</span>(out_buf <span style=color:#666>+</span> del_from, out_buf <span style=color:#666>+</span> del_from <span style=color:#666>+</span> del_len,
</span></span><span style=display:flex><span>                    temp_len <span style=color:#666>-</span> del_from <span style=color:#666>-</span> del_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            temp_len <span style=color:#666>-=</span> del_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取一个位置，插入一段随机长度的内容，其中 75% 的概率是插入原文中随机位置的内容，25% 的概率是插入一段随机选取的数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>13</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>+</span> HAVOC_BLK_XL <span style=color:#666>&lt;</span> MAX_FILE) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u8  actually_clone <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(<span style=color:#666>4</span>);
</span></span><span style=display:flex><span>            u32 clone_from, clone_to, clone_len;
</span></span><span style=display:flex><span>            u8<span style=color:#666>*</span> new_buf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (actually_clone) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              clone_len  <span style=color:#666>=</span> <span style=color:#00a000>choose_block_len</span>(temp_len);
</span></span><span style=display:flex><span>              clone_from <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> clone_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              clone_len <span style=color:#666>=</span> <span style=color:#00a000>choose_block_len</span>(HAVOC_BLK_XL);
</span></span><span style=display:flex><span>              clone_from <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            clone_to   <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            new_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(temp_len <span style=color:#666>+</span> clone_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Head */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>memcpy</span>(new_buf, out_buf, clone_to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Inserted part */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (actually_clone)
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(new_buf <span style=color:#666>+</span> clone_to, out_buf <span style=color:#666>+</span> clone_from, clone_len);
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>else</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>memset</span>(new_buf <span style=color:#666>+</span> clone_to,
</span></span><span style=display:flex><span>                     <span style=color:#00a000>UR</span>(<span style=color:#666>2</span>) <span style=color:#666>?</span> <span style=color:#00a000>UR</span>(<span style=color:#666>256</span>) <span style=color:#666>:</span> out_buf[<span style=color:#00a000>UR</span>(temp_len)], clone_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Tail */</span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>memcpy</span>(new_buf <span style=color:#666>+</span> clone_to <span style=color:#666>+</span> clone_len, out_buf <span style=color:#666>+</span> clone_to,
</span></span><span style=display:flex><span>                   temp_len <span style=color:#666>-</span> clone_to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>ck_free</span>(out_buf);
</span></span><span style=display:flex><span>            out_buf <span style=color:#666>=</span> new_buf;
</span></span><span style=display:flex><span>            temp_len <span style=color:#666>+=</span> clone_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取一个位置，替换为一段随机长度的内容，其中 75% 的概率是替换成原文中随机位置的内容，25% 的概率是替换成一段随机选取的数
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>14</span><span style=color:#666>:</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Overwrite bytes with a randomly selected chunk (75%) or fixed
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>               bytes (25%). */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 copy_from, copy_to, copy_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            copy_len  <span style=color:#666>=</span> <span style=color:#00a000>choose_block_len</span>(temp_len <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            copy_from <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> copy_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>            copy_to   <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> copy_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>UR</span>(<span style=color:#666>4</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#a2f;font-weight:700>if</span> (copy_from <span style=color:#666>!=</span> copy_to)
</span></span><span style=display:flex><span>                <span style=color:#00a000>memmove</span>(out_buf <span style=color:#666>+</span> copy_to, out_buf <span style=color:#666>+</span> copy_from, copy_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#00a000>memset</span>(out_buf <span style=color:#666>+</span> copy_to,
</span></span><span style=display:flex><span>                          <span style=color:#00a000>UR</span>(<span style=color:#666>2</span>) <span style=color:#666>?</span> <span style=color:#00a000>UR</span>(<span style=color:#666>256</span>) <span style=color:#666>:</span> out_buf[<span style=color:#00a000>UR</span>(temp_len)], copy_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Values 15 and 16 can be selected only if there are any extras
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>           present in the dictionaries. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）替换
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>15</span><span style=color:#666>:</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Overwrite bytes with an extra. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>extras_cnt <span style=color:#666>||</span> (a_extras_cnt <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>UR</span>(<span style=color:#666>2</span>))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* No user-specified extras or odds in our favor. Let&#39;s use an
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>                 auto-detected one. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              u32 use_extra <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(a_extras_cnt);
</span></span><span style=display:flex><span>              u32 extra_len <span style=color:#666>=</span> a_extras[use_extra].len;
</span></span><span style=display:flex><span>              u32 insert_at;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#a2f;font-weight:700>if</span> (extra_len <span style=color:#666>&gt;</span> temp_len) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              insert_at <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> extra_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(out_buf <span style=color:#666>+</span> insert_at, a_extras[use_extra].data, extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* No auto extras or odds in our favor. Use the dictionary. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              u32 use_extra <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(extras_cnt);
</span></span><span style=display:flex><span>              u32 extra_len <span style=color:#666>=</span> extras[use_extra].len;
</span></span><span style=display:flex><span>              u32 insert_at;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#a2f;font-weight:700>if</span> (extra_len <span style=color:#666>&gt;</span> temp_len) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              insert_at <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>-</span> extra_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(out_buf <span style=color:#666>+</span> insert_at, extras[use_extra].data, extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>//随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）插入
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>16</span><span style=color:#666>:</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            u32 use_extra, extra_len, insert_at <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(temp_len <span style=color:#666>+</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>            u8<span style=color:#666>*</span> new_buf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Insert an extra. Do the same dice-rolling stuff as for the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>               previous case. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>extras_cnt <span style=color:#666>||</span> (a_extras_cnt <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>UR</span>(<span style=color:#666>2</span>))) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              use_extra <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(a_extras_cnt);
</span></span><span style=display:flex><span>              extra_len <span style=color:#666>=</span> a_extras[use_extra].len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>+</span> extra_len <span style=color:#666>&gt;=</span> MAX_FILE) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              new_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(temp_len <span style=color:#666>+</span> extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* Head */</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(new_buf, out_buf, insert_at);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* Inserted part */</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(new_buf <span style=color:#666>+</span> insert_at, a_extras[use_extra].data, extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              use_extra <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(extras_cnt);
</span></span><span style=display:flex><span>              extra_len <span style=color:#666>=</span> extras[use_extra].len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>+</span> extra_len <span style=color:#666>&gt;=</span> MAX_FILE) <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              new_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(temp_len <span style=color:#666>+</span> extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* Head */</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(new_buf, out_buf, insert_at);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              <span style=color:#080;font-style:italic>/* Inserted part */</span>
</span></span><span style=display:flex><span>              <span style=color:#00a000>memcpy</span>(new_buf <span style=color:#666>+</span> insert_at, extras[use_extra].data, extra_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>/* Tail */</span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>memcpy</span>(new_buf <span style=color:#666>+</span> insert_at <span style=color:#666>+</span> extra_len, out_buf <span style=color:#666>+</span> insert_at,
</span></span><span style=display:flex><span>                   temp_len <span style=color:#666>-</span> insert_at);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#00a000>ck_free</span>(out_buf);
</span></span><span style=display:flex><span>            out_buf   <span style=color:#666>=</span> new_buf;
</span></span><span style=display:flex><span>            temp_len <span style=color:#666>+=</span> extra_len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//变异后调用common_fuzz_stuff跑出结果，如果发现了新成果，那么剩余的 havoc 执行次数会翻倍
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>common_fuzz_stuff</span>(argv, out_buf, temp_len))
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>goto</span> abandon_entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* out_buf might have been mangled a bit, so let&#39;s restore it to its
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       original size and shape. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (temp_len <span style=color:#666>&lt;</span> len) out_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_realloc</span>(out_buf, len);
</span></span><span style=display:flex><span>    temp_len <span style=color:#666>=</span> len;
</span></span><span style=display:flex><span>    <span style=color:#00a000>memcpy</span>(out_buf, in_buf, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* If we&#39;re finding new stuff, let&#39;s run for a bit longer, limits
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       permitting. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (queued_paths <span style=color:#666>!=</span> havoc_queued) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (perf_score <span style=color:#666>&lt;=</span> HAVOC_MAX_MULT <span style=color:#666>*</span> <span style=color:#666>100</span>) {
</span></span><span style=display:flex><span>        stage_max  <span style=color:#666>*=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>        perf_score <span style=color:#666>*=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      havoc_queued <span style=color:#666>=</span> queued_paths;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  new_hit_cnt <span style=color:#666>=</span> queued_paths <span style=color:#666>+</span> unique_crashes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>splice_cycle) {
</span></span><span style=display:flex><span>    stage_finds[STAGE_HAVOC]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>    stage_cycles[STAGE_HAVOC] <span style=color:#666>+=</span> stage_max;
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    stage_finds[STAGE_SPLICE]  <span style=color:#666>+=</span> new_hit_cnt <span style=color:#666>-</span> orig_hit_cnt;
</span></span><span style=display:flex><span>    stage_cycles[STAGE_SPLICE] <span style=color:#666>+=</span> stage_max;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h2 id=splicing>splicing
<a class=header-anchor href=#splicing></a></h2><ul><li>随机选取一个足够长、且差异足够大的杂交目标，然后随机选择分割点，把本用例的前面一段和杂交目标的后面一段拼接起来。这样会形成一个新的用例，将这个新用例拿去执行 havoc 阶段变异</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#080;font-style:italic>/************
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   * SPLICING *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>   ************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* This is a last-resort strategy triggered by a full round with no findings.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     It takes the current input file, randomly selects another input, and
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     splices them together at some offset, then relies on the havoc
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     code to mutate that blob. */</span>
</span></span><span style=display:flex><span><span style=color:#080>#define SPLICE_CYCLES 15
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#a0a000>retry_splicing</span>:
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// SPLICE_CYCLES 被定义为 15
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>if</span> (use_splicing <span style=color:#666>&amp;&amp;</span> splice_cycle<span style=color:#666>++</span> <span style=color:#666>&lt;</span> SPLICE_CYCLES <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>      queued_paths <span style=color:#666>&gt;</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> queue_cur<span style=color:#666>-&gt;</span>len <span style=color:#666>&gt;</span> <span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>struct</span> queue_entry<span style=color:#666>*</span> target;
</span></span><span style=display:flex><span>    u32 tid, split_at;
</span></span><span style=display:flex><span>    u8<span style=color:#666>*</span> new_buf;
</span></span><span style=display:flex><span>    s32 f_diff, l_diff;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* First of all, if we&#39;ve modified in_buf for havoc, let&#39;s clean that
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       up... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (in_buf <span style=color:#666>!=</span> orig_in) {
</span></span><span style=display:flex><span>      <span style=color:#00a000>ck_free</span>(in_buf);
</span></span><span style=display:flex><span>      in_buf <span style=color:#666>=</span> orig_in;
</span></span><span style=display:flex><span>      len <span style=color:#666>=</span> queue_cur<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Pick a random queue entry and seek to it. Don&#39;t splice with yourself. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 随机选择一个杂交对象
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>do</span> { tid <span style=color:#666>=</span> <span style=color:#00a000>UR</span>(queued_paths); } <span style=color:#a2f;font-weight:700>while</span> (tid <span style=color:#666>==</span> current_entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    splicing_with <span style=color:#666>=</span> tid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 在链表中跳转，找到目标
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    target <span style=color:#666>=</span> queue;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>while</span> (tid <span style=color:#666>&gt;=</span> <span style=color:#666>100</span>) { target <span style=color:#666>=</span> target<span style=color:#666>-&gt;</span>next_100; tid <span style=color:#666>-=</span> <span style=color:#666>100</span>; }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>while</span> (tid<span style=color:#666>--</span>) target <span style=color:#666>=</span> target<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 杂交目标要足够长
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>/* Make sure that the target has a reasonable length. */</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>while</span> (target <span style=color:#666>&amp;&amp;</span> (target<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> <span style=color:#666>2</span> <span style=color:#666>||</span> target <span style=color:#666>==</span> queue_cur)) {
</span></span><span style=display:flex><span>      target <span style=color:#666>=</span> target<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>      splicing_with<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>target) <span style=color:#a2f;font-weight:700>goto</span> retry_splicing;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 读入杂交目标
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>/* Read the testcase into a new buffer. */</span>
</span></span><span style=display:flex><span>    fd <span style=color:#666>=</span> <span style=color:#00a000>open</span>(target<span style=color:#666>-&gt;</span>fname, O_RDONLY);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (fd <span style=color:#666>&lt;</span> <span style=color:#666>0</span>) <span style=color:#00a000>PFATAL</span>(<span style=color:#b44>&#34;Unable to open &#39;%s&#39;&#34;</span>, target<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    new_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(target<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_read</span>(fd, new_buf, target<span style=color:#666>-&gt;</span>len, target<span style=color:#666>-&gt;</span>fname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>close</span>(fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Find a suitable splicing location, somewhere between the first and
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       the last differing byte. Bail out if the difference is just a single
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>       byte or so. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 找到两个串第一个、最后一个不同的位置
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>locate_diffs</span>(in_buf, new_buf, <span style=color:#00a000>MIN</span>(len, target<span style=color:#666>-&gt;</span>len), <span style=color:#666>&amp;</span>f_diff, <span style=color:#666>&amp;</span>l_diff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 如果两个串差异只有一两个字节，则重新选择
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (f_diff <span style=color:#666>&lt;</span> <span style=color:#666>0</span> <span style=color:#666>||</span> l_diff <span style=color:#666>&lt;</span> <span style=color:#666>2</span> <span style=color:#666>||</span> f_diff <span style=color:#666>==</span> l_diff) {
</span></span><span style=display:flex><span>      <span style=color:#00a000>ck_free</span>(new_buf);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>goto</span> retry_splicing;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Split somewhere between the first and last differing byte. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 分割点，生成一个新用例 A[:split_at] + B[split_at:]
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    split_at <span style=color:#666>=</span> f_diff <span style=color:#666>+</span> <span style=color:#00a000>UR</span>(l_diff <span style=color:#666>-</span> f_diff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Do the thing. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    len <span style=color:#666>=</span> target<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>    <span style=color:#00a000>memcpy</span>(new_buf, in_buf, split_at);
</span></span><span style=display:flex><span>    in_buf <span style=color:#666>=</span> new_buf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>ck_free</span>(out_buf);
</span></span><span style=display:flex><span>    out_buf <span style=color:#666>=</span> <span style=color:#00a000>ck_alloc_nozero</span>(len);
</span></span><span style=display:flex><span>    <span style=color:#00a000>memcpy</span>(out_buf, in_buf, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 执行一遍 havoc
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>goto</span> havoc_stage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=locate_diffs>locate_diffs
<a class=header-anchor href=#locate_diffs></a></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>locate_diffs</span>(u8<span style=color:#666>*</span> ptr1, u8<span style=color:#666>*</span> ptr2, u32 len, s32<span style=color:#666>*</span> first, s32<span style=color:#666>*</span> last) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  s32 f_loc <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>  s32 l_loc <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>  u32 pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>for</span> (pos <span style=color:#666>=</span> <span style=color:#666>0</span>; pos <span style=color:#666>&lt;</span> len; pos<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>*</span>(ptr1<span style=color:#666>++</span>) <span style=color:#666>!=</span> <span style=color:#666>*</span>(ptr2<span style=color:#666>++</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> (f_loc <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) f_loc <span style=color:#666>=</span> pos;
</span></span><span style=display:flex><span>      l_loc <span style=color:#666>=</span> pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>first <span style=color:#666>=</span> f_loc;
</span></span><span style=display:flex><span>  <span style=color:#666>*</span>last <span style=color:#666>=</span> l_loc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=心得体会>心得体会
<a class=header-anchor href=#%e5%bf%83%e5%be%97%e4%bd%93%e4%bc%9a></a></h1><p>至此afl-fuzz的相关源码全部分析完了，以下是一些心得体会</p><p>这是笔者第一次读中型项目的源代码，花了很多时间和精力去阅读，首先感谢前辈们的知识分享，站在巨人的肩膀上，才让我学习fuzz源码更加得心应手，这里贴出一些主要参考过的博客，感谢这些师傅们的无私分享
<a href=https://v3rdant.cn/Fuzz.AFL-All-in-One/ title=https://v3rdant.cn/Fuzz.AFL-All-in-One/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://v3rdant.cn/Fuzz.AFL-All-in-One/
<i class="fa fa-external-link-alt"></i>
</a><a href=https://www.ruanx.net/afl-source-6/ title=https://www.ruanx.net/afl-source-6/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.ruanx.net/afl-source-6/
<i class="fa fa-external-link-alt"></i>
</a><a href=https://xidoo.top/2022/01/afl-rsc4/ title=https://xidoo.top/2022/01/afl-rsc4/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://xidoo.top/2022/01/afl-rsc4/
<i class="fa fa-external-link-alt"></i>
</a><a href=https://www.iotsec-zone.com/article/199#218-setup_stdio_file title=https://www.iotsec-zone.com/article/199#218-setup_stdio_file rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.iotsec-zone.com/article/199#218-setup_stdio_file
<i class="fa fa-external-link-alt"></i>
</a><a href=https://xidoo.top/2022/01/afl-white-book/ title=https://xidoo.top/2022/01/afl-white-book/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://xidoo.top/2022/01/afl-white-book/
<i class="fa fa-external-link-alt"></i></a></p><p>不论学习什么新的东西，信息收集是很重要的一步，先是搜到了好多学习资料，在他人理解的基础上入门，再形成自己的理解，这是一个很重要的过程。如果能力很强的师傅，也可以就靠自己去读源码，但是笔者认为读源码还是多搜资料，结合已有的文章去学习领悟</p><p>读源码要搞清楚自己的目的，因为源码有很多技术规范，还有一些和目的不相关的函数，要学会分辨哪些是不重要的，绕开这些，直奔核心目的很重要。同时对于这些代码，如果只是看表面，这就是一些字母和数字的集合，给变量赋值，调用函数，但如果浮在这个表面是什么都学不到的。要形成自己的理解，比如看到某个变量就知道它和哪一步相关，fuzz源码中testcase是个什么结构(队列)，一些函数有什么作用(比如update_bitmap_score函数，我一看到这个就立刻能想起来它和top_rated有关，再比如save_if_interesting函数，一下子就能想到这个和是否产生新覆盖有关)，以及整个函数的流程(比如fuzz_one函数，无非是准备阶段，加上变异阶段，准备阶段又有好几步，变异阶段有好几种变异)。</p><p>总的来说上述是一种抽象能力，这种能力是很重要的。因为源码有些细节很快就会忘记，但是把它抽象出来，这种就很难忘记，也利于整体把握。读完fuzz源码后应该会进行一些fuzz实操的尝试了，也可以读读fuzz相关论文，进一步的学习</p></div><footer class=post-footer><div class=post-tags><a href=/tags/fuzz>Fuzz</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="f1ow - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="f1ow - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
afl-fuzz源码分析下篇</li><li class=post-copyright-author><strong>本文作者： </strong>f1ow</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/ title=afl-fuzz源码分析下篇>https://zp9080.github.io/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/shellcode/%E5%9F%BA%E4%BA%8Eptrace%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/ rel=next title=基于ptrace的沙箱绕过><i class="fa fa-chevron-left"></i> 基于ptrace的沙箱绕过</a></div><div class="post-nav-prev post-nav-item"><a href=/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%AD%E7%AF%87/ rel=prev title=afl-fuzz源码分析中篇>afl-fuzz源码分析中篇
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2024 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>f1ow</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.126.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>鄂ICP备 20240001号</a>
<img src=/imgs/gongan.png alt=鄂公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42010002002000" target=_blank>鄂公网安备 42010002002000 号</a></div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel>
</a><a target=_blank href=https://upyun.com title=又拍云><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/upyun.png alt=又拍云>
</a><a target=_blank href=https://github.com title=Github><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/github.svg alt=Github>
</a><span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=https://zp9080.github.io/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://zp9080.github.io/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://zp9080.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://zp9080.github.io/3rd"}},"version":"4.6.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src=/js/main.min.befa9b7d22ec90da86c74c5dbff5ee42c12e9fc6d6f4448bfcc596cc329b19e8.js defer></script></body></html>